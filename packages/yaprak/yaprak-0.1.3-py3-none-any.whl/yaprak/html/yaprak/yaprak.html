<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>yaprak.yaprak API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>yaprak.yaprak</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# SPDX-FileCopyrightText: Â© 2023 N. Sertac Artan &lt;artans.github@gmail.com&gt;
# SPDX-License-Identifier: MIT

import json        
import os
from abc import ABC, abstractmethod

class Yaprak(ABC):
    &#34;&#34;&#34;Base class for the yaprak package.&#34;&#34;&#34;
    def __init__(self, config = None):
        &#39;&#39;&#39;
            The yaprak class initializes with empty local variables. If a
            configuration file name is given as an argument, this will trigger
            the loading of a configuration file via the self.readConfig()
            method.

            Args:
                config (str): (Optional) configuration filename. If given, the 
                    self.readConfig() method will be called.
        &#39;&#39;&#39;
        self.config = {}
        self.current_iteration = {}
        self.globals = {}
        self.__IDs = []
        self.__processes = []
        self.__inFileList = []
        self.__outFileList = []
        self.__outPath = None
        if config:
            self.readConfig(config)
            self.globals = {&#39;outPath&#39;: self.__outPath}

    def run(self):
        &#39;&#39;&#39;
            The main method to call to go through all the input files, execute
            all the processes, populate the output files, and report anything 
            pertinent to each input file.

            This method runs for all instances (defined as an ID, an input file,
            and an output file). If any of the parameters don&#39;t exist, the
            operation stops.

            For each process a process_spec is given (probably read from the 
            configuration file. This process_spec will be passed to the method,
            and executed. The process_spec can include basic parameters such as 
            numbers, booleans, and strings, which the json file supports.

            The process will be skipped if the process_spec does not have the
            apply property. This way, processes can be disabled quickly by just
            removing the apply property.

            Args:
                None

            Returns:
                None
        &#39;&#39;&#39;
        for instances in zip(self.__IDs, self.__inFileList, self.__outFileList):
            self.current_iteration = {&#39;ID&#39;: instances[0], &#39;inFile&#39;: instances[1],
                                      &#39;outFile&#39;: instances[2]}
            self.load(instances[1])
            for process_spec in self.__processes:
                if process_spec[&#39;apply&#39;]:
                    function = getattr(self, process_spec[&#39;process&#39;])
                    function(process_spec)
            self.save(instances[2])
            self.report()

    @abstractmethod
    def load(self, file):
        &#39;&#39;&#39;
            An abstract method as a placeholder for the file load function. The
            child class must implement this function.

            Args:
                file (str): Name of the file to load

            Returns:
                None
        &#39;&#39;&#39;
        raise NotImplementedError(&#34;The load method in Yaprak is abstract\
        and should be implemented in the child class&#34;)

    @abstractmethod
    def save(self, file):
        &#39;&#39;&#39;
            An abstract method as a placeholder for the file save function. The
            child class must implement this function.

            Args:
                file (str): Name of the file to save

            Returns:
                None
        &#39;&#39;&#39;
        raise NotImplementedError(&#34;The save method in Yaprak is abstract\
        and should be implemented in the child class&#34;)

    @abstractmethod
    def report(self):
        &#39;&#39;&#39;
            An abstract method as a placeholder for the report function. The
            child class must implement this function.

            Args:
                None: 

            Returns:
                None
        &#39;&#39;&#39;
        raise NotImplementedError(&#34;The report method in Yaprak is abstract\
        and should be implemented in the child class&#34;)

    # Config
    def readConfig(self, file): 
        &#39;&#39;&#39;
            Reads the json configuration file. The IDs, input file list, and
            output file lists will be populated with full paths to the files, if
            they exist in the configuration file. If output path is defined and
            non-existing, the output path will be created. Processes will also
            be populated if they are listed in the configuration file. 

            This function will be called automatically in __init__() if the
            configuration file is given to __init__().

            Args:
                file (str): Name of the configuration file to load 

            Returns:
                None
        &#39;&#39;&#39;
        self.config = load_json_file(file)
        if &#34;IDs&#34; in self.config:
            self.__IDs = self.config[&#39;IDs&#39;] 
        if &#34;inFileList&#34; in self.config:
            self.__inFileList = fullPathFileList(self.config, &#39;in&#39;)
        if &#34;outFileList&#34; in self.config:
            self.__outFileList = fullPathFileList(self.config, &#39;out&#39;)
        if &#34;outPath&#34; in self.config:
            self.__outPath = self.config[&#39;outPath&#39;] 
            mkdir_p(self.__outPath)
        if &#34;processes&#34; in self.config:
            self.__processes = [x for x in self.config[&#39;processes&#39;]]

    def setConfig(self, config):
        self.config = config

    def getConfig(self):
        return self.config

    def generateConfig(self):
        pass 

    # IDs
    def setIDs(self, IDs):
        self.__IDs = IDs

    def getIDs(self):
        return self.__IDs 

    def generateIDs(self):
        pass 

    # File Lists
    def setInFileList(self, fileList):
        self.__inFileList = fileList

    def getInFileList(self):
        return self.__inFileList 

    def setOutFileList(self, fileList):
        self.__outFileList = fileList

    def getOutFileList(self):
        return self.__outFileList 

    # Processes
    def setProcesses(self, processes):
        self.__processes = processes

    def getProcesses(self):
        return self.__processes 

    def generateProcesses(self):
        pass 

class Summary(Yaprak):
    &#34;&#34;&#34;Summary class for the yaprak package.&#34;&#34;&#34;
    def __init__(self, config = None):
        &#39;&#39;&#39;
            The summary class is similar to the base yaprak class. The primary
            difference is that the Summary class saves the output to a single
            output file, and individual files. This class is not intended to be
            used as a way to aggregate many output files into a single file. 
            Instead, this class is aimed for the use cases, where some basic 
            information is collected from each file (e.g. statistics, or
            feature vectors), and summarized in the single output file.

            Args:
                config (str): (Optional) configuration filename. If given, the 
                    self.readConfig() method will be called.
        &#39;&#39;&#39;
        Yaprak.__init__(self, config)
        self.outSummaryFile = None
        self.readAdditionalConfig(config)

    # Config
    def readAdditionalConfig(self, config): 
        &#39;&#39;&#39;
            Reads the global information from the configuration file, that is
            the name of the output summary file, if it exists.

            Args:
                config (str): Name of the configuration file to load 

            Returns:
                None
        &#39;&#39;&#39;
        if &#34;outSummaryFile&#34; in self.config:
            self.outSummaryFile = fullPathFile(self.config, &#39;outSummary&#39;)

    def run(self):
        &#39;&#39;&#39;
            This method is similar to the base class&#39; run method in that it
            loads all the input files, run the processes, and report the
            pertinent information. The main difference is that in this class 
            only one output file is generated, which consolidates outputs from 
            all the input files.

            Args:
                None: 

            Returns:
                None
        &#39;&#39;&#39;
        IDs = self.getIDs()
        inFileList = self.getInFileList()
        processes = self.getProcesses()
        for instances in zip(IDs, inFileList):
            self.current_iteration = {&#39;ID&#39;: instances[0], 
                                      &#39;inFile&#39;: instances[1]}
            self.load(instances[1])
            for process_spec in processes:
                if process_spec[&#39;apply&#39;]:
                    function = getattr(self, process_spec[&#39;process&#39;])
                    function(process_spec)
        self.summarize()
        self.report()

    @abstractmethod
    def summarize(self):
        &#39;&#39;&#39;
            An abstract method as a placeholder for the summarize function. The
            child class must implement this function.

            Args:
                None: 

            Returns:
                None
        &#39;&#39;&#39;
        raise NotImplementedError(&#34;The summarize method in Yaprak is abstract\
        and should be implemented in the child class&#34;)

def fullPathFile(config, type):
        pathName = type + &#34;Path&#34;
        fileName = type + &#34;File&#34;
        fullPathFileOutput = None 
        # Path and filename separate
        if pathName in config and fileName in config:
            path = config[pathName] 
            fileName = config[fileName]
            fullPathFileOutput = path + fileName
        # Full path
        elif fileName in config: 
            fullPathFileOutput = config[fileName] 
        return fullPathFileOutput 

def fullPathFileList(config, type):
        pathName = type + &#34;Path&#34;
        fileListName = type + &#34;FileList&#34;
            
        # Grab file info from config.
        fullPathFileListOutput = []
        # Path and filename separate
        if pathName in config and fileListName in config:
            path = config[pathName] 
            fileList = config[fileListName]
            fullPathFileListOutput = [path + file for file in fileList]
        # Full path
        elif fileListName in config: 
            fullPathFileListOutput = config[fileListName] 
        return fullPathFileListOutput 

def load_json_file(fileName):
    &#34;&#34;&#34;
        Loads a json file as config 
        
        Args:
            fileName (str): Name of input json file.

        Returns:
            dict: Json data as key-value pairs dictionary 
    &#34;&#34;&#34;
    with open(fileName) as json_file:
        json_data = json.load(json_file)
    return json_data

def mkdir_p(path):
    &#34;&#34;&#34;
        Creates the directory path if it doesn&#39;t exist
        
        Args:
            path (str): Full path of the directory to be created 

        Returns:
            int: 0 if directory exists, 1 if directory does not exist. If the
            latter, this function creates the new library.
    &#34;&#34;&#34;
    if os.path.exists(path):
        print(&#34;Output directory exists, overwrites are possible.&#34;)
        return 0
    print(&#34;Creating new directory &#34; + path + &#34;.&#34;)
    os.makedirs(path)
    return 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="yaprak.yaprak.fullPathFile"><code class="name flex">
<span>def <span class="ident">fullPathFile</span></span>(<span>config, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fullPathFile(config, type):
        pathName = type + &#34;Path&#34;
        fileName = type + &#34;File&#34;
        fullPathFileOutput = None 
        # Path and filename separate
        if pathName in config and fileName in config:
            path = config[pathName] 
            fileName = config[fileName]
            fullPathFileOutput = path + fileName
        # Full path
        elif fileName in config: 
            fullPathFileOutput = config[fileName] 
        return fullPathFileOutput </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.fullPathFileList"><code class="name flex">
<span>def <span class="ident">fullPathFileList</span></span>(<span>config, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fullPathFileList(config, type):
        pathName = type + &#34;Path&#34;
        fileListName = type + &#34;FileList&#34;
            
        # Grab file info from config.
        fullPathFileListOutput = []
        # Path and filename separate
        if pathName in config and fileListName in config:
            path = config[pathName] 
            fileList = config[fileListName]
            fullPathFileListOutput = [path + file for file in fileList]
        # Full path
        elif fileListName in config: 
            fullPathFileListOutput = config[fileListName] 
        return fullPathFileListOutput </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.load_json_file"><code class="name flex">
<span>def <span class="ident">load_json_file</span></span>(<span>fileName)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a json file as config </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fileName</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of input json file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Json data as key-value pairs dictionary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_json_file(fileName):
    &#34;&#34;&#34;
        Loads a json file as config 
        
        Args:
            fileName (str): Name of input json file.

        Returns:
            dict: Json data as key-value pairs dictionary 
    &#34;&#34;&#34;
    with open(fileName) as json_file:
        json_data = json.load(json_file)
    return json_data</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.mkdir_p"><code class="name flex">
<span>def <span class="ident">mkdir_p</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the directory path if it doesn't exist</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Full path of the directory to be created </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>0 if directory exists, 1 if directory does not exist. If the</dd>
</dl>
<p>latter, this function creates the new library.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mkdir_p(path):
    &#34;&#34;&#34;
        Creates the directory path if it doesn&#39;t exist
        
        Args:
            path (str): Full path of the directory to be created 

        Returns:
            int: 0 if directory exists, 1 if directory does not exist. If the
            latter, this function creates the new library.
    &#34;&#34;&#34;
    if os.path.exists(path):
        print(&#34;Output directory exists, overwrites are possible.&#34;)
        return 0
    print(&#34;Creating new directory &#34; + path + &#34;.&#34;)
    os.makedirs(path)
    return 1</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="yaprak.yaprak.Summary"><code class="flex name class">
<span>class <span class="ident">Summary</span></span>
<span>(</span><span>config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary class for the yaprak package.</p>
<p>The summary class is similar to the base yaprak class. The primary
difference is that the Summary class saves the output to a single
output file, and individual files. This class is not intended to be
used as a way to aggregate many output files into a single file.
Instead, this class is aimed for the use cases, where some basic
information is collected from each file (e.g. statistics, or
feature vectors), and summarized in the single output file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>str</code></dt>
<dd>(Optional) configuration filename. If given, the
self.readConfig() method will be called.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Summary(Yaprak):
    &#34;&#34;&#34;Summary class for the yaprak package.&#34;&#34;&#34;
    def __init__(self, config = None):
        &#39;&#39;&#39;
            The summary class is similar to the base yaprak class. The primary
            difference is that the Summary class saves the output to a single
            output file, and individual files. This class is not intended to be
            used as a way to aggregate many output files into a single file. 
            Instead, this class is aimed for the use cases, where some basic 
            information is collected from each file (e.g. statistics, or
            feature vectors), and summarized in the single output file.

            Args:
                config (str): (Optional) configuration filename. If given, the 
                    self.readConfig() method will be called.
        &#39;&#39;&#39;
        Yaprak.__init__(self, config)
        self.outSummaryFile = None
        self.readAdditionalConfig(config)

    # Config
    def readAdditionalConfig(self, config): 
        &#39;&#39;&#39;
            Reads the global information from the configuration file, that is
            the name of the output summary file, if it exists.

            Args:
                config (str): Name of the configuration file to load 

            Returns:
                None
        &#39;&#39;&#39;
        if &#34;outSummaryFile&#34; in self.config:
            self.outSummaryFile = fullPathFile(self.config, &#39;outSummary&#39;)

    def run(self):
        &#39;&#39;&#39;
            This method is similar to the base class&#39; run method in that it
            loads all the input files, run the processes, and report the
            pertinent information. The main difference is that in this class 
            only one output file is generated, which consolidates outputs from 
            all the input files.

            Args:
                None: 

            Returns:
                None
        &#39;&#39;&#39;
        IDs = self.getIDs()
        inFileList = self.getInFileList()
        processes = self.getProcesses()
        for instances in zip(IDs, inFileList):
            self.current_iteration = {&#39;ID&#39;: instances[0], 
                                      &#39;inFile&#39;: instances[1]}
            self.load(instances[1])
            for process_spec in processes:
                if process_spec[&#39;apply&#39;]:
                    function = getattr(self, process_spec[&#39;process&#39;])
                    function(process_spec)
        self.summarize()
        self.report()

    @abstractmethod
    def summarize(self):
        &#39;&#39;&#39;
            An abstract method as a placeholder for the summarize function. The
            child class must implement this function.

            Args:
                None: 

            Returns:
                None
        &#39;&#39;&#39;
        raise NotImplementedError(&#34;The summarize method in Yaprak is abstract\
        and should be implemented in the child class&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="yaprak.yaprak.Yaprak" href="#yaprak.yaprak.Yaprak">Yaprak</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="yaprak.yaprak.Summary.readAdditionalConfig"><code class="name flex">
<span>def <span class="ident">readAdditionalConfig</span></span>(<span>self, config)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the global information from the configuration file, that is
the name of the output summary file, if it exists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the configuration file to load </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readAdditionalConfig(self, config): 
    &#39;&#39;&#39;
        Reads the global information from the configuration file, that is
        the name of the output summary file, if it exists.

        Args:
            config (str): Name of the configuration file to load 

        Returns:
            None
    &#39;&#39;&#39;
    if &#34;outSummaryFile&#34; in self.config:
        self.outSummaryFile = fullPathFile(self.config, &#39;outSummary&#39;)</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Summary.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is similar to the base class' run method in that it
loads all the input files, run the processes, and report the
pertinent information. The main difference is that in this class
only one output file is generated, which consolidates outputs from
all the input files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#39;&#39;&#39;
        This method is similar to the base class&#39; run method in that it
        loads all the input files, run the processes, and report the
        pertinent information. The main difference is that in this class 
        only one output file is generated, which consolidates outputs from 
        all the input files.

        Args:
            None: 

        Returns:
            None
    &#39;&#39;&#39;
    IDs = self.getIDs()
    inFileList = self.getInFileList()
    processes = self.getProcesses()
    for instances in zip(IDs, inFileList):
        self.current_iteration = {&#39;ID&#39;: instances[0], 
                                  &#39;inFile&#39;: instances[1]}
        self.load(instances[1])
        for process_spec in processes:
            if process_spec[&#39;apply&#39;]:
                function = getattr(self, process_spec[&#39;process&#39;])
                function(process_spec)
    self.summarize()
    self.report()</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Summary.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>An abstract method as a placeholder for the summarize function. The
child class must implement this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def summarize(self):
    &#39;&#39;&#39;
        An abstract method as a placeholder for the summarize function. The
        child class must implement this function.

        Args:
            None: 

        Returns:
            None
    &#39;&#39;&#39;
    raise NotImplementedError(&#34;The summarize method in Yaprak is abstract\
    and should be implemented in the child class&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="yaprak.yaprak.Yaprak" href="#yaprak.yaprak.Yaprak">Yaprak</a></b></code>:
<ul class="hlist">
<li><code><a title="yaprak.yaprak.Yaprak.load" href="#yaprak.yaprak.Yaprak.load">load</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.readConfig" href="#yaprak.yaprak.Yaprak.readConfig">readConfig</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.report" href="#yaprak.yaprak.Yaprak.report">report</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.save" href="#yaprak.yaprak.Yaprak.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="yaprak.yaprak.Yaprak"><code class="flex name class">
<span>class <span class="ident">Yaprak</span></span>
<span>(</span><span>config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for the yaprak package.</p>
<p>The yaprak class initializes with empty local variables. If a
configuration file name is given as an argument, this will trigger
the loading of a configuration file via the self.readConfig()
method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>str</code></dt>
<dd>(Optional) configuration filename. If given, the
self.readConfig() method will be called.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Yaprak(ABC):
    &#34;&#34;&#34;Base class for the yaprak package.&#34;&#34;&#34;
    def __init__(self, config = None):
        &#39;&#39;&#39;
            The yaprak class initializes with empty local variables. If a
            configuration file name is given as an argument, this will trigger
            the loading of a configuration file via the self.readConfig()
            method.

            Args:
                config (str): (Optional) configuration filename. If given, the 
                    self.readConfig() method will be called.
        &#39;&#39;&#39;
        self.config = {}
        self.current_iteration = {}
        self.globals = {}
        self.__IDs = []
        self.__processes = []
        self.__inFileList = []
        self.__outFileList = []
        self.__outPath = None
        if config:
            self.readConfig(config)
            self.globals = {&#39;outPath&#39;: self.__outPath}

    def run(self):
        &#39;&#39;&#39;
            The main method to call to go through all the input files, execute
            all the processes, populate the output files, and report anything 
            pertinent to each input file.

            This method runs for all instances (defined as an ID, an input file,
            and an output file). If any of the parameters don&#39;t exist, the
            operation stops.

            For each process a process_spec is given (probably read from the 
            configuration file. This process_spec will be passed to the method,
            and executed. The process_spec can include basic parameters such as 
            numbers, booleans, and strings, which the json file supports.

            The process will be skipped if the process_spec does not have the
            apply property. This way, processes can be disabled quickly by just
            removing the apply property.

            Args:
                None

            Returns:
                None
        &#39;&#39;&#39;
        for instances in zip(self.__IDs, self.__inFileList, self.__outFileList):
            self.current_iteration = {&#39;ID&#39;: instances[0], &#39;inFile&#39;: instances[1],
                                      &#39;outFile&#39;: instances[2]}
            self.load(instances[1])
            for process_spec in self.__processes:
                if process_spec[&#39;apply&#39;]:
                    function = getattr(self, process_spec[&#39;process&#39;])
                    function(process_spec)
            self.save(instances[2])
            self.report()

    @abstractmethod
    def load(self, file):
        &#39;&#39;&#39;
            An abstract method as a placeholder for the file load function. The
            child class must implement this function.

            Args:
                file (str): Name of the file to load

            Returns:
                None
        &#39;&#39;&#39;
        raise NotImplementedError(&#34;The load method in Yaprak is abstract\
        and should be implemented in the child class&#34;)

    @abstractmethod
    def save(self, file):
        &#39;&#39;&#39;
            An abstract method as a placeholder for the file save function. The
            child class must implement this function.

            Args:
                file (str): Name of the file to save

            Returns:
                None
        &#39;&#39;&#39;
        raise NotImplementedError(&#34;The save method in Yaprak is abstract\
        and should be implemented in the child class&#34;)

    @abstractmethod
    def report(self):
        &#39;&#39;&#39;
            An abstract method as a placeholder for the report function. The
            child class must implement this function.

            Args:
                None: 

            Returns:
                None
        &#39;&#39;&#39;
        raise NotImplementedError(&#34;The report method in Yaprak is abstract\
        and should be implemented in the child class&#34;)

    # Config
    def readConfig(self, file): 
        &#39;&#39;&#39;
            Reads the json configuration file. The IDs, input file list, and
            output file lists will be populated with full paths to the files, if
            they exist in the configuration file. If output path is defined and
            non-existing, the output path will be created. Processes will also
            be populated if they are listed in the configuration file. 

            This function will be called automatically in __init__() if the
            configuration file is given to __init__().

            Args:
                file (str): Name of the configuration file to load 

            Returns:
                None
        &#39;&#39;&#39;
        self.config = load_json_file(file)
        if &#34;IDs&#34; in self.config:
            self.__IDs = self.config[&#39;IDs&#39;] 
        if &#34;inFileList&#34; in self.config:
            self.__inFileList = fullPathFileList(self.config, &#39;in&#39;)
        if &#34;outFileList&#34; in self.config:
            self.__outFileList = fullPathFileList(self.config, &#39;out&#39;)
        if &#34;outPath&#34; in self.config:
            self.__outPath = self.config[&#39;outPath&#39;] 
            mkdir_p(self.__outPath)
        if &#34;processes&#34; in self.config:
            self.__processes = [x for x in self.config[&#39;processes&#39;]]

    def setConfig(self, config):
        self.config = config

    def getConfig(self):
        return self.config

    def generateConfig(self):
        pass 

    # IDs
    def setIDs(self, IDs):
        self.__IDs = IDs

    def getIDs(self):
        return self.__IDs 

    def generateIDs(self):
        pass 

    # File Lists
    def setInFileList(self, fileList):
        self.__inFileList = fileList

    def getInFileList(self):
        return self.__inFileList 

    def setOutFileList(self, fileList):
        self.__outFileList = fileList

    def getOutFileList(self):
        return self.__outFileList 

    # Processes
    def setProcesses(self, processes):
        self.__processes = processes

    def getProcesses(self):
        return self.__processes 

    def generateProcesses(self):
        pass </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="yaprak.yaprak.Summary" href="#yaprak.yaprak.Summary">Summary</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="yaprak.yaprak.Yaprak.generateConfig"><code class="name flex">
<span>def <span class="ident">generateConfig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateConfig(self):
    pass </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.generateIDs"><code class="name flex">
<span>def <span class="ident">generateIDs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateIDs(self):
    pass </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.generateProcesses"><code class="name flex">
<span>def <span class="ident">generateProcesses</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateProcesses(self):
    pass </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.getConfig"><code class="name flex">
<span>def <span class="ident">getConfig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getConfig(self):
    return self.config</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.getIDs"><code class="name flex">
<span>def <span class="ident">getIDs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIDs(self):
    return self.__IDs </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.getInFileList"><code class="name flex">
<span>def <span class="ident">getInFileList</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInFileList(self):
    return self.__inFileList </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.getOutFileList"><code class="name flex">
<span>def <span class="ident">getOutFileList</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOutFileList(self):
    return self.__outFileList </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.getProcesses"><code class="name flex">
<span>def <span class="ident">getProcesses</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProcesses(self):
    return self.__processes </code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>An abstract method as a placeholder for the file load function. The
child class must implement this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the file to load</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def load(self, file):
    &#39;&#39;&#39;
        An abstract method as a placeholder for the file load function. The
        child class must implement this function.

        Args:
            file (str): Name of the file to load

        Returns:
            None
    &#39;&#39;&#39;
    raise NotImplementedError(&#34;The load method in Yaprak is abstract\
    and should be implemented in the child class&#34;)</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.readConfig"><code class="name flex">
<span>def <span class="ident">readConfig</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the json configuration file. The IDs, input file list, and
output file lists will be populated with full paths to the files, if
they exist in the configuration file. If output path is defined and
non-existing, the output path will be created. Processes will also
be populated if they are listed in the configuration file. </p>
<p>This function will be called automatically in <strong>init</strong>() if the
configuration file is given to <strong>init</strong>().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the configuration file to load </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readConfig(self, file): 
    &#39;&#39;&#39;
        Reads the json configuration file. The IDs, input file list, and
        output file lists will be populated with full paths to the files, if
        they exist in the configuration file. If output path is defined and
        non-existing, the output path will be created. Processes will also
        be populated if they are listed in the configuration file. 

        This function will be called automatically in __init__() if the
        configuration file is given to __init__().

        Args:
            file (str): Name of the configuration file to load 

        Returns:
            None
    &#39;&#39;&#39;
    self.config = load_json_file(file)
    if &#34;IDs&#34; in self.config:
        self.__IDs = self.config[&#39;IDs&#39;] 
    if &#34;inFileList&#34; in self.config:
        self.__inFileList = fullPathFileList(self.config, &#39;in&#39;)
    if &#34;outFileList&#34; in self.config:
        self.__outFileList = fullPathFileList(self.config, &#39;out&#39;)
    if &#34;outPath&#34; in self.config:
        self.__outPath = self.config[&#39;outPath&#39;] 
        mkdir_p(self.__outPath)
    if &#34;processes&#34; in self.config:
        self.__processes = [x for x in self.config[&#39;processes&#39;]]</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>An abstract method as a placeholder for the report function. The
child class must implement this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def report(self):
    &#39;&#39;&#39;
        An abstract method as a placeholder for the report function. The
        child class must implement this function.

        Args:
            None: 

        Returns:
            None
    &#39;&#39;&#39;
    raise NotImplementedError(&#34;The report method in Yaprak is abstract\
    and should be implemented in the child class&#34;)</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The main method to call to go through all the input files, execute
all the processes, populate the output files, and report anything
pertinent to each input file.</p>
<p>This method runs for all instances (defined as an ID, an input file,
and an output file). If any of the parameters don't exist, the
operation stops.</p>
<p>For each process a process_spec is given (probably read from the
configuration file. This process_spec will be passed to the method,
and executed. The process_spec can include basic parameters such as
numbers, booleans, and strings, which the json file supports.</p>
<p>The process will be skipped if the process_spec does not have the
apply property. This way, processes can be disabled quickly by just
removing the apply property.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#39;&#39;&#39;
        The main method to call to go through all the input files, execute
        all the processes, populate the output files, and report anything 
        pertinent to each input file.

        This method runs for all instances (defined as an ID, an input file,
        and an output file). If any of the parameters don&#39;t exist, the
        operation stops.

        For each process a process_spec is given (probably read from the 
        configuration file. This process_spec will be passed to the method,
        and executed. The process_spec can include basic parameters such as 
        numbers, booleans, and strings, which the json file supports.

        The process will be skipped if the process_spec does not have the
        apply property. This way, processes can be disabled quickly by just
        removing the apply property.

        Args:
            None

        Returns:
            None
    &#39;&#39;&#39;
    for instances in zip(self.__IDs, self.__inFileList, self.__outFileList):
        self.current_iteration = {&#39;ID&#39;: instances[0], &#39;inFile&#39;: instances[1],
                                  &#39;outFile&#39;: instances[2]}
        self.load(instances[1])
        for process_spec in self.__processes:
            if process_spec[&#39;apply&#39;]:
                function = getattr(self, process_spec[&#39;process&#39;])
                function(process_spec)
        self.save(instances[2])
        self.report()</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>An abstract method as a placeholder for the file save function. The
child class must implement this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the file to save</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def save(self, file):
    &#39;&#39;&#39;
        An abstract method as a placeholder for the file save function. The
        child class must implement this function.

        Args:
            file (str): Name of the file to save

        Returns:
            None
    &#39;&#39;&#39;
    raise NotImplementedError(&#34;The save method in Yaprak is abstract\
    and should be implemented in the child class&#34;)</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.setConfig"><code class="name flex">
<span>def <span class="ident">setConfig</span></span>(<span>self, config)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setConfig(self, config):
    self.config = config</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.setIDs"><code class="name flex">
<span>def <span class="ident">setIDs</span></span>(<span>self, IDs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setIDs(self, IDs):
    self.__IDs = IDs</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.setInFileList"><code class="name flex">
<span>def <span class="ident">setInFileList</span></span>(<span>self, fileList)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInFileList(self, fileList):
    self.__inFileList = fileList</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.setOutFileList"><code class="name flex">
<span>def <span class="ident">setOutFileList</span></span>(<span>self, fileList)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setOutFileList(self, fileList):
    self.__outFileList = fileList</code></pre>
</details>
</dd>
<dt id="yaprak.yaprak.Yaprak.setProcesses"><code class="name flex">
<span>def <span class="ident">setProcesses</span></span>(<span>self, processes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setProcesses(self, processes):
    self.__processes = processes</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="yaprak" href="index.html">yaprak</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="yaprak.yaprak.fullPathFile" href="#yaprak.yaprak.fullPathFile">fullPathFile</a></code></li>
<li><code><a title="yaprak.yaprak.fullPathFileList" href="#yaprak.yaprak.fullPathFileList">fullPathFileList</a></code></li>
<li><code><a title="yaprak.yaprak.load_json_file" href="#yaprak.yaprak.load_json_file">load_json_file</a></code></li>
<li><code><a title="yaprak.yaprak.mkdir_p" href="#yaprak.yaprak.mkdir_p">mkdir_p</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="yaprak.yaprak.Summary" href="#yaprak.yaprak.Summary">Summary</a></code></h4>
<ul class="">
<li><code><a title="yaprak.yaprak.Summary.readAdditionalConfig" href="#yaprak.yaprak.Summary.readAdditionalConfig">readAdditionalConfig</a></code></li>
<li><code><a title="yaprak.yaprak.Summary.run" href="#yaprak.yaprak.Summary.run">run</a></code></li>
<li><code><a title="yaprak.yaprak.Summary.summarize" href="#yaprak.yaprak.Summary.summarize">summarize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yaprak.yaprak.Yaprak" href="#yaprak.yaprak.Yaprak">Yaprak</a></code></h4>
<ul class="two-column">
<li><code><a title="yaprak.yaprak.Yaprak.generateConfig" href="#yaprak.yaprak.Yaprak.generateConfig">generateConfig</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.generateIDs" href="#yaprak.yaprak.Yaprak.generateIDs">generateIDs</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.generateProcesses" href="#yaprak.yaprak.Yaprak.generateProcesses">generateProcesses</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.getConfig" href="#yaprak.yaprak.Yaprak.getConfig">getConfig</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.getIDs" href="#yaprak.yaprak.Yaprak.getIDs">getIDs</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.getInFileList" href="#yaprak.yaprak.Yaprak.getInFileList">getInFileList</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.getOutFileList" href="#yaprak.yaprak.Yaprak.getOutFileList">getOutFileList</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.getProcesses" href="#yaprak.yaprak.Yaprak.getProcesses">getProcesses</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.load" href="#yaprak.yaprak.Yaprak.load">load</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.readConfig" href="#yaprak.yaprak.Yaprak.readConfig">readConfig</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.report" href="#yaprak.yaprak.Yaprak.report">report</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.run" href="#yaprak.yaprak.Yaprak.run">run</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.save" href="#yaprak.yaprak.Yaprak.save">save</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.setConfig" href="#yaprak.yaprak.Yaprak.setConfig">setConfig</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.setIDs" href="#yaprak.yaprak.Yaprak.setIDs">setIDs</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.setInFileList" href="#yaprak.yaprak.Yaprak.setInFileList">setInFileList</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.setOutFileList" href="#yaprak.yaprak.Yaprak.setOutFileList">setOutFileList</a></code></li>
<li><code><a title="yaprak.yaprak.Yaprak.setProcesses" href="#yaprak.yaprak.Yaprak.setProcesses">setProcesses</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>