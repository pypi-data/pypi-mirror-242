# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'WorkspaceAdminPortal',
    'WorkspaceAdminPortalPalette',
    'WorkspaceAdminPortalPaletteError',
    'WorkspaceAdminPortalPaletteInfo',
    'WorkspaceAdminPortalPalettePrimary',
    'WorkspaceAdminPortalPaletteSecondary',
    'WorkspaceAdminPortalPaletteSuccess',
    'WorkspaceAdminPortalPaletteWarning',
    'WorkspaceAuthPolicy',
    'WorkspaceBulkTenantsInvitesEmail',
    'WorkspaceCaptchaPolicy',
    'WorkspaceFacebookSocialLogin',
    'WorkspaceGithubSocialLogin',
    'WorkspaceGoogleSocialLogin',
    'WorkspaceHostedLogin',
    'WorkspaceLockoutPolicy',
    'WorkspaceMagicCodeEmail',
    'WorkspaceMagicLinkEmail',
    'WorkspaceMfaAuthenticationApp',
    'WorkspaceMfaPolicy',
    'WorkspaceMicrosoftSocialLogin',
    'WorkspaceNewDeviceConnectedEmail',
    'WorkspaceOidc',
    'WorkspacePasswordPolicy',
    'WorkspacePwnedPasswordEmail',
    'WorkspaceResetPasswordEmail',
    'WorkspaceResetPhoneNumberEmail',
    'WorkspaceSaml',
    'WorkspaceUserActivationEmail',
    'WorkspaceUserInvitationEmail',
    'WorkspaceUserUsedInvitationEmail',
]

@pulumi.output_type
class WorkspaceAdminPortal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableAccountSettings":
            suggest = "enable_account_settings"
        elif key == "enableApiTokens":
            suggest = "enable_api_tokens"
        elif key == "enableAuditLogs":
            suggest = "enable_audit_logs"
        elif key == "enablePersonalApiTokens":
            suggest = "enable_personal_api_tokens"
        elif key == "enablePrivacy":
            suggest = "enable_privacy"
        elif key == "enableProfile":
            suggest = "enable_profile"
        elif key == "enableRoles":
            suggest = "enable_roles"
        elif key == "enableSecurity":
            suggest = "enable_security"
        elif key == "enableSso":
            suggest = "enable_sso"
        elif key == "enableSubscriptions":
            suggest = "enable_subscriptions"
        elif key == "enableUsage":
            suggest = "enable_usage"
        elif key == "enableUsers":
            suggest = "enable_users"
        elif key == "enableWebhooks":
            suggest = "enable_webhooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceAdminPortal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceAdminPortal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceAdminPortal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_account_settings: bool,
                 enable_api_tokens: bool,
                 enable_audit_logs: bool,
                 enable_personal_api_tokens: bool,
                 enable_privacy: bool,
                 enable_profile: bool,
                 enable_roles: bool,
                 enable_security: bool,
                 enable_sso: bool,
                 enable_subscriptions: bool,
                 enable_usage: bool,
                 enable_users: bool,
                 enable_webhooks: bool,
                 palette: Optional['outputs.WorkspaceAdminPortalPalette'] = None):
        WorkspaceAdminPortal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_account_settings=enable_account_settings,
            enable_api_tokens=enable_api_tokens,
            enable_audit_logs=enable_audit_logs,
            enable_personal_api_tokens=enable_personal_api_tokens,
            enable_privacy=enable_privacy,
            enable_profile=enable_profile,
            enable_roles=enable_roles,
            enable_security=enable_security,
            enable_sso=enable_sso,
            enable_subscriptions=enable_subscriptions,
            enable_usage=enable_usage,
            enable_users=enable_users,
            enable_webhooks=enable_webhooks,
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_account_settings: Optional[bool] = None,
             enable_api_tokens: Optional[bool] = None,
             enable_audit_logs: Optional[bool] = None,
             enable_personal_api_tokens: Optional[bool] = None,
             enable_privacy: Optional[bool] = None,
             enable_profile: Optional[bool] = None,
             enable_roles: Optional[bool] = None,
             enable_security: Optional[bool] = None,
             enable_sso: Optional[bool] = None,
             enable_subscriptions: Optional[bool] = None,
             enable_usage: Optional[bool] = None,
             enable_users: Optional[bool] = None,
             enable_webhooks: Optional[bool] = None,
             palette: Optional['outputs.WorkspaceAdminPortalPalette'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_account_settings is None and 'enableAccountSettings' in kwargs:
            enable_account_settings = kwargs['enableAccountSettings']
        if enable_account_settings is None:
            raise TypeError("Missing 'enable_account_settings' argument")
        if enable_api_tokens is None and 'enableApiTokens' in kwargs:
            enable_api_tokens = kwargs['enableApiTokens']
        if enable_api_tokens is None:
            raise TypeError("Missing 'enable_api_tokens' argument")
        if enable_audit_logs is None and 'enableAuditLogs' in kwargs:
            enable_audit_logs = kwargs['enableAuditLogs']
        if enable_audit_logs is None:
            raise TypeError("Missing 'enable_audit_logs' argument")
        if enable_personal_api_tokens is None and 'enablePersonalApiTokens' in kwargs:
            enable_personal_api_tokens = kwargs['enablePersonalApiTokens']
        if enable_personal_api_tokens is None:
            raise TypeError("Missing 'enable_personal_api_tokens' argument")
        if enable_privacy is None and 'enablePrivacy' in kwargs:
            enable_privacy = kwargs['enablePrivacy']
        if enable_privacy is None:
            raise TypeError("Missing 'enable_privacy' argument")
        if enable_profile is None and 'enableProfile' in kwargs:
            enable_profile = kwargs['enableProfile']
        if enable_profile is None:
            raise TypeError("Missing 'enable_profile' argument")
        if enable_roles is None and 'enableRoles' in kwargs:
            enable_roles = kwargs['enableRoles']
        if enable_roles is None:
            raise TypeError("Missing 'enable_roles' argument")
        if enable_security is None and 'enableSecurity' in kwargs:
            enable_security = kwargs['enableSecurity']
        if enable_security is None:
            raise TypeError("Missing 'enable_security' argument")
        if enable_sso is None and 'enableSso' in kwargs:
            enable_sso = kwargs['enableSso']
        if enable_sso is None:
            raise TypeError("Missing 'enable_sso' argument")
        if enable_subscriptions is None and 'enableSubscriptions' in kwargs:
            enable_subscriptions = kwargs['enableSubscriptions']
        if enable_subscriptions is None:
            raise TypeError("Missing 'enable_subscriptions' argument")
        if enable_usage is None and 'enableUsage' in kwargs:
            enable_usage = kwargs['enableUsage']
        if enable_usage is None:
            raise TypeError("Missing 'enable_usage' argument")
        if enable_users is None and 'enableUsers' in kwargs:
            enable_users = kwargs['enableUsers']
        if enable_users is None:
            raise TypeError("Missing 'enable_users' argument")
        if enable_webhooks is None and 'enableWebhooks' in kwargs:
            enable_webhooks = kwargs['enableWebhooks']
        if enable_webhooks is None:
            raise TypeError("Missing 'enable_webhooks' argument")

        _setter("enable_account_settings", enable_account_settings)
        _setter("enable_api_tokens", enable_api_tokens)
        _setter("enable_audit_logs", enable_audit_logs)
        _setter("enable_personal_api_tokens", enable_personal_api_tokens)
        _setter("enable_privacy", enable_privacy)
        _setter("enable_profile", enable_profile)
        _setter("enable_roles", enable_roles)
        _setter("enable_security", enable_security)
        _setter("enable_sso", enable_sso)
        _setter("enable_subscriptions", enable_subscriptions)
        _setter("enable_usage", enable_usage)
        _setter("enable_users", enable_users)
        _setter("enable_webhooks", enable_webhooks)
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter(name="enableAccountSettings")
    def enable_account_settings(self) -> bool:
        return pulumi.get(self, "enable_account_settings")

    @property
    @pulumi.getter(name="enableApiTokens")
    def enable_api_tokens(self) -> bool:
        return pulumi.get(self, "enable_api_tokens")

    @property
    @pulumi.getter(name="enableAuditLogs")
    def enable_audit_logs(self) -> bool:
        return pulumi.get(self, "enable_audit_logs")

    @property
    @pulumi.getter(name="enablePersonalApiTokens")
    def enable_personal_api_tokens(self) -> bool:
        return pulumi.get(self, "enable_personal_api_tokens")

    @property
    @pulumi.getter(name="enablePrivacy")
    def enable_privacy(self) -> bool:
        return pulumi.get(self, "enable_privacy")

    @property
    @pulumi.getter(name="enableProfile")
    def enable_profile(self) -> bool:
        return pulumi.get(self, "enable_profile")

    @property
    @pulumi.getter(name="enableRoles")
    def enable_roles(self) -> bool:
        return pulumi.get(self, "enable_roles")

    @property
    @pulumi.getter(name="enableSecurity")
    def enable_security(self) -> bool:
        return pulumi.get(self, "enable_security")

    @property
    @pulumi.getter(name="enableSso")
    def enable_sso(self) -> bool:
        return pulumi.get(self, "enable_sso")

    @property
    @pulumi.getter(name="enableSubscriptions")
    def enable_subscriptions(self) -> bool:
        return pulumi.get(self, "enable_subscriptions")

    @property
    @pulumi.getter(name="enableUsage")
    def enable_usage(self) -> bool:
        return pulumi.get(self, "enable_usage")

    @property
    @pulumi.getter(name="enableUsers")
    def enable_users(self) -> bool:
        return pulumi.get(self, "enable_users")

    @property
    @pulumi.getter(name="enableWebhooks")
    def enable_webhooks(self) -> bool:
        return pulumi.get(self, "enable_webhooks")

    @property
    @pulumi.getter
    def palette(self) -> Optional['outputs.WorkspaceAdminPortalPalette']:
        return pulumi.get(self, "palette")


@pulumi.output_type
class WorkspaceAdminPortalPalette(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteError']] = None,
                 infos: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteInfo']] = None,
                 primaries: Optional[Sequence['outputs.WorkspaceAdminPortalPalettePrimary']] = None,
                 secondaries: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteSecondary']] = None,
                 successes: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteSuccess']] = None,
                 warnings: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteWarning']] = None):
        WorkspaceAdminPortalPalette._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            errors=errors,
            infos=infos,
            primaries=primaries,
            secondaries=secondaries,
            successes=successes,
            warnings=warnings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             errors: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteError']] = None,
             infos: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteInfo']] = None,
             primaries: Optional[Sequence['outputs.WorkspaceAdminPortalPalettePrimary']] = None,
             secondaries: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteSecondary']] = None,
             successes: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteSuccess']] = None,
             warnings: Optional[Sequence['outputs.WorkspaceAdminPortalPaletteWarning']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if errors is not None:
            _setter("errors", errors)
        if infos is not None:
            _setter("infos", infos)
        if primaries is not None:
            _setter("primaries", primaries)
        if secondaries is not None:
            _setter("secondaries", secondaries)
        if successes is not None:
            _setter("successes", successes)
        if warnings is not None:
            _setter("warnings", warnings)

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.WorkspaceAdminPortalPaletteError']]:
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def infos(self) -> Optional[Sequence['outputs.WorkspaceAdminPortalPaletteInfo']]:
        return pulumi.get(self, "infos")

    @property
    @pulumi.getter
    def primaries(self) -> Optional[Sequence['outputs.WorkspaceAdminPortalPalettePrimary']]:
        return pulumi.get(self, "primaries")

    @property
    @pulumi.getter
    def secondaries(self) -> Optional[Sequence['outputs.WorkspaceAdminPortalPaletteSecondary']]:
        return pulumi.get(self, "secondaries")

    @property
    @pulumi.getter
    def successes(self) -> Optional[Sequence['outputs.WorkspaceAdminPortalPaletteSuccess']]:
        return pulumi.get(self, "successes")

    @property
    @pulumi.getter
    def warnings(self) -> Optional[Sequence['outputs.WorkspaceAdminPortalPaletteWarning']]:
        return pulumi.get(self, "warnings")


@pulumi.output_type
class WorkspaceAdminPortalPaletteError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contrastText":
            suggest = "contrast_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceAdminPortalPaletteError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceAdminPortalPaletteError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceAdminPortalPaletteError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contrast_text: str,
                 dark: str,
                 light: str,
                 main: str):
        WorkspaceAdminPortalPaletteError._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contrast_text=contrast_text,
            dark=dark,
            light=light,
            main=main,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contrast_text: Optional[str] = None,
             dark: Optional[str] = None,
             light: Optional[str] = None,
             main: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contrast_text is None and 'contrastText' in kwargs:
            contrast_text = kwargs['contrastText']
        if contrast_text is None:
            raise TypeError("Missing 'contrast_text' argument")
        if dark is None:
            raise TypeError("Missing 'dark' argument")
        if light is None:
            raise TypeError("Missing 'light' argument")
        if main is None:
            raise TypeError("Missing 'main' argument")

        _setter("contrast_text", contrast_text)
        _setter("dark", dark)
        _setter("light", light)
        _setter("main", main)

    @property
    @pulumi.getter(name="contrastText")
    def contrast_text(self) -> str:
        return pulumi.get(self, "contrast_text")

    @property
    @pulumi.getter
    def dark(self) -> str:
        return pulumi.get(self, "dark")

    @property
    @pulumi.getter
    def light(self) -> str:
        return pulumi.get(self, "light")

    @property
    @pulumi.getter
    def main(self) -> str:
        return pulumi.get(self, "main")


@pulumi.output_type
class WorkspaceAdminPortalPaletteInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contrastText":
            suggest = "contrast_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceAdminPortalPaletteInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceAdminPortalPaletteInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceAdminPortalPaletteInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contrast_text: str,
                 dark: str,
                 light: str,
                 main: str):
        WorkspaceAdminPortalPaletteInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contrast_text=contrast_text,
            dark=dark,
            light=light,
            main=main,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contrast_text: Optional[str] = None,
             dark: Optional[str] = None,
             light: Optional[str] = None,
             main: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contrast_text is None and 'contrastText' in kwargs:
            contrast_text = kwargs['contrastText']
        if contrast_text is None:
            raise TypeError("Missing 'contrast_text' argument")
        if dark is None:
            raise TypeError("Missing 'dark' argument")
        if light is None:
            raise TypeError("Missing 'light' argument")
        if main is None:
            raise TypeError("Missing 'main' argument")

        _setter("contrast_text", contrast_text)
        _setter("dark", dark)
        _setter("light", light)
        _setter("main", main)

    @property
    @pulumi.getter(name="contrastText")
    def contrast_text(self) -> str:
        return pulumi.get(self, "contrast_text")

    @property
    @pulumi.getter
    def dark(self) -> str:
        return pulumi.get(self, "dark")

    @property
    @pulumi.getter
    def light(self) -> str:
        return pulumi.get(self, "light")

    @property
    @pulumi.getter
    def main(self) -> str:
        return pulumi.get(self, "main")


@pulumi.output_type
class WorkspaceAdminPortalPalettePrimary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contrastText":
            suggest = "contrast_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceAdminPortalPalettePrimary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceAdminPortalPalettePrimary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceAdminPortalPalettePrimary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: str,
                 contrast_text: str,
                 dark: str,
                 hover: str,
                 light: str,
                 main: str):
        WorkspaceAdminPortalPalettePrimary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active=active,
            contrast_text=contrast_text,
            dark=dark,
            hover=hover,
            light=light,
            main=main,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active: Optional[str] = None,
             contrast_text: Optional[str] = None,
             dark: Optional[str] = None,
             hover: Optional[str] = None,
             light: Optional[str] = None,
             main: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if active is None:
            raise TypeError("Missing 'active' argument")
        if contrast_text is None and 'contrastText' in kwargs:
            contrast_text = kwargs['contrastText']
        if contrast_text is None:
            raise TypeError("Missing 'contrast_text' argument")
        if dark is None:
            raise TypeError("Missing 'dark' argument")
        if hover is None:
            raise TypeError("Missing 'hover' argument")
        if light is None:
            raise TypeError("Missing 'light' argument")
        if main is None:
            raise TypeError("Missing 'main' argument")

        _setter("active", active)
        _setter("contrast_text", contrast_text)
        _setter("dark", dark)
        _setter("hover", hover)
        _setter("light", light)
        _setter("main", main)

    @property
    @pulumi.getter
    def active(self) -> str:
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="contrastText")
    def contrast_text(self) -> str:
        return pulumi.get(self, "contrast_text")

    @property
    @pulumi.getter
    def dark(self) -> str:
        return pulumi.get(self, "dark")

    @property
    @pulumi.getter
    def hover(self) -> str:
        return pulumi.get(self, "hover")

    @property
    @pulumi.getter
    def light(self) -> str:
        return pulumi.get(self, "light")

    @property
    @pulumi.getter
    def main(self) -> str:
        return pulumi.get(self, "main")


@pulumi.output_type
class WorkspaceAdminPortalPaletteSecondary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contrastText":
            suggest = "contrast_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceAdminPortalPaletteSecondary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceAdminPortalPaletteSecondary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceAdminPortalPaletteSecondary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: str,
                 contrast_text: str,
                 dark: str,
                 hover: str,
                 light: str,
                 main: str):
        WorkspaceAdminPortalPaletteSecondary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active=active,
            contrast_text=contrast_text,
            dark=dark,
            hover=hover,
            light=light,
            main=main,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active: Optional[str] = None,
             contrast_text: Optional[str] = None,
             dark: Optional[str] = None,
             hover: Optional[str] = None,
             light: Optional[str] = None,
             main: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if active is None:
            raise TypeError("Missing 'active' argument")
        if contrast_text is None and 'contrastText' in kwargs:
            contrast_text = kwargs['contrastText']
        if contrast_text is None:
            raise TypeError("Missing 'contrast_text' argument")
        if dark is None:
            raise TypeError("Missing 'dark' argument")
        if hover is None:
            raise TypeError("Missing 'hover' argument")
        if light is None:
            raise TypeError("Missing 'light' argument")
        if main is None:
            raise TypeError("Missing 'main' argument")

        _setter("active", active)
        _setter("contrast_text", contrast_text)
        _setter("dark", dark)
        _setter("hover", hover)
        _setter("light", light)
        _setter("main", main)

    @property
    @pulumi.getter
    def active(self) -> str:
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="contrastText")
    def contrast_text(self) -> str:
        return pulumi.get(self, "contrast_text")

    @property
    @pulumi.getter
    def dark(self) -> str:
        return pulumi.get(self, "dark")

    @property
    @pulumi.getter
    def hover(self) -> str:
        return pulumi.get(self, "hover")

    @property
    @pulumi.getter
    def light(self) -> str:
        return pulumi.get(self, "light")

    @property
    @pulumi.getter
    def main(self) -> str:
        return pulumi.get(self, "main")


@pulumi.output_type
class WorkspaceAdminPortalPaletteSuccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contrastText":
            suggest = "contrast_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceAdminPortalPaletteSuccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceAdminPortalPaletteSuccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceAdminPortalPaletteSuccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contrast_text: str,
                 dark: str,
                 light: str,
                 main: str):
        WorkspaceAdminPortalPaletteSuccess._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contrast_text=contrast_text,
            dark=dark,
            light=light,
            main=main,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contrast_text: Optional[str] = None,
             dark: Optional[str] = None,
             light: Optional[str] = None,
             main: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contrast_text is None and 'contrastText' in kwargs:
            contrast_text = kwargs['contrastText']
        if contrast_text is None:
            raise TypeError("Missing 'contrast_text' argument")
        if dark is None:
            raise TypeError("Missing 'dark' argument")
        if light is None:
            raise TypeError("Missing 'light' argument")
        if main is None:
            raise TypeError("Missing 'main' argument")

        _setter("contrast_text", contrast_text)
        _setter("dark", dark)
        _setter("light", light)
        _setter("main", main)

    @property
    @pulumi.getter(name="contrastText")
    def contrast_text(self) -> str:
        return pulumi.get(self, "contrast_text")

    @property
    @pulumi.getter
    def dark(self) -> str:
        return pulumi.get(self, "dark")

    @property
    @pulumi.getter
    def light(self) -> str:
        return pulumi.get(self, "light")

    @property
    @pulumi.getter
    def main(self) -> str:
        return pulumi.get(self, "main")


@pulumi.output_type
class WorkspaceAdminPortalPaletteWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contrastText":
            suggest = "contrast_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceAdminPortalPaletteWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceAdminPortalPaletteWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceAdminPortalPaletteWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contrast_text: str,
                 dark: str,
                 light: str,
                 main: str):
        WorkspaceAdminPortalPaletteWarning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contrast_text=contrast_text,
            dark=dark,
            light=light,
            main=main,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contrast_text: Optional[str] = None,
             dark: Optional[str] = None,
             light: Optional[str] = None,
             main: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contrast_text is None and 'contrastText' in kwargs:
            contrast_text = kwargs['contrastText']
        if contrast_text is None:
            raise TypeError("Missing 'contrast_text' argument")
        if dark is None:
            raise TypeError("Missing 'dark' argument")
        if light is None:
            raise TypeError("Missing 'light' argument")
        if main is None:
            raise TypeError("Missing 'main' argument")

        _setter("contrast_text", contrast_text)
        _setter("dark", dark)
        _setter("light", light)
        _setter("main", main)

    @property
    @pulumi.getter(name="contrastText")
    def contrast_text(self) -> str:
        return pulumi.get(self, "contrast_text")

    @property
    @pulumi.getter
    def dark(self) -> str:
        return pulumi.get(self, "dark")

    @property
    @pulumi.getter
    def light(self) -> str:
        return pulumi.get(self, "light")

    @property
    @pulumi.getter
    def main(self) -> str:
        return pulumi.get(self, "main")


@pulumi.output_type
class WorkspaceAuthPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignups":
            suggest = "allow_signups"
        elif key == "allowTenantInvitations":
            suggest = "allow_tenant_invitations"
        elif key == "allowUnverifiedUsers":
            suggest = "allow_unverified_users"
        elif key == "authStrategy":
            suggest = "auth_strategy"
        elif key == "enableApiTokens":
            suggest = "enable_api_tokens"
        elif key == "enableRoles":
            suggest = "enable_roles"
        elif key == "jwtAccessTokenExpiration":
            suggest = "jwt_access_token_expiration"
        elif key == "jwtRefreshTokenExpiration":
            suggest = "jwt_refresh_token_expiration"
        elif key == "sameSiteCookiePolicy":
            suggest = "same_site_cookie_policy"
        elif key == "jwtAlgorithm":
            suggest = "jwt_algorithm"
        elif key == "jwtPublicKey":
            suggest = "jwt_public_key"
        elif key == "machineToMachineAuthStrategy":
            suggest = "machine_to_machine_auth_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceAuthPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceAuthPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceAuthPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_signups: bool,
                 allow_tenant_invitations: bool,
                 allow_unverified_users: bool,
                 auth_strategy: str,
                 enable_api_tokens: bool,
                 enable_roles: bool,
                 jwt_access_token_expiration: int,
                 jwt_refresh_token_expiration: int,
                 same_site_cookie_policy: str,
                 jwt_algorithm: Optional[str] = None,
                 jwt_public_key: Optional[str] = None,
                 machine_to_machine_auth_strategy: Optional[str] = None):
        WorkspaceAuthPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_signups=allow_signups,
            allow_tenant_invitations=allow_tenant_invitations,
            allow_unverified_users=allow_unverified_users,
            auth_strategy=auth_strategy,
            enable_api_tokens=enable_api_tokens,
            enable_roles=enable_roles,
            jwt_access_token_expiration=jwt_access_token_expiration,
            jwt_refresh_token_expiration=jwt_refresh_token_expiration,
            same_site_cookie_policy=same_site_cookie_policy,
            jwt_algorithm=jwt_algorithm,
            jwt_public_key=jwt_public_key,
            machine_to_machine_auth_strategy=machine_to_machine_auth_strategy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_signups: Optional[bool] = None,
             allow_tenant_invitations: Optional[bool] = None,
             allow_unverified_users: Optional[bool] = None,
             auth_strategy: Optional[str] = None,
             enable_api_tokens: Optional[bool] = None,
             enable_roles: Optional[bool] = None,
             jwt_access_token_expiration: Optional[int] = None,
             jwt_refresh_token_expiration: Optional[int] = None,
             same_site_cookie_policy: Optional[str] = None,
             jwt_algorithm: Optional[str] = None,
             jwt_public_key: Optional[str] = None,
             machine_to_machine_auth_strategy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_signups is None and 'allowSignups' in kwargs:
            allow_signups = kwargs['allowSignups']
        if allow_signups is None:
            raise TypeError("Missing 'allow_signups' argument")
        if allow_tenant_invitations is None and 'allowTenantInvitations' in kwargs:
            allow_tenant_invitations = kwargs['allowTenantInvitations']
        if allow_tenant_invitations is None:
            raise TypeError("Missing 'allow_tenant_invitations' argument")
        if allow_unverified_users is None and 'allowUnverifiedUsers' in kwargs:
            allow_unverified_users = kwargs['allowUnverifiedUsers']
        if allow_unverified_users is None:
            raise TypeError("Missing 'allow_unverified_users' argument")
        if auth_strategy is None and 'authStrategy' in kwargs:
            auth_strategy = kwargs['authStrategy']
        if auth_strategy is None:
            raise TypeError("Missing 'auth_strategy' argument")
        if enable_api_tokens is None and 'enableApiTokens' in kwargs:
            enable_api_tokens = kwargs['enableApiTokens']
        if enable_api_tokens is None:
            raise TypeError("Missing 'enable_api_tokens' argument")
        if enable_roles is None and 'enableRoles' in kwargs:
            enable_roles = kwargs['enableRoles']
        if enable_roles is None:
            raise TypeError("Missing 'enable_roles' argument")
        if jwt_access_token_expiration is None and 'jwtAccessTokenExpiration' in kwargs:
            jwt_access_token_expiration = kwargs['jwtAccessTokenExpiration']
        if jwt_access_token_expiration is None:
            raise TypeError("Missing 'jwt_access_token_expiration' argument")
        if jwt_refresh_token_expiration is None and 'jwtRefreshTokenExpiration' in kwargs:
            jwt_refresh_token_expiration = kwargs['jwtRefreshTokenExpiration']
        if jwt_refresh_token_expiration is None:
            raise TypeError("Missing 'jwt_refresh_token_expiration' argument")
        if same_site_cookie_policy is None and 'sameSiteCookiePolicy' in kwargs:
            same_site_cookie_policy = kwargs['sameSiteCookiePolicy']
        if same_site_cookie_policy is None:
            raise TypeError("Missing 'same_site_cookie_policy' argument")
        if jwt_algorithm is None and 'jwtAlgorithm' in kwargs:
            jwt_algorithm = kwargs['jwtAlgorithm']
        if jwt_public_key is None and 'jwtPublicKey' in kwargs:
            jwt_public_key = kwargs['jwtPublicKey']
        if machine_to_machine_auth_strategy is None and 'machineToMachineAuthStrategy' in kwargs:
            machine_to_machine_auth_strategy = kwargs['machineToMachineAuthStrategy']

        _setter("allow_signups", allow_signups)
        _setter("allow_tenant_invitations", allow_tenant_invitations)
        _setter("allow_unverified_users", allow_unverified_users)
        _setter("auth_strategy", auth_strategy)
        _setter("enable_api_tokens", enable_api_tokens)
        _setter("enable_roles", enable_roles)
        _setter("jwt_access_token_expiration", jwt_access_token_expiration)
        _setter("jwt_refresh_token_expiration", jwt_refresh_token_expiration)
        _setter("same_site_cookie_policy", same_site_cookie_policy)
        if jwt_algorithm is not None:
            _setter("jwt_algorithm", jwt_algorithm)
        if jwt_public_key is not None:
            _setter("jwt_public_key", jwt_public_key)
        if machine_to_machine_auth_strategy is not None:
            _setter("machine_to_machine_auth_strategy", machine_to_machine_auth_strategy)

    @property
    @pulumi.getter(name="allowSignups")
    def allow_signups(self) -> bool:
        return pulumi.get(self, "allow_signups")

    @property
    @pulumi.getter(name="allowTenantInvitations")
    def allow_tenant_invitations(self) -> bool:
        return pulumi.get(self, "allow_tenant_invitations")

    @property
    @pulumi.getter(name="allowUnverifiedUsers")
    def allow_unverified_users(self) -> bool:
        return pulumi.get(self, "allow_unverified_users")

    @property
    @pulumi.getter(name="authStrategy")
    def auth_strategy(self) -> str:
        return pulumi.get(self, "auth_strategy")

    @property
    @pulumi.getter(name="enableApiTokens")
    def enable_api_tokens(self) -> bool:
        return pulumi.get(self, "enable_api_tokens")

    @property
    @pulumi.getter(name="enableRoles")
    def enable_roles(self) -> bool:
        return pulumi.get(self, "enable_roles")

    @property
    @pulumi.getter(name="jwtAccessTokenExpiration")
    def jwt_access_token_expiration(self) -> int:
        return pulumi.get(self, "jwt_access_token_expiration")

    @property
    @pulumi.getter(name="jwtRefreshTokenExpiration")
    def jwt_refresh_token_expiration(self) -> int:
        return pulumi.get(self, "jwt_refresh_token_expiration")

    @property
    @pulumi.getter(name="sameSiteCookiePolicy")
    def same_site_cookie_policy(self) -> str:
        return pulumi.get(self, "same_site_cookie_policy")

    @property
    @pulumi.getter(name="jwtAlgorithm")
    def jwt_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "jwt_algorithm")

    @property
    @pulumi.getter(name="jwtPublicKey")
    def jwt_public_key(self) -> Optional[str]:
        return pulumi.get(self, "jwt_public_key")

    @property
    @pulumi.getter(name="machineToMachineAuthStrategy")
    def machine_to_machine_auth_strategy(self) -> Optional[str]:
        return pulumi.get(self, "machine_to_machine_auth_strategy")


@pulumi.output_type
class WorkspaceBulkTenantsInvitesEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceBulkTenantsInvitesEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceBulkTenantsInvitesEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceBulkTenantsInvitesEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceBulkTenantsInvitesEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceCaptchaPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minScore":
            suggest = "min_score"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "siteKey":
            suggest = "site_key"
        elif key == "ignoredEmails":
            suggest = "ignored_emails"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceCaptchaPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceCaptchaPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceCaptchaPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_score: float,
                 secret_key: str,
                 site_key: str,
                 ignored_emails: Optional[Sequence[str]] = None):
        WorkspaceCaptchaPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            min_score=min_score,
            secret_key=secret_key,
            site_key=site_key,
            ignored_emails=ignored_emails,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             min_score: Optional[float] = None,
             secret_key: Optional[str] = None,
             site_key: Optional[str] = None,
             ignored_emails: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if min_score is None and 'minScore' in kwargs:
            min_score = kwargs['minScore']
        if min_score is None:
            raise TypeError("Missing 'min_score' argument")
        if secret_key is None and 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if secret_key is None:
            raise TypeError("Missing 'secret_key' argument")
        if site_key is None and 'siteKey' in kwargs:
            site_key = kwargs['siteKey']
        if site_key is None:
            raise TypeError("Missing 'site_key' argument")
        if ignored_emails is None and 'ignoredEmails' in kwargs:
            ignored_emails = kwargs['ignoredEmails']

        _setter("min_score", min_score)
        _setter("secret_key", secret_key)
        _setter("site_key", site_key)
        if ignored_emails is not None:
            _setter("ignored_emails", ignored_emails)

    @property
    @pulumi.getter(name="minScore")
    def min_score(self) -> float:
        return pulumi.get(self, "min_score")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> str:
        return pulumi.get(self, "site_key")

    @property
    @pulumi.getter(name="ignoredEmails")
    def ignored_emails(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ignored_emails")


@pulumi.output_type
class WorkspaceFacebookSocialLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceFacebookSocialLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceFacebookSocialLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceFacebookSocialLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_url: str,
                 client_id: Optional[str] = None,
                 customised: Optional[bool] = None,
                 secret: Optional[str] = None):
        WorkspaceFacebookSocialLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_url=redirect_url,
            client_id=client_id,
            customised=customised,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_url: Optional[str] = None,
             client_id: Optional[str] = None,
             customised: Optional[bool] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if redirect_url is None:
            raise TypeError("Missing 'redirect_url' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']

        _setter("redirect_url", redirect_url)
        if client_id is not None:
            _setter("client_id", client_id)
        if customised is not None:
            _setter("customised", customised)
        if secret is not None:
            _setter("secret", secret)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> str:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def customised(self) -> Optional[bool]:
        return pulumi.get(self, "customised")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        return pulumi.get(self, "secret")


@pulumi.output_type
class WorkspaceGithubSocialLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceGithubSocialLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceGithubSocialLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceGithubSocialLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_url: str,
                 client_id: Optional[str] = None,
                 customised: Optional[bool] = None,
                 secret: Optional[str] = None):
        WorkspaceGithubSocialLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_url=redirect_url,
            client_id=client_id,
            customised=customised,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_url: Optional[str] = None,
             client_id: Optional[str] = None,
             customised: Optional[bool] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if redirect_url is None:
            raise TypeError("Missing 'redirect_url' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']

        _setter("redirect_url", redirect_url)
        if client_id is not None:
            _setter("client_id", client_id)
        if customised is not None:
            _setter("customised", customised)
        if secret is not None:
            _setter("secret", secret)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> str:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def customised(self) -> Optional[bool]:
        return pulumi.get(self, "customised")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        return pulumi.get(self, "secret")


@pulumi.output_type
class WorkspaceGoogleSocialLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceGoogleSocialLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceGoogleSocialLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceGoogleSocialLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_url: str,
                 client_id: Optional[str] = None,
                 customised: Optional[bool] = None,
                 secret: Optional[str] = None):
        WorkspaceGoogleSocialLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_url=redirect_url,
            client_id=client_id,
            customised=customised,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_url: Optional[str] = None,
             client_id: Optional[str] = None,
             customised: Optional[bool] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if redirect_url is None:
            raise TypeError("Missing 'redirect_url' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']

        _setter("redirect_url", redirect_url)
        if client_id is not None:
            _setter("client_id", client_id)
        if customised is not None:
            _setter("customised", customised)
        if secret is not None:
            _setter("secret", secret)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> str:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def customised(self) -> Optional[bool]:
        return pulumi.get(self, "customised")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        return pulumi.get(self, "secret")


@pulumi.output_type
class WorkspaceHostedLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedRedirectUrls":
            suggest = "allowed_redirect_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceHostedLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceHostedLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceHostedLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_redirect_urls: Optional[Sequence[str]] = None):
        WorkspaceHostedLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_redirect_urls=allowed_redirect_urls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_redirect_urls: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_redirect_urls is None and 'allowedRedirectUrls' in kwargs:
            allowed_redirect_urls = kwargs['allowedRedirectUrls']

        if allowed_redirect_urls is not None:
            _setter("allowed_redirect_urls", allowed_redirect_urls)

    @property
    @pulumi.getter(name="allowedRedirectUrls")
    def allowed_redirect_urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_redirect_urls")


@pulumi.output_type
class WorkspaceLockoutPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAttempts":
            suggest = "max_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceLockoutPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceLockoutPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceLockoutPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_attempts: int):
        WorkspaceLockoutPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_attempts=max_attempts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_attempts: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_attempts is None and 'maxAttempts' in kwargs:
            max_attempts = kwargs['maxAttempts']
        if max_attempts is None:
            raise TypeError("Missing 'max_attempts' argument")

        _setter("max_attempts", max_attempts)

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> int:
        return pulumi.get(self, "max_attempts")


@pulumi.output_type
class WorkspaceMagicCodeEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceMagicCodeEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceMagicCodeEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceMagicCodeEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceMagicCodeEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceMagicLinkEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceMagicLinkEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceMagicLinkEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceMagicLinkEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceMagicLinkEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceMfaAuthenticationApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceMfaAuthenticationApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceMfaAuthenticationApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceMfaAuthenticationApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: str):
        WorkspaceMfaAuthenticationApp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")

        _setter("service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class WorkspaceMfaPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRememberDevice":
            suggest = "allow_remember_device"
        elif key == "deviceExpiration":
            suggest = "device_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceMfaPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceMfaPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceMfaPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remember_device: bool,
                 device_expiration: int,
                 enforce: str):
        WorkspaceMfaPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_remember_device=allow_remember_device,
            device_expiration=device_expiration,
            enforce=enforce,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_remember_device: Optional[bool] = None,
             device_expiration: Optional[int] = None,
             enforce: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_remember_device is None and 'allowRememberDevice' in kwargs:
            allow_remember_device = kwargs['allowRememberDevice']
        if allow_remember_device is None:
            raise TypeError("Missing 'allow_remember_device' argument")
        if device_expiration is None and 'deviceExpiration' in kwargs:
            device_expiration = kwargs['deviceExpiration']
        if device_expiration is None:
            raise TypeError("Missing 'device_expiration' argument")
        if enforce is None:
            raise TypeError("Missing 'enforce' argument")

        _setter("allow_remember_device", allow_remember_device)
        _setter("device_expiration", device_expiration)
        _setter("enforce", enforce)

    @property
    @pulumi.getter(name="allowRememberDevice")
    def allow_remember_device(self) -> bool:
        return pulumi.get(self, "allow_remember_device")

    @property
    @pulumi.getter(name="deviceExpiration")
    def device_expiration(self) -> int:
        return pulumi.get(self, "device_expiration")

    @property
    @pulumi.getter
    def enforce(self) -> str:
        return pulumi.get(self, "enforce")


@pulumi.output_type
class WorkspaceMicrosoftSocialLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceMicrosoftSocialLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceMicrosoftSocialLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceMicrosoftSocialLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_url: str,
                 client_id: Optional[str] = None,
                 customised: Optional[bool] = None,
                 secret: Optional[str] = None):
        WorkspaceMicrosoftSocialLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_url=redirect_url,
            client_id=client_id,
            customised=customised,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_url: Optional[str] = None,
             client_id: Optional[str] = None,
             customised: Optional[bool] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if redirect_url is None:
            raise TypeError("Missing 'redirect_url' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']

        _setter("redirect_url", redirect_url)
        if client_id is not None:
            _setter("client_id", client_id)
        if customised is not None:
            _setter("customised", customised)
        if secret is not None:
            _setter("secret", secret)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> str:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def customised(self) -> Optional[bool]:
        return pulumi.get(self, "customised")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        return pulumi.get(self, "secret")


@pulumi.output_type
class WorkspaceNewDeviceConnectedEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceNewDeviceConnectedEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceNewDeviceConnectedEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceNewDeviceConnectedEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceNewDeviceConnectedEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectUrl":
            suggest = "redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_url: str):
        WorkspaceOidc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_url=redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if redirect_url is None:
            raise TypeError("Missing 'redirect_url' argument")

        _setter("redirect_url", redirect_url)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> str:
        return pulumi.get(self, "redirect_url")


@pulumi.output_type
class WorkspacePasswordPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPassphrases":
            suggest = "allow_passphrases"
        elif key == "maxLength":
            suggest = "max_length"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "minPhraseLength":
            suggest = "min_phrase_length"
        elif key == "minTests":
            suggest = "min_tests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspacePasswordPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspacePasswordPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspacePasswordPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_passphrases: bool,
                 history: int,
                 max_length: int,
                 min_length: int,
                 min_phrase_length: int,
                 min_tests: int):
        WorkspacePasswordPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_passphrases=allow_passphrases,
            history=history,
            max_length=max_length,
            min_length=min_length,
            min_phrase_length=min_phrase_length,
            min_tests=min_tests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_passphrases: Optional[bool] = None,
             history: Optional[int] = None,
             max_length: Optional[int] = None,
             min_length: Optional[int] = None,
             min_phrase_length: Optional[int] = None,
             min_tests: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_passphrases is None and 'allowPassphrases' in kwargs:
            allow_passphrases = kwargs['allowPassphrases']
        if allow_passphrases is None:
            raise TypeError("Missing 'allow_passphrases' argument")
        if history is None:
            raise TypeError("Missing 'history' argument")
        if max_length is None and 'maxLength' in kwargs:
            max_length = kwargs['maxLength']
        if max_length is None:
            raise TypeError("Missing 'max_length' argument")
        if min_length is None and 'minLength' in kwargs:
            min_length = kwargs['minLength']
        if min_length is None:
            raise TypeError("Missing 'min_length' argument")
        if min_phrase_length is None and 'minPhraseLength' in kwargs:
            min_phrase_length = kwargs['minPhraseLength']
        if min_phrase_length is None:
            raise TypeError("Missing 'min_phrase_length' argument")
        if min_tests is None and 'minTests' in kwargs:
            min_tests = kwargs['minTests']
        if min_tests is None:
            raise TypeError("Missing 'min_tests' argument")

        _setter("allow_passphrases", allow_passphrases)
        _setter("history", history)
        _setter("max_length", max_length)
        _setter("min_length", min_length)
        _setter("min_phrase_length", min_phrase_length)
        _setter("min_tests", min_tests)

    @property
    @pulumi.getter(name="allowPassphrases")
    def allow_passphrases(self) -> bool:
        return pulumi.get(self, "allow_passphrases")

    @property
    @pulumi.getter
    def history(self) -> int:
        return pulumi.get(self, "history")

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> int:
        return pulumi.get(self, "max_length")

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> int:
        return pulumi.get(self, "min_length")

    @property
    @pulumi.getter(name="minPhraseLength")
    def min_phrase_length(self) -> int:
        return pulumi.get(self, "min_phrase_length")

    @property
    @pulumi.getter(name="minTests")
    def min_tests(self) -> int:
        return pulumi.get(self, "min_tests")


@pulumi.output_type
class WorkspacePwnedPasswordEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspacePwnedPasswordEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspacePwnedPasswordEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspacePwnedPasswordEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspacePwnedPasswordEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceResetPasswordEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceResetPasswordEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceResetPasswordEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceResetPasswordEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceResetPasswordEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceResetPhoneNumberEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceResetPhoneNumberEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceResetPhoneNumberEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceResetPhoneNumberEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceResetPhoneNumberEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acsUrl":
            suggest = "acs_url"
        elif key == "spEntityId":
            suggest = "sp_entity_id"
        elif key == "redirectUrl":
            suggest = "redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acs_url: str,
                 sp_entity_id: str,
                 redirect_url: Optional[str] = None):
        WorkspaceSaml._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acs_url=acs_url,
            sp_entity_id=sp_entity_id,
            redirect_url=redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acs_url: Optional[str] = None,
             sp_entity_id: Optional[str] = None,
             redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acs_url is None and 'acsUrl' in kwargs:
            acs_url = kwargs['acsUrl']
        if acs_url is None:
            raise TypeError("Missing 'acs_url' argument")
        if sp_entity_id is None and 'spEntityId' in kwargs:
            sp_entity_id = kwargs['spEntityId']
        if sp_entity_id is None:
            raise TypeError("Missing 'sp_entity_id' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']

        _setter("acs_url", acs_url)
        _setter("sp_entity_id", sp_entity_id)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> str:
        return pulumi.get(self, "acs_url")

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> str:
        return pulumi.get(self, "sp_entity_id")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")


@pulumi.output_type
class WorkspaceUserActivationEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceUserActivationEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceUserActivationEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceUserActivationEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceUserActivationEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceUserInvitationEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceUserInvitationEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceUserInvitationEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceUserInvitationEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceUserInvitationEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


@pulumi.output_type
class WorkspaceUserUsedInvitationEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "htmlTemplate":
            suggest = "html_template"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "successRedirectUrl":
            suggest = "success_redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceUserUsedInvitationEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceUserUsedInvitationEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceUserUsedInvitationEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: str,
                 from_name: str,
                 html_template: str,
                 subject: str,
                 redirect_url: Optional[str] = None,
                 success_redirect_url: Optional[str] = None):
        WorkspaceUserUsedInvitationEmail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_address=from_address,
            from_name=from_name,
            html_template=html_template,
            subject=subject,
            redirect_url=redirect_url,
            success_redirect_url=success_redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_address: Optional[str] = None,
             from_name: Optional[str] = None,
             html_template: Optional[str] = None,
             subject: Optional[str] = None,
             redirect_url: Optional[str] = None,
             success_redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_address is None and 'fromAddress' in kwargs:
            from_address = kwargs['fromAddress']
        if from_address is None:
            raise TypeError("Missing 'from_address' argument")
        if from_name is None and 'fromName' in kwargs:
            from_name = kwargs['fromName']
        if from_name is None:
            raise TypeError("Missing 'from_name' argument")
        if html_template is None and 'htmlTemplate' in kwargs:
            html_template = kwargs['htmlTemplate']
        if html_template is None:
            raise TypeError("Missing 'html_template' argument")
        if subject is None:
            raise TypeError("Missing 'subject' argument")
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if success_redirect_url is None and 'successRedirectUrl' in kwargs:
            success_redirect_url = kwargs['successRedirectUrl']

        _setter("from_address", from_address)
        _setter("from_name", from_name)
        _setter("html_template", html_template)
        _setter("subject", subject)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if success_redirect_url is not None:
            _setter("success_redirect_url", success_redirect_url)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> str:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> str:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter(name="htmlTemplate")
    def html_template(self) -> str:
        return pulumi.get(self, "html_template")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter(name="successRedirectUrl")
    def success_redirect_url(self) -> Optional[str]:
        return pulumi.get(self, "success_redirect_url")


