# Stealth25519 Python Package

The `Stealth25519` Python package provides functionality for the generation, verification, and signing of stealth addresses using the standard ed25519 algorithm with the ECDH protocol.

## Stealth Address Features

- The sender can generate a stealth address using the public view and spend key of the recipient.
- The recipient can use their public spend key and private view key to identify transactions intended for them.
- The recipient can sign transactions for all transactions that belong to them.
- The signature generated by the recipient can be verified by anyone with the stealth address public key.

## Installation

```bash
pip install stealth25519
```

## Example Usage

### Generating and Loading Private Keys

```python
from cryptography.hazmat.primitives.asymmetric import ed25519
from stealth25519.key import PrivateKey, PublicKey

# Generate or load private key from cryptography or any other library as bytes array
private_spend_key_ = '6e2096a4aeb83752be2c2072d26d8c526c9bb7c5957289fc6feb85bd7da8dbf3'
private_view_key_ = ed25519.Ed25519PrivateKey.generate()

private_spend_key = PrivateKey(bytes.fromhex( private_spend_key_))
private_view_key = PrivateKey(private_view_key_.private_bytes_raw())

public_spend_key = private_spend_key.generatePublicKey()
public_view_key = private_view_key.generatePublicKey()

print('Private spend key: ', private_spend_key)
print('Private view key: ', private_view_key)
print('Public spend key: ', public_spend_key)
print('Public view key: ', public_view_key)
```

### Output

After generating and loading the private keys, the output would be:

```plaintext
Private spend key:  6e2096a4aeb83752be2c2072d26d8c526c9bb7c5957289fc6feb85bd7da8dbf3
Private view key:   0f516f860b87d991924be8dbe00f15d8633ee6168b77e38ef7646771d8056d56
Public spend key:   c32dd358fa8fbea62d3b875c7b0db1631a39b643ff7a8f180de4878b2298be06
Public view key:    874e1029399477a9537b5015580ff8cc4701ecd8ced251fbe75ba7b9cc3fb3be
```



### Generating a Stealth Address

```python
from stealth25519.generator import StealthAddressGenerator

public_spend_key_bytes = bytes.fromhex('18a498c68461e39dd180745e5aa1faacbc9b8a5f74a7eb25b5038b66db0a4af6')
public_view_key_bytes = bytes.fromhex('b52c33b513c26e17b7105cb1ed1c7022ef00f3967aaac0ff8bd9d15ccee4d94e')

public_spend_key = PublicKey(public_spend_key_bytes)
public_view_key = PublicKey(public_view_key_bytes)

generator = StealthAddressGenerator(public_spend_key, public_view_key, hash_function = sha512)
stealth_address = generator.generate()
print('Stealth Address\n', stealth_address)
```

### Output

After generating the stealth address the output would be:

```plaintext
Stealth Address
R: f694a725eade1f938797a87ba09d505f4be4358c1e8a865a3ef0ae202bb8b827
P: 573fff985d6407e747a845ff9f6d245b65b68beb3738837d207943f7697a6338
```

### Verifying a Stealth Address

```python
from stealth25519.verifier import StealthAddressVerifier

private_view_key_bytes = bytes.fromhex('8cdc2d3879363eff3c187ee494c7154ac63a4b94c1814488fd46c4f2bafc2239')
public_spend_key_bytes = bytes.fromhex('18a498c68461e39dd180745e5aa1faacbc9b8a5f74a7eb25b5038b66db0a4af6')
R = bytes.fromhex('f694a725eade1f938797a87ba09d505f4be4358c1e8a865a3ef0ae202bb8b827')
P = bytes.fromhex('573fff985d6407e747a845ff9f6d245b65b68beb3738837d207943f7697a6338')

private_view_key = PrivateKey(private_view_key_bytes)
public_spend_key = PublicKey(public_spend_key_bytes)

stealth_address = StealthAddress(R, P)
verifier = StealthAddressVerifier(private_view_key, public_spend_key, hash_function = sha512)
results = verifier.verify(stealth_address)

print('Stealth address verified: ', results)
```

### Output

The verification of the stealth address would output:

```plaintext
Stealth address verified:  True
```

### Signing a Stealth Address

```python
from stealth25519.signer import StealthAddressSigner

private_spend_key_bytes = bytes.fromhex('da4956d53efc1c48472080ca284948399ef5dcb1feb47ebd5017330ca2416c30')
private_view_key_bytes = bytes.fromhex('8cdc2d3879363eff3c187ee494c7154ac63a4b94c1814488fd46c4f2bafc2239')
R = bytes.fromhex('f694a725eade1f938797a87ba09d505f4be4358c1e8a865a3ef0ae202bb8b827')
P = bytes.fromhex('573fff985d6407e747a845ff9f6d245b65b68beb3738837d207943f7697a6338')

private_spend_key = PrivateKey(private_spend_key_bytes)
private_view_key = PrivateKey(private_view_key_bytes)

msg = b'somedata'
stealth_address = StealthAddress(R, P)
signer = StealthAddressSigner(private_spend_key, private_view_key, hash_function = sha512)
sig = signer.sign(stealth_address, msg)
print('Stealth signature: ', sig.hex())

```

### Output
```plaintext
Stealth signature:  56dcf17a9fd91b7d3d0dffc7ea86fd1cb1dda94caff964c2533c63ecd52166377684fa60f2cfe5258f9e5c8247db4e5003a73c1d0fbd42c56f31a7b996089404
```

### Signature Verification
The signature generated using the private spend key can be verified using the public key of the stealth address (P). This verification can be done by anyone using the ed25519 signature algorithm (ECDSA). 

```python
from cryptography.hazmat.primitives.asymmetric import ed25519

def verify_ed25519_signature(public_key_bytes, signature_bytes, message):
    public_key = ed25519.Ed25519PublicKey.from_public_bytes(public_key_bytes)
    try:
        public_key.verify(signature_bytes, message)
        return True
    except Exception as e:
        print(f"Signature verification failed: {str(e)}")
        return False

public_key_hex = '1d3796436ecf22b674f60990945fb09d4a5dd4ad6c16e04dd20ff46e71935fc5'
signature_hex = '56dcf17a9fd91b7d3d0dffc7ea86fd1cb1dda94caff964c2533c63ecd52166377684fa60f2cfe5258f9e5c8247db4e5003a73c1d0fbd42c56f31a7b996089404'
message = b'somedata'

public_key_bytes = bytes.fromhex(public_key_hex)
signature_bytes = bytes.fromhex(signature_hex)


verification_result = verify_ed25519_signature(public_key_bytes, signature_bytes, message)
print('Signature verification result:', verification_result)
```

### Output
```plaintext
Signature verification result: True
```

### Generate and verify stealth address using custom hash function (Keccak256)
This Python code snippet demonstrates the generation and verification of stealth addresses using a custom hash function, specifically Keccak256. 

```python
from Crypto.Hash import keccak

def keccak256(s):
    keccak_hash = keccak.new(digest_bits=256)
    keccak_hash.update(s)
    return keccak_hash.digest()

# Generating and verifying stealth addresses with keccak

sa_generator = StealthAddressGenerator(public_spend_key, public_view_key, keccak256)
stealth_address = sa_generator.generate()
print('Stealth Address\n', stealth_address)

sa_verifier = StealthAddressVerifier(private_view_key, public_spend_key, keccak256)
verified = sa_verifier.verify(stealth_address)
print('Stealth Address Verified: ', verified)
```

Note: The code assumes that the necessary variables (public_spend_key, public_view_key, private_view_key) are defined before this snippet is executed.

### Output
```plaintext
Stealth Address
R: c4904e7df617dd93a02375771b76270950b22eec968ad82bc903f06bf8508c3c
P: 14ec8b2ae19fa492423e8402a63a3fd48326864c01409e9001af0066f532aeca
Stealth Address Verified:  True
```

## Dependencies
Crypto libraries (Ensure they are installed using `pip install pycryptodome cryptography`)