# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_grds.ipynb.

# %% auto 0
__all__ = ['guard', 'tset', 'tlist', 'tdict', 'ttype', 'ttuple', 'tunion', 'tliteral', 'tgeneric', 'tclassvar', 'eqtype',
           'eqlist', 'eqtuple', 'equnion', 'eqliteral', 'isstrbytes', 'notstrbytes', 'isstrq', 'notiterstr',
           'isallsame', 'aliascheck']

# %% ../nbs/02_grds.ipynb 6
import os, inspect
from functools import wraps

# %% ../nbs/02_grds.ipynb 8
from types import NoneType 
from typing import (
    Any, Set, Dict, List, Tuple, Union, ClassVar, Generic, Literal, 
    Callable, Iterable, get_args, get_origin, Type, TypeGuard,
)

# %% ../nbs/02_grds.ipynb 10
#| export


# %% ../nbs/02_grds.ipynb 12
#| export


# %% ../nbs/02_grds.ipynb 14
from .type import (T, GuardFunc, StrFactory,)
from .util import (guardname, guarddocs, guardanns,)

# %% ../nbs/02_grds.ipynb 17
def guard(
    *types: Type[T], 
    docsfn: StrFactory = guarddocs, 
    namefn: StrFactory = guardname, 
    annsfn: StrFactory = guardanns,
    negate: bool = False,
    optional: bool = False,
) -> Callable[[Callable[[Any], bool]], Callable[[Any], TypeGuard[T]]]:
    dtypes = (*types, ) + ((NoneType, ) if optional else ())
    def decorator(func:  Callable[[Any], bool]) -> Callable[[Any], TypeGuard[T]]:
        @wraps(func, updated=())
        def wrapper(x: Any) -> TypeGuard[T]:
            return not isinstance(x, dtypes) if negate == True else isinstance(x, dtypes)
        wrapper.__doc__ = docsfn(*dtypes)
        wrapper.__name__ = namefn(*dtypes)
        wrapper.__annotations__ = annsfn(*dtypes)
        return wrapper
    return decorator

# %% ../nbs/02_grds.ipynb 19
def tset(t: Type) -> bool: return get_origin(t) is Set
def tlist(t: Type) -> bool: return get_origin(t) is List
def tdict(t: Type) -> bool: return get_origin(t) is Dict
def ttype(t: Type) -> bool: return get_origin(t) is type
def ttuple(t: Type) -> bool: return get_origin(t) is Tuple
def tunion(t: Type) -> bool: return get_origin(t) is Union
def tliteral(t: Type) -> bool: return get_origin(t) is Literal
def tgeneric(t: Type) -> bool: return get_origin(t) is Generic
def tclassvar(t: Type) -> bool: return get_origin(t) is ClassVar

# %% ../nbs/02_grds.ipynb 21
def eqtype(val, obj: Type, guard: GuardFunc = tliteral) -> TypeGuard[Type]:
    if not guard(obj): return False
    try: return any((val == (args := get_args(obj)), val in args, val == obj))
    except: return False
    
def eqlist(val, obj: Type) -> TypeGuard[Type]: return eqtype(val, obj, tlist)
def eqtuple(val, obj: Type) -> TypeGuard[Type]: return eqtype(val, obj, ttuple)
def equnion(val, obj: Type) -> TypeGuard[Type]: return eqtype(val, obj, tunion)
def eqliteral(val, obj: Type) -> TypeGuard[Type]: return eqtype(val, obj, tliteral)

# %% ../nbs/02_grds.ipynb 23
@guard(str, bytes)
def isstrbytes(x): ...
@guard(str, bytes, negate=True)
def notstrbytes(x): ...
@guard(str, optional=True)
def isstrq(x): ...

def notiterstr(x) -> TypeGuard[Iterable['NotStrBytes']]:
    return isinstance(x, Iterable) and notstrbytes(x)    

def isallsame(it: Iterable, dtype: T) -> TypeGuard[Iterable[T]]:
    for el in it:
        if notiterstr(el):
            if not isallsame(el, dtype): 
                return False
        elif not isinstance(el, dtype): 
            return False
    return True

# %% ../nbs/02_grds.ipynb 25
def aliascheck(obj, types, attrs: dict = dict()):
    found = False
    for t in types:
        try:
            if (found := isinstance(obj, t)): break
        except TypeError:
            try:
                if (found := eqlist(obj, t)): break
                if (found := eqtuple(obj, t)): break
                if (found := equnion(obj, t)): break
                if (found := eqliteral(obj, t)): break
                if (found := obj == t): break
            except: ...

    if not found: return False
    
    for attr, val in attrs.items():
        if attr in {'types', 'dtype', 'type'} and notiterstr(obj) and isallsame(obj, val): continue                        
        if getattr(obj, attr, None) == val: continue
        return False        
    return True
