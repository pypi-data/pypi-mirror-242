import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_guardduty as _aws_cdk_aws_guardduty_ceddda9d
import constructs as _constructs_77d1e7e8


class DataSource(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.guardduty.DataSource",
):
    '''A data source that will be configured for a GuardDuty detector.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="kubernetes")
    @builtins.classmethod
    def kubernetes(
        cls,
        *,
        audit_logs: typing.Optional[builtins.bool] = None,
    ) -> "IDataSource":
        '''Creates a data source configuration for processing Kubernetes (EKS) events.

        :param audit_logs: Controls whether EKS audit logs should be used as a data source for GuardDuty.

        :return: An object representing the configured data source.
        '''
        options = KubernetesOptions(audit_logs=audit_logs)

        return typing.cast("IDataSource", jsii.sinvoke(cls, "kubernetes", [options]))

    @jsii.member(jsii_name="malwareProtection")
    @builtins.classmethod
    def malware_protection(
        cls,
        *,
        ebs_volumes: typing.Optional[builtins.bool] = None,
    ) -> "IDataSource":
        '''Creates a data source configuration allowing GuardDuty top perform malware scanning.

        :param ebs_volumes: Controls whether EBS volumes should be scanned for malware by GuardDuty.

        :return: An object representing the configured data source.
        '''
        options = MalwareProtectionOptions(ebs_volumes=ebs_volumes)

        return typing.cast("IDataSource", jsii.sinvoke(cls, "malwareProtection", [options]))

    @jsii.member(jsii_name="s3Logs")
    @builtins.classmethod
    def s3_logs(
        cls,
        *,
        enabled: typing.Optional[builtins.bool] = None,
    ) -> "IDataSource":
        '''Creates a data source configuration for analyzing S3 data events in GuardDuty.

        :param enabled: Controls whether S3 data events are enabled as a data source for GuardDuty.

        :return: An object representing the configured data source.
        '''
        options = S3LogsOptions(enabled=enabled)

        return typing.cast("IDataSource", jsii.sinvoke(cls, "s3Logs", [options]))


@jsii.data_type(
    jsii_type="cdk-extensions.guardduty.DetectorAttributes",
    jsii_struct_bases=[],
    name_mapping={"detector_arn": "detectorArn", "detector_id": "detectorId"},
)
class DetectorAttributes:
    def __init__(
        self,
        *,
        detector_arn: typing.Optional[builtins.str] = None,
        detector_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for importing an existing GuardDuty detector.

        :param detector_arn: The Amazon Resource Name (ARN) of the GuardDuty detector.
        :param detector_id: The ID generated by AWS for the GuardDuty detector.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d12ae76291e803174ca171a5fc85d1b4c28b339c057ed8f75568af3b4a877628)
            check_type(argname="argument detector_arn", value=detector_arn, expected_type=type_hints["detector_arn"])
            check_type(argname="argument detector_id", value=detector_id, expected_type=type_hints["detector_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if detector_arn is not None:
            self._values["detector_arn"] = detector_arn
        if detector_id is not None:
            self._values["detector_id"] = detector_id

    @builtins.property
    def detector_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the GuardDuty detector.'''
        result = self._values.get("detector_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def detector_id(self) -> typing.Optional[builtins.str]:
        '''The ID generated by AWS for the GuardDuty detector.'''
        result = self._values.get("detector_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DetectorAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.guardduty.DetectorOptions",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "features": "features",
        "publishing_frequency": "publishingFrequency",
    },
)
class DetectorOptions:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        features: typing.Optional[typing.Sequence["IFeature"]] = None,
        publishing_frequency: typing.Optional["FindingPublishingFrequency"] = None,
    ) -> None:
        '''Optional configuration for the detector resource.

        :param enabled: Specifies whether the detector is to be enabled on creation.
        :param features: Collection of additional features to be configured on the detector.
        :param publishing_frequency: Specifies how frequently updated findings are exported.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__498753c70e96c48c0ddf3b2dd9194cd2bc718f18ffdd31e00f0e644499841785)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument features", value=features, expected_type=type_hints["features"])
            check_type(argname="argument publishing_frequency", value=publishing_frequency, expected_type=type_hints["publishing_frequency"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if features is not None:
            self._values["features"] = features
        if publishing_frequency is not None:
            self._values["publishing_frequency"] = publishing_frequency

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether the detector is to be enabled on creation.

        :see: `Detector Enable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-enable>`_
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def features(self) -> typing.Optional[typing.List["IFeature"]]:
        '''Collection of additional features to be configured on the detector.

        :see: `Detector Features <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-features>`_
        '''
        result = self._values.get("features")
        return typing.cast(typing.Optional[typing.List["IFeature"]], result)

    @builtins.property
    def publishing_frequency(self) -> typing.Optional["FindingPublishingFrequency"]:
        '''Specifies how frequently updated findings are exported.

        :see: `Detector FindingPublishingFrequency <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-findingpublishingfrequency>`_
        '''
        result = self._values.get("publishing_frequency")
        return typing.cast(typing.Optional["FindingPublishingFrequency"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DetectorOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.guardduty.DetectorProps",
    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps, DetectorOptions],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "enabled": "enabled",
        "features": "features",
        "publishing_frequency": "publishingFrequency",
    },
)
class DetectorProps(_aws_cdk_ceddda9d.ResourceProps, DetectorOptions):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[builtins.bool] = None,
        features: typing.Optional[typing.Sequence["IFeature"]] = None,
        publishing_frequency: typing.Optional["FindingPublishingFrequency"] = None,
    ) -> None:
        '''Configuration for the dector resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param enabled: Specifies whether the detector is to be enabled on creation.
        :param features: Collection of additional features to be configured on the detector.
        :param publishing_frequency: Specifies how frequently updated findings are exported.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77a2139096812048b85f21b0d063223ce253705d2e41b86445168a137b2da4dd)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument features", value=features, expected_type=type_hints["features"])
            check_type(argname="argument publishing_frequency", value=publishing_frequency, expected_type=type_hints["publishing_frequency"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if enabled is not None:
            self._values["enabled"] = enabled
        if features is not None:
            self._values["features"] = features
        if publishing_frequency is not None:
            self._values["publishing_frequency"] = publishing_frequency

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether the detector is to be enabled on creation.

        :see: `Detector Enable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-enable>`_
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def features(self) -> typing.Optional[typing.List["IFeature"]]:
        '''Collection of additional features to be configured on the detector.

        :see: `Detector Features <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-features>`_
        '''
        result = self._values.get("features")
        return typing.cast(typing.Optional[typing.List["IFeature"]], result)

    @builtins.property
    def publishing_frequency(self) -> typing.Optional["FindingPublishingFrequency"]:
        '''Specifies how frequently updated findings are exported.

        :see: `Detector FindingPublishingFrequency <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-findingpublishingfrequency>`_
        '''
        result = self._values.get("publishing_frequency")
        return typing.cast(typing.Optional["FindingPublishingFrequency"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DetectorProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Feature(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.guardduty.Feature"):
    '''A feature that will be configured for a GuardDuty detector.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="ebsMalwareProtection")
    @builtins.classmethod
    def ebs_malware_protection(
        cls,
        *,
        enabled: typing.Optional[builtins.bool] = None,
    ) -> "IFeature":
        '''Controls whether GuardDuty should scan the EBS volumes associated with EC2 instances for malware and report the results.

        :param enabled: Whether the feature should be enabled or not.

        :return: An object representing the configured feature.

        :see: `GuardDuty Malware Protection <https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html>`_
        '''
        options = FeatureOptions(enabled=enabled)

        return typing.cast("IFeature", jsii.sinvoke(cls, "ebsMalwareProtection", [options]))

    @jsii.member(jsii_name="eksAuditLogs")
    @builtins.classmethod
    def eks_audit_logs(
        cls,
        *,
        enabled: typing.Optional[builtins.bool] = None,
    ) -> "IFeature":
        '''Helps you detect potentially suspicious activities in your EKS clusters within Amazon Elastic Kubernetes Service by monitoring the audit logs generated by your clusters.

        :param enabled: Whether the feature should be enabled or not.

        :return: An object representing the configured feature.

        :see: `EKS Audit Log Monitoring <https://docs.aws.amazon.com/guardduty/latest/ug/guardduty-eks-audit-log-monitoring.html>`_
        '''
        options = FeatureOptions(enabled=enabled)

        return typing.cast("IFeature", jsii.sinvoke(cls, "eksAuditLogs", [options]))

    @jsii.member(jsii_name="eksRuntimeMonitoring")
    @builtins.classmethod
    def eks_runtime_monitoring(
        cls,
        *,
        addon_management: typing.Optional[builtins.bool] = None,
        enabled: typing.Optional[builtins.bool] = None,
    ) -> "IFeature":
        '''EKS Runtime Monitoring provides runtime threat detection coverage for Amazon Elastic Kubernetes Service (Amazon EKS) nodes and containers within your AWS environment.

        EKS Runtime Monitoring uses a new GuardDuty security
        agent that adds runtime visibility into individual EKS workloads, for
        example, file access, process execution, and network connections.

        :param addon_management: Determines whether GuardDuty is allowed to manage addons for the EKS cluster. If both runtime monitoring and addon management are enabled GuardDuty can automatically manage the GuardDuty security agent addon that is used to send findings to GuardDuty. If runtime monitoring is enabled and addon management is disabled you must manage the GuardDuty security agent manually.
        :param enabled: Whether the feature should be enabled or not.

        :return: An object representing the configured feature.

        :see: `EKS Runtime Monitoring <https://docs.aws.amazon.com/guardduty/latest/ug/guardduty-eks-runtime-monitoring.html>`_
        '''
        options = EksRuntimeMonitoringOptions(
            addon_management=addon_management, enabled=enabled
        )

        return typing.cast("IFeature", jsii.sinvoke(cls, "eksRuntimeMonitoring", [options]))

    @jsii.member(jsii_name="lambdaNetworkLogs")
    @builtins.classmethod
    def lambda_network_logs(
        cls,
        *,
        enabled: typing.Optional[builtins.bool] = None,
    ) -> "IFeature":
        '''Lambda Protection helps you identify potential security threats when an AWS Lambda function gets invoked in your AWS environment.

        When you enable
        Lambda Protection, GuardDuty starts monitoring Lambda network activity
        logs, starting with VPC Flow Logs from all Lambda functions for account,
        including those logs that don't use VPC networking, and are generated when
        the Lambda function gets invoked.

        :param enabled: Whether the feature should be enabled or not.

        :return: An object representing the configured feature.

        :see: `GuardDuty Lambda Protection <https://docs.aws.amazon.com/guardduty/latest/ug/guardduty-eks-runtime-monitoring.html>`_
        '''
        options = FeatureOptions(enabled=enabled)

        return typing.cast("IFeature", jsii.sinvoke(cls, "lambdaNetworkLogs", [options]))

    @jsii.member(jsii_name="rdsLoginEvents")
    @builtins.classmethod
    def rds_login_events(
        cls,
        *,
        enabled: typing.Optional[builtins.bool] = None,
    ) -> "IFeature":
        '''RDS Protection in Amazon GuardDuty analyzes and profiles RDS login activity for potential access threats to your Amazon Aurora databases (Amazon Aurora MySQL-Compatible Edition and Aurora PostgreSQL-Compatible Edition).

        :param enabled: Whether the feature should be enabled or not.

        :return: An object representing the configured feature.

        :see: `GuardDuty RDS Protection <https://docs.aws.amazon.com/guardduty/latest/ug/guardduty-eks-runtime-monitoring.html>`_
        '''
        options = FeatureOptions(enabled=enabled)

        return typing.cast("IFeature", jsii.sinvoke(cls, "rdsLoginEvents", [options]))

    @jsii.member(jsii_name="s3DataEvents")
    @builtins.classmethod
    def s3_data_events(
        cls,
        *,
        enabled: typing.Optional[builtins.bool] = None,
    ) -> "IFeature":
        '''S3 protection enables Amazon GuardDuty to monitor object-level API operations to identify potential security risks for data within your S3 buckets.

        :param enabled: Whether the feature should be enabled or not.

        :return: An object representing the configured feature.

        :see: `GuardDuty S3 Protection <https://docs.aws.amazon.com/guardduty/latest/ug/guardduty-eks-runtime-monitoring.html>`_
        '''
        options = FeatureOptions(enabled=enabled)

        return typing.cast("IFeature", jsii.sinvoke(cls, "s3DataEvents", [options]))


@jsii.data_type(
    jsii_type="cdk-extensions.guardduty.FeatureOptions",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class FeatureOptions:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''Configuration shared by all GuardDuty detector features.

        :param enabled: Whether the feature should be enabled or not.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d38a280758dab4c4d500d0d1689d9a5a8ca1419f0941b880a0d3b5fd241b94a)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether the feature should be enabled or not.

        :see: `FeatureConfigurations Status <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-status>`_
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FeatureOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class FindingPublishingFrequency(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.guardduty.FindingPublishingFrequency",
):
    '''Specifies how frequently updated findings are exported.

    :see: `Detector FindingPublishingFrequency <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-findingpublishingfrequency>`_
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, label: builtins.str) -> "FindingPublishingFrequency":
        '''Escape hatch for specifying custom publishing frequency values.

        This is primarily intended in case additional options are added and
        support for those values has not yet been officially added.

        Where possible it is recommended that the existing provided values be
        used.

        :param label: The label for the publishing frequency value as would be expected by CloudFormation.

        :return:

        An object that can be used for setting the publishing frequency
        for a detector resource.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab6fbf3bd9c88a73ebdfee03daba1747e8add1127ca6fc87c159ba18832d4a39)
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
        return typing.cast("FindingPublishingFrequency", jsii.sinvoke(cls, "of", [label]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FIFTEEN_MINUTES")
    def FIFTEEN_MINUTES(cls) -> "FindingPublishingFrequency":
        '''Publish findings every fifteen minutes.'''
        return typing.cast("FindingPublishingFrequency", jsii.sget(cls, "FIFTEEN_MINUTES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ONE_HOUR")
    def ONE_HOUR(cls) -> "FindingPublishingFrequency":
        '''Publish findings every hour.'''
        return typing.cast("FindingPublishingFrequency", jsii.sget(cls, "ONE_HOUR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SIX_HOURS")
    def SIX_HOURS(cls) -> "FindingPublishingFrequency":
        '''Publish findings every six hours.'''
        return typing.cast("FindingPublishingFrequency", jsii.sget(cls, "SIX_HOURS"))

    @builtins.property
    @jsii.member(jsii_name="label")
    def label(self) -> builtins.str:
        '''The label for the publishing frequency value as would be expected by CloudFormation.'''
        return typing.cast(builtins.str, jsii.get(self, "label"))


@jsii.interface(jsii_type="cdk-extensions.guardduty.IDataSource")
class IDataSource(typing_extensions.Protocol):
    '''Represents a data source that should be enabled on a detector.'''

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> _aws_cdk_aws_guardduty_ceddda9d.CfnDetector.CFNDataSourceConfigurationsProperty:
        '''Associates the data source with a resource configuring a GuardDuty detector.

        :param scope: The resource managing the detector being configured.
        '''
        ...


class _IDataSourceProxy:
    '''Represents a data source that should be enabled on a detector.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.guardduty.IDataSource"

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> _aws_cdk_aws_guardduty_ceddda9d.CfnDetector.CFNDataSourceConfigurationsProperty:
        '''Associates the data source with a resource configuring a GuardDuty detector.

        :param scope: The resource managing the detector being configured.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__835fce999fafcdc1ab328335bd2e7cc27d3d02658196cfa5e5782bf4f8e48230)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(_aws_cdk_aws_guardduty_ceddda9d.CfnDetector.CFNDataSourceConfigurationsProperty, jsii.invoke(self, "bind", [scope]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDataSource).__jsii_proxy_class__ = lambda : _IDataSourceProxy


@jsii.interface(jsii_type="cdk-extensions.guardduty.IDetector")
class IDetector(typing_extensions.Protocol):
    '''Represents a GuardDuty detector in AWS.'''

    @builtins.property
    @jsii.member(jsii_name="detectorArn")
    def detector_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the GuardDuty detector.'''
        ...

    @builtins.property
    @jsii.member(jsii_name="detectorId")
    def detector_id(self) -> builtins.str:
        '''The ID generated by AWS for the GuardDuty detector.'''
        ...


class _IDetectorProxy:
    '''Represents a GuardDuty detector in AWS.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.guardduty.IDetector"

    @builtins.property
    @jsii.member(jsii_name="detectorArn")
    def detector_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the GuardDuty detector.'''
        return typing.cast(builtins.str, jsii.get(self, "detectorArn"))

    @builtins.property
    @jsii.member(jsii_name="detectorId")
    def detector_id(self) -> builtins.str:
        '''The ID generated by AWS for the GuardDuty detector.'''
        return typing.cast(builtins.str, jsii.get(self, "detectorId"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDetector).__jsii_proxy_class__ = lambda : _IDetectorProxy


@jsii.interface(jsii_type="cdk-extensions.guardduty.IFeature")
class IFeature(typing_extensions.Protocol):
    '''Represents a feature that will be configured for a GuardDuty detector.

    :see: `DetectorFeatureConfiguration <https://docs.aws.amazon.com/guardduty/latest/APIReference/API_DetectorFeatureConfiguration.html>`_
    '''

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> builtins.bool:
        '''Whether the feature should be enabled or not.

        :see: `FeatureConfigurations Status <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-status>`_
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''Name of the feature.

        :see: `FeatureConfigurations Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-name>`_
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="dataSource")
    def data_source(self) -> typing.Optional[IDataSource]:
        '''Provides a data source that must be enabled for the feature to function.

        :see: `Detector DataSources <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-datasources>`_
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="settings")
    def settings(self) -> typing.Optional[typing.List["IFeatureSetting"]]:
        '''Additional configuration of the feature.

        :see: `FeatureConfigurations AdditionalConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-additionalconfiguration>`_
        '''
        ...


class _IFeatureProxy:
    '''Represents a feature that will be configured for a GuardDuty detector.

    :see: `DetectorFeatureConfiguration <https://docs.aws.amazon.com/guardduty/latest/APIReference/API_DetectorFeatureConfiguration.html>`_
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.guardduty.IFeature"

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> builtins.bool:
        '''Whether the feature should be enabled or not.

        :see: `FeatureConfigurations Status <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-status>`_
        '''
        return typing.cast(builtins.bool, jsii.get(self, "enabled"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''Name of the feature.

        :see: `FeatureConfigurations Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-name>`_
        '''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="dataSource")
    def data_source(self) -> typing.Optional[IDataSource]:
        '''Provides a data source that must be enabled for the feature to function.

        :see: `Detector DataSources <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-datasources>`_
        '''
        return typing.cast(typing.Optional[IDataSource], jsii.get(self, "dataSource"))

    @builtins.property
    @jsii.member(jsii_name="settings")
    def settings(self) -> typing.Optional[typing.List["IFeatureSetting"]]:
        '''Additional configuration of the feature.

        :see: `FeatureConfigurations AdditionalConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-additionalconfiguration>`_
        '''
        return typing.cast(typing.Optional[typing.List["IFeatureSetting"]], jsii.get(self, "settings"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IFeature).__jsii_proxy_class__ = lambda : _IFeatureProxy


@jsii.interface(jsii_type="cdk-extensions.guardduty.IFeatureSetting")
class IFeatureSetting(typing_extensions.Protocol):
    '''Additional configuration of the feature.

    :see: `FeatureConfigurations AdditionalConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-additionalconfiguration>`_
    '''

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> builtins.bool:
        '''Status of the additional configuration of a feature.

        :see: `FeatureAdditionalConfiguration Status <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureadditionalconfiguration.html#cfn-guardduty-detector-featureadditionalconfiguration-status>`_
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''Name of the additional configuration of a feature.

        :see: `FeatureAdditionalConfiguration Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureadditionalconfiguration.html#cfn-guardduty-detector-featureadditionalconfiguration-name>`_
        '''
        ...


class _IFeatureSettingProxy:
    '''Additional configuration of the feature.

    :see: `FeatureConfigurations AdditionalConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-additionalconfiguration>`_
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.guardduty.IFeatureSetting"

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> builtins.bool:
        '''Status of the additional configuration of a feature.

        :see: `FeatureAdditionalConfiguration Status <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureadditionalconfiguration.html#cfn-guardduty-detector-featureadditionalconfiguration-status>`_
        '''
        return typing.cast(builtins.bool, jsii.get(self, "enabled"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''Name of the additional configuration of a feature.

        :see: `FeatureAdditionalConfiguration Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureadditionalconfiguration.html#cfn-guardduty-detector-featureadditionalconfiguration-name>`_
        '''
        return typing.cast(builtins.str, jsii.get(self, "name"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IFeatureSetting).__jsii_proxy_class__ = lambda : _IFeatureSettingProxy


@jsii.data_type(
    jsii_type="cdk-extensions.guardduty.KubernetesOptions",
    jsii_struct_bases=[],
    name_mapping={"audit_logs": "auditLogs"},
)
class KubernetesOptions:
    def __init__(self, *, audit_logs: typing.Optional[builtins.bool] = None) -> None:
        '''Options for configuring Kubernetes as a data source for GuardDuty.

        :param audit_logs: Controls whether EKS audit logs should be used as a data source for GuardDuty.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__680e727d389fdee6b624ddb1c0c5a17c19cbac56865a05dec0d81f3a97844244)
            check_type(argname="argument audit_logs", value=audit_logs, expected_type=type_hints["audit_logs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if audit_logs is not None:
            self._values["audit_logs"] = audit_logs

    @builtins.property
    def audit_logs(self) -> typing.Optional[builtins.bool]:
        '''Controls whether EKS audit logs should be used as a data source for GuardDuty.'''
        result = self._values.get("audit_logs")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KubernetesOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.guardduty.MalwareProtectionOptions",
    jsii_struct_bases=[],
    name_mapping={"ebs_volumes": "ebsVolumes"},
)
class MalwareProtectionOptions:
    def __init__(self, *, ebs_volumes: typing.Optional[builtins.bool] = None) -> None:
        '''Options for configuring data sources for GuardDuty malware protection.

        :param ebs_volumes: Controls whether EBS volumes should be scanned for malware by GuardDuty.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e0c45b096e7933f8ca3bdb9c31ebf95b517325dd7201cbede229b094c6788bb)
            check_type(argname="argument ebs_volumes", value=ebs_volumes, expected_type=type_hints["ebs_volumes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ebs_volumes is not None:
            self._values["ebs_volumes"] = ebs_volumes

    @builtins.property
    def ebs_volumes(self) -> typing.Optional[builtins.bool]:
        '''Controls whether EBS volumes should be scanned for malware by GuardDuty.'''
        result = self._values.get("ebs_volumes")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MalwareProtectionOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.guardduty.S3LogsOptions",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class S3LogsOptions:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''Options for configuring whether S3 data events should be used as a data source for GuardDuty.

        :param enabled: Controls whether S3 data events are enabled as a data source for GuardDuty.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8df326d4c4f43716dd47fafee0be3cc14f6f6600b7a9303bc2fd0d780d39e4a)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Controls whether S3 data events are enabled as a data source for GuardDuty.'''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3LogsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDetector)
class Detector(
    _aws_cdk_ceddda9d.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.guardduty.Detector",
):
    '''Represents a GuardDuty detector.

    A detector is an object that represents the GuardDuty service. A detector is
    required for GuardDuty to become operational.

    :see: `AWS::GuardDuty::Detector <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html>`_
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[builtins.bool] = None,
        features: typing.Optional[typing.Sequence[IFeature]] = None,
        publishing_frequency: typing.Optional[FindingPublishingFrequency] = None,
    ) -> None:
        '''Creates a new instance of the Detector resource.

        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param enabled: Specifies whether the detector is to be enabled on creation.
        :param features: Collection of additional features to be configured on the detector.
        :param publishing_frequency: Specifies how frequently updated findings are exported.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5496d8413dfcb8e78a9916d9da515c687d6db8abf04534ca4ef231799e9dde44)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DetectorProps(
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
            enabled=enabled,
            features=features,
            publishing_frequency=publishing_frequency,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromDetectorArn")
    @builtins.classmethod
    def from_detector_arn(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        detector_arn: builtins.str,
    ) -> IDetector:
        '''Imports an existing GuardDuty detector by specifying its Amazon Resource Name (ARN).

        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param detector_arn: The ARN of the existing GuardDuty detector to be imported.

        :return: An object representing the imported GuardDuty detector.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2b3c827ef2ef21f432576fa0601c24d3be06ea7aa97babcc69e26587e8be430)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument detector_arn", value=detector_arn, expected_type=type_hints["detector_arn"])
        return typing.cast(IDetector, jsii.sinvoke(cls, "fromDetectorArn", [scope, id, detector_arn]))

    @jsii.member(jsii_name="fromDetectorAttributes")
    @builtins.classmethod
    def from_detector_attributes(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        detector_arn: typing.Optional[builtins.str] = None,
        detector_id: typing.Optional[builtins.str] = None,
    ) -> IDetector:
        '''Imports an existing GuardDuty detector by explicitly specifying its attributes.

        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param detector_arn: The Amazon Resource Name (ARN) of the GuardDuty detector.
        :param detector_id: The ID generated by AWS for the GuardDuty detector.

        :return: An object representing the imported GuardDuty detector.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__264d091826933079abf0bc33e2556d3b0f5536b7b61b21b9fa9adcc48170490c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        attrs = DetectorAttributes(detector_arn=detector_arn, detector_id=detector_id)

        return typing.cast(IDetector, jsii.sinvoke(cls, "fromDetectorAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="fromDetectorId")
    @builtins.classmethod
    def from_detector_id(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        detector_id: builtins.str,
    ) -> IDetector:
        '''Imports an existing GuardDuty detector by specifiying its AWS generated ID.

        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param detector_id: The AWS generated ID of an existing GuardDuty detector to be imported.

        :return: An object representing the imported GuardDuty detector.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0316d76163173f8534be4b2eea3fc7da8b9f4478b1ce84cfe63ef1ab1f8a8c6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument detector_id", value=detector_id, expected_type=type_hints["detector_id"])
        return typing.cast(IDetector, jsii.sinvoke(cls, "fromDetectorId", [scope, id, detector_id]))

    @jsii.member(jsii_name="addFeature")
    def add_feature(self, feature: IFeature) -> "Detector":
        '''Configures a feature to be enabled on the detector.

        :param feature: The feature to be configured.

        :return: The detector on which the feature was configured.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5923192c4aa535c7930d93b2c26851bf211c8d9ba48b63cb9f4198d532a6ef3)
            check_type(argname="argument feature", value=feature, expected_type=type_hints["feature"])
        return typing.cast("Detector", jsii.invoke(self, "addFeature", [feature]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ARN_FORMAT")
    def ARN_FORMAT(cls) -> _aws_cdk_ceddda9d.ArnFormat:
        '''The format this resource uses for it's Amazon Resource Name (ARN).'''
        return typing.cast(_aws_cdk_ceddda9d.ArnFormat, jsii.sget(cls, "ARN_FORMAT"))

    @builtins.property
    @jsii.member(jsii_name="detectorArn")
    def detector_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the GuardDuty detector.'''
        return typing.cast(builtins.str, jsii.get(self, "detectorArn"))

    @builtins.property
    @jsii.member(jsii_name="detectorId")
    def detector_id(self) -> builtins.str:
        '''The ID generated by AWS for the GuardDuty detector.'''
        return typing.cast(builtins.str, jsii.get(self, "detectorId"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> builtins.bool:
        '''Specifies whether the detector is to be enabled on creation.

        :see: `Detector Enable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-enable>`_
        :group: Inputs
        '''
        return typing.cast(builtins.bool, jsii.get(self, "enabled"))

    @builtins.property
    @jsii.member(jsii_name="features")
    def features(self) -> typing.List[IFeature]:
        '''Collection of additional features to be configured on the detector.

        :see: `Detector Features <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-features>`_
        :group: Inputs
        '''
        return typing.cast(typing.List[IFeature], jsii.get(self, "features"))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> _aws_cdk_aws_guardduty_ceddda9d.CfnDetector:
        '''The underlying Detector CloudFormation resource.

        :see: `AWS::GuardDuty::Detector <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html>`_
        :group: Resources
        '''
        return typing.cast(_aws_cdk_aws_guardduty_ceddda9d.CfnDetector, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="publishingFrequency")
    def publishing_frequency(self) -> typing.Optional[FindingPublishingFrequency]:
        '''Specifies how frequently updated findings are exported.

        :see: `Detector FindingPublishingFrequency <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guardduty-detector.html#cfn-guardduty-detector-findingpublishingfrequency>`_
        :group: Inputs
        '''
        return typing.cast(typing.Optional[FindingPublishingFrequency], jsii.get(self, "publishingFrequency"))


@jsii.data_type(
    jsii_type="cdk-extensions.guardduty.EksRuntimeMonitoringOptions",
    jsii_struct_bases=[FeatureOptions],
    name_mapping={"enabled": "enabled", "addon_management": "addonManagement"},
)
class EksRuntimeMonitoringOptions(FeatureOptions):
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        addon_management: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Configuration for the EKS runtime monitoring GuardDuty detector feature.

        :param enabled: Whether the feature should be enabled or not.
        :param addon_management: Determines whether GuardDuty is allowed to manage addons for the EKS cluster. If both runtime monitoring and addon management are enabled GuardDuty can automatically manage the GuardDuty security agent addon that is used to send findings to GuardDuty. If runtime monitoring is enabled and addon management is disabled you must manage the GuardDuty security agent manually.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1402c4956e544ac52f113d5f5a2bde14bd842c288263e7e469b18619cbced6f)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument addon_management", value=addon_management, expected_type=type_hints["addon_management"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if addon_management is not None:
            self._values["addon_management"] = addon_management

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether the feature should be enabled or not.

        :see: `FeatureConfigurations Status <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-guardduty-detector-featureconfigurations.html#cfn-guardduty-detector-featureconfigurations-status>`_
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def addon_management(self) -> typing.Optional[builtins.bool]:
        '''Determines whether GuardDuty is allowed to manage addons for the EKS cluster.

        If both runtime monitoring and addon management are enabled GuardDuty can
        automatically manage the GuardDuty security agent addon that is used to
        send findings to GuardDuty.

        If runtime monitoring is enabled and addon management is disabled you must
        manage the GuardDuty security agent manually.

        :see: `Configuring EKS Runtime Monitoring <https://docs.aws.amazon.com/guardduty/latest/ug/eks-protection-configuration.html>`_
        '''
        result = self._values.get("addon_management")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EksRuntimeMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "DataSource",
    "Detector",
    "DetectorAttributes",
    "DetectorOptions",
    "DetectorProps",
    "EksRuntimeMonitoringOptions",
    "Feature",
    "FeatureOptions",
    "FindingPublishingFrequency",
    "IDataSource",
    "IDetector",
    "IFeature",
    "IFeatureSetting",
    "KubernetesOptions",
    "MalwareProtectionOptions",
    "S3LogsOptions",
]

publication.publish()

def _typecheckingstub__d12ae76291e803174ca171a5fc85d1b4c28b339c057ed8f75568af3b4a877628(
    *,
    detector_arn: typing.Optional[builtins.str] = None,
    detector_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__498753c70e96c48c0ddf3b2dd9194cd2bc718f18ffdd31e00f0e644499841785(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    features: typing.Optional[typing.Sequence[IFeature]] = None,
    publishing_frequency: typing.Optional[FindingPublishingFrequency] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77a2139096812048b85f21b0d063223ce253705d2e41b86445168a137b2da4dd(
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[builtins.bool] = None,
    features: typing.Optional[typing.Sequence[IFeature]] = None,
    publishing_frequency: typing.Optional[FindingPublishingFrequency] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d38a280758dab4c4d500d0d1689d9a5a8ca1419f0941b880a0d3b5fd241b94a(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab6fbf3bd9c88a73ebdfee03daba1747e8add1127ca6fc87c159ba18832d4a39(
    label: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__835fce999fafcdc1ab328335bd2e7cc27d3d02658196cfa5e5782bf4f8e48230(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__680e727d389fdee6b624ddb1c0c5a17c19cbac56865a05dec0d81f3a97844244(
    *,
    audit_logs: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e0c45b096e7933f8ca3bdb9c31ebf95b517325dd7201cbede229b094c6788bb(
    *,
    ebs_volumes: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8df326d4c4f43716dd47fafee0be3cc14f6f6600b7a9303bc2fd0d780d39e4a(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5496d8413dfcb8e78a9916d9da515c687d6db8abf04534ca4ef231799e9dde44(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[builtins.bool] = None,
    features: typing.Optional[typing.Sequence[IFeature]] = None,
    publishing_frequency: typing.Optional[FindingPublishingFrequency] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2b3c827ef2ef21f432576fa0601c24d3be06ea7aa97babcc69e26587e8be430(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    detector_arn: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__264d091826933079abf0bc33e2556d3b0f5536b7b61b21b9fa9adcc48170490c(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    detector_arn: typing.Optional[builtins.str] = None,
    detector_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0316d76163173f8534be4b2eea3fc7da8b9f4478b1ce84cfe63ef1ab1f8a8c6(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    detector_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5923192c4aa535c7930d93b2c26851bf211c8d9ba48b63cb9f4198d532a6ef3(
    feature: IFeature,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1402c4956e544ac52f113d5f5a2bde14bd842c288263e7e469b18619cbced6f(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    addon_management: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass
