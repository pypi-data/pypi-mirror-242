import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_aps as _aws_cdk_aws_aps_ceddda9d
import aws_cdk.aws_logs as _aws_cdk_aws_logs_ceddda9d
import aws_cdk.aws_sns as _aws_cdk_aws_sns_ceddda9d
import constructs as _constructs_77d1e7e8


@jsii.data_type(
    jsii_type="cdk-extensions.aps.AlertManagerConfigurationDetails",
    jsii_struct_bases=[],
    name_mapping={"contents": "contents"},
)
class AlertManagerConfigurationDetails:
    def __init__(self, *, contents: builtins.str) -> None:
        '''The details that are needed to configure alert manager for an Amazon APS workspace.

        :param contents: The rendered alert manager configuration in the format expected by an Amazon APS workspace.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cbff91d83be6bd8b06b602b6b9e93e20d216e589768f575ab6d1f2c6010e644)
            check_type(argname="argument contents", value=contents, expected_type=type_hints["contents"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "contents": contents,
        }

    @builtins.property
    def contents(self) -> builtins.str:
        '''The rendered alert manager configuration in the format expected by an Amazon APS workspace.'''
        result = self._values.get("contents")
        assert result is not None, "Required property 'contents' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlertManagerConfigurationDetails(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.AlertManagerConfigurationProps",
    jsii_struct_bases=[],
    name_mapping={
        "default_receiver_destinations": "defaultReceiverDestinations",
        "default_route": "defaultRoute",
        "templates": "templates",
    },
)
class AlertManagerConfigurationProps:
    def __init__(
        self,
        *,
        default_receiver_destinations: typing.Optional[typing.Sequence["IAlertManagerDestination"]] = None,
        default_route: typing.Optional[typing.Union["DefaultRouteOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        templates: typing.Optional[typing.Sequence["AlertManagerTemplate"]] = None,
    ) -> None:
        '''Configuration for alert manager running on Amazon APS.

        :param default_receiver_destinations: Destinations where all alerts generated by APS should be sent. If this property is not a provided, a new default topic will be created to receive notifications. If a default topic is not desired (such as in cases where topics will be registered dynamically later in the build) an empty list can be provided. This will result in the default topic not being created an no destinations being configured for the default receiver. Note that the default receiver requires at least one destination to be registered, so if the default topic is skipped and no destinations are provided here, at least one destination *must* be registered for the default route before the CDK app is synthed.
        :param default_route: Options for configuring the behavior of the default route that gets created for alerts. The default route for alert manager does not support all options allowed by child routes.
        :param templates: Collection of templates to make available to alert manager. The templates are available to be referenced in any field that supports templating by using the ``template`` templating function and referencing the name of the template as defined in the template content with the ``define`` keyword.
        '''
        if isinstance(default_route, dict):
            default_route = DefaultRouteOptions(**default_route)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d4829074894e21837337df54d36c60c82b7d149f7979af531bf4d29dd236d80)
            check_type(argname="argument default_receiver_destinations", value=default_receiver_destinations, expected_type=type_hints["default_receiver_destinations"])
            check_type(argname="argument default_route", value=default_route, expected_type=type_hints["default_route"])
            check_type(argname="argument templates", value=templates, expected_type=type_hints["templates"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if default_receiver_destinations is not None:
            self._values["default_receiver_destinations"] = default_receiver_destinations
        if default_route is not None:
            self._values["default_route"] = default_route
        if templates is not None:
            self._values["templates"] = templates

    @builtins.property
    def default_receiver_destinations(
        self,
    ) -> typing.Optional[typing.List["IAlertManagerDestination"]]:
        '''Destinations where all alerts generated by APS should be sent.

        If this property is not a provided, a new default topic will be created to
        receive notifications. If a default topic is not desired (such as in cases
        where topics will be registered dynamically later in the build) an empty
        list can be provided. This will result in the default topic not being
        created an no destinations being configured for the default receiver.

        Note that the default receiver requires at least one destination to be
        registered, so if the default topic is skipped and no destinations are
        provided here, at least one destination *must* be registered for the
        default route before the CDK app is synthed.
        '''
        result = self._values.get("default_receiver_destinations")
        return typing.cast(typing.Optional[typing.List["IAlertManagerDestination"]], result)

    @builtins.property
    def default_route(self) -> typing.Optional["DefaultRouteOptions"]:
        '''Options for configuring the behavior of the default route that gets created for alerts.

        The default route for alert manager does not support all options allowed
        by child routes.
        '''
        result = self._values.get("default_route")
        return typing.cast(typing.Optional["DefaultRouteOptions"], result)

    @builtins.property
    def templates(self) -> typing.Optional[typing.List["AlertManagerTemplate"]]:
        '''Collection of templates to make available to alert manager.

        The templates
        are available to be referenced in any field that supports templating by
        using the ``template`` templating function and referencing the name of the
        template as defined in the template content with the ``define`` keyword.

        :see: `Reference defined templates <https://pkg.go.dev/text/template#hdr-Nested_template_definitions>`_
        '''
        result = self._values.get("templates")
        return typing.cast(typing.Optional[typing.List["AlertManagerTemplate"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlertManagerConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AlertManagerDestination(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerDestination",
):
    '''Provides an interface for creating various alert manager destination objects that can receive notifications when an alert happens in Prometheus.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="snsTopic")
    @builtins.classmethod
    def sns_topic(
        cls,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        *,
        api_url: typing.Optional[builtins.str] = None,
        attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        message: typing.Optional[builtins.str] = None,
        send_resolved: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
    ) -> "AlertManagerSnsDestination":
        '''Creates an alert manager destination that sends alert notifications to an Amazon SNS topic.

        :param topic: The SNS topic where alert notifications should be sent.
        :param api_url: The SNS API URL i.e. https://sns.us-east-2.amazonaws.com. If not specified, the SNS API URL from the SNS SDK will be used.
        :param attributes: SNS message attributes.
        :param message: The message content of the SNS notification.
        :param send_resolved: Controls whether to notify about resolved alerts.
        :param subject: Subject line when the message is delivered to email endpoints.

        :return: An alert manager destination that represents the SNS topic.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee96d31190b82fed53dd257897e453fb250f2e84f2cafdfc5897004bf1ed947d)
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        options = AlertManagerSnsDestinationOptions(
            api_url=api_url,
            attributes=attributes,
            message=message,
            send_resolved=send_resolved,
            subject=subject,
        )

        return typing.cast("AlertManagerSnsDestination", jsii.sinvoke(cls, "snsTopic", [topic, options]))


class AlertManagerDestinationCategory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerDestinationCategory",
):
    '''Specifies the type of destination where alert manager can send notifications.

    Corresponds with a config block inside an alert manager receiver
    configuration.
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, name: builtins.str) -> "AlertManagerDestinationCategory":
        '''An escape hatch method that allows specifying arbitrary values for the type a receiver field a destination should be placed under.

        In the event that new destination types are added by alert manager, this
        can be used to implement custom destinations in the event that it hasn't
        had the chance to be implemented here.

        Whenever possible, it is recommended the static values provided be used.

        :param name: The name of the key in a receiver config where the destination being configured should be placed.

        :return:

        An object that can be used when building a receiver that
        specifies the given destination.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81f98103b29146e8fbc8bfe41a2d240e3fe48039bafda52ef4e8f26431684515)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        return typing.cast("AlertManagerDestinationCategory", jsii.sinvoke(cls, "of", [name]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EMAIL")
    def EMAIL(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications via email.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "EMAIL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="OPSGENIE")
    def OPSGENIE(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications using Opsgenie.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "OPSGENIE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PAGERDUTY")
    def PAGERDUTY(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications using PagerDuty.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "PAGERDUTY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PUSHOVER")
    def PUSHOVER(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications using Pushover.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "PUSHOVER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SLACK")
    def SLACK(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications via Slack.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "SLACK"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SNS")
    def SNS(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications using Amazon SNS.'''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "SNS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TELEGRAM")
    def TELEGRAM(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications via Telegram.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "TELEGRAM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VICTOROPS")
    def VICTOROPS(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications using VictorOps.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "VICTOROPS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WEBEX")
    def WEBEX(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications using Webex.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "WEBEX"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WEBHOOK")
    def WEBHOOK(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications via a webhook.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "WEBHOOK"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WECHAT")
    def WECHAT(cls) -> "AlertManagerDestinationCategory":
        '''Sends notifications via WeChat.

        Not currently supported by APS.
        '''
        return typing.cast("AlertManagerDestinationCategory", jsii.sget(cls, "WECHAT"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the category, as it would appear as a key in the configuration for an alert manager receiver.'''
        return typing.cast(builtins.str, jsii.get(self, "name"))


class AlertManagerInhibitRule(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerInhibitRule",
):
    '''An inhibition rule mutes an alert (target) matching a set of matchers when an alert (source) exists that matches another set of matchers.

    Both target
    and source alerts can optionally be required to have the same label values
    for a specified list of label names.

    Semantically, a missing label and a label with an empty value are the same
    thing. Therefore, if all the label names given for ``equalLabels`` are missing
    from both the source and target alerts, the inhibition rule will apply.

    To prevent an alert from inhibiting itself, an alert that matches both the
    target and the source side of a rule cannot be inhibited by alerts for which
    the same is true (including itself). However, we recommend to choose target
    and source matchers in a way that alerts never match both sides. It is much
    easier to reason about and does not trigger this special case.

    :see: `Inhibit Rule Official Documentation <https://prometheus.io/docs/alerting/latest/configuration/#inhibit_rule>`_
    '''

    def __init__(
        self,
        scope: "AlertManagerConfiguration",
        id: builtins.str,
        options: "AlertManagerInhibitRuleProps",
    ) -> None:
        '''Creates a new instance of the AlertManagerInhibitRule class.

        :param scope: A CDK Construct that will serve as this construct's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param options: Arguments related to the configuration of this construct.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e6a19d0395d678236b02437254ceb002b2e26657c7db7413be6a3ac113a2dda)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
        jsii.create(self.__class__, self, [scope, id, options])

    @jsii.member(jsii_name="addEqualLabel")
    def add_equal_label(self, label: builtins.str) -> "AlertManagerInhibitRule":
        '''Adds a label that must be equal for both matched source and target alerts in order for the inhibition to take effect.

        :param label: The label to add.

        :return: The inhibit rule to which the label was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9fa628986dd21444584b00b1da57d1af20bde0830146d4a141f8a04d44b24f00)
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
        return typing.cast("AlertManagerInhibitRule", jsii.invoke(self, "addEqualLabel", [label]))

    @jsii.member(jsii_name="addSourceMatcher")
    def add_source_matcher(
        self,
        matcher: "AlertManagerMatcher",
    ) -> "AlertManagerInhibitRule":
        '''Adds a matcher for which one or more alerts have to exist in order for inhibition to take effect.

        :param matcher: The source matcher to add.

        :return: The inhibit rule to which the matcher was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95de43fa15c0e1d2874d1faf6b8e7b45c8988fce0743890838c588cc983cffa4)
            check_type(argname="argument matcher", value=matcher, expected_type=type_hints["matcher"])
        return typing.cast("AlertManagerInhibitRule", jsii.invoke(self, "addSourceMatcher", [matcher]))

    @jsii.member(jsii_name="addTargetMatcher")
    def add_target_matcher(
        self,
        matcher: "AlertManagerMatcher",
    ) -> "AlertManagerInhibitRule":
        '''Adds a matcher that has to be fulfilled by a target alert in order to be muted.

        :param matcher: The target matcher to add.

        :return: The inhibit rule to which the matcher was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66050a8008925fdd455146632a5f6e306152f2a1a2f37c1c9599e82abe003c54)
            check_type(argname="argument matcher", value=matcher, expected_type=type_hints["matcher"])
        return typing.cast("AlertManagerInhibitRule", jsii.invoke(self, "addTargetMatcher", [matcher]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        _scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the inhibit rule with a construct that is handling the configuration of alert manager.

        :param _scope: The construct handling the configuration of alert manager that will consume the rendered configuration.

        :return: An alert manager _inhibit_rule` object.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b698f0b2614fc551fd45880c9b42618b6ee68f08904e7e171536c028a659778)
            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [_scope]))

    @builtins.property
    @jsii.member(jsii_name="equalLabels")
    def equal_labels(self) -> typing.List[builtins.str]:
        '''Collection of labels that must be equal for both matched source and target alerts in order for the inhibition to take effect.'''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "equalLabels"))

    @builtins.property
    @jsii.member(jsii_name="sourceMatchers")
    def source_matchers(self) -> typing.List["AlertManagerMatcher"]:
        '''Collection of matchers for which one or more alerts have to exist for the inhibition to take effect.'''
        return typing.cast(typing.List["AlertManagerMatcher"], jsii.get(self, "sourceMatchers"))

    @builtins.property
    @jsii.member(jsii_name="targetMatchers")
    def target_matchers(self) -> typing.List["AlertManagerMatcher"]:
        '''Collection of matchers that have to be fulfilled by the target alerts to be muted.'''
        return typing.cast(typing.List["AlertManagerMatcher"], jsii.get(self, "targetMatchers"))


class AlertManagerInhibitRuleProps(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerInhibitRuleProps",
):
    '''Configuration options for the alert manager inhibit rule.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="equalLabels")
    def equal_labels(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Labels that must have an equal value in the source and target alert for the inhibition to take effect.'''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "equalLabels"))

    @builtins.property
    @jsii.member(jsii_name="sourceMatchers")
    def source_matchers(self) -> typing.Optional[typing.List["AlertManagerMatcher"]]:
        '''A list of matchers for which one or more alerts have to exist for the inhibition to take effect.'''
        return typing.cast(typing.Optional[typing.List["AlertManagerMatcher"]], jsii.get(self, "sourceMatchers"))

    @builtins.property
    @jsii.member(jsii_name="targetMatchers")
    def target_matchers(self) -> typing.Optional[typing.List["AlertManagerMatcher"]]:
        '''A list of matchers that have to be fulfilled by the target alerts to be muted.'''
        return typing.cast(typing.Optional[typing.List["AlertManagerMatcher"]], jsii.get(self, "targetMatchers"))


class AlertManagerMatcher(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerMatcher",
):
    '''An expression that alert manager can use to evaluate incoming alerts to determine the actions it should take.'''

    @jsii.member(jsii_name="fromComponents")
    @builtins.classmethod
    def from_components(
        cls,
        label: builtins.str,
        operator: "MatchOperator",
        value: builtins.str,
    ) -> "AlertManagerMatcher":
        '''Builds a simple matcher using the standard components supported by the matcher expression syntax.

        Handles formatting an escaping of values.

        :param label: The Prometheus label name to match against.
        :param operator: The logical operator to use when evaluating the matcher.
        :param value: The value being compared against the specified label using the specified operator.

        :return: A matcher object representing the given operation.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1958e2d2776995b0606099b11a0abfc6067a6c584e3703f06ff95d07db8c4342)
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("AlertManagerMatcher", jsii.sinvoke(cls, "fromComponents", [label, operator, value]))

    @jsii.member(jsii_name="fromCompound")
    @builtins.classmethod
    def from_compound(cls, *matchers: "AlertManagerMatcher") -> "AlertManagerMatcher":
        '''Creates a compund matcher expression by joining one or more other matcher objects.

        :param matchers: The matcher objects to join into a compound expression.

        :return: A compound matcher representing the joined expressions.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbc0f07bb1b51d6e9d9e9fbef0b54e68767eef01649efa7b464285c5c66e4a8f)
            check_type(argname="argument matchers", value=matchers, expected_type=typing.Tuple[type_hints["matchers"], ...]) # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast("AlertManagerMatcher", jsii.sinvoke(cls, "fromCompound", [*matchers]))

    @jsii.member(jsii_name="fromString")
    @builtins.classmethod
    def from_string(cls, expression: builtins.str) -> "AlertManagerMatcher":
        '''Creates a matcher from a raw string expression.

        This allows for specifying
        arbitrary matching conditions that may be too complex to be supported by
        the other means of constructing matchers.

        :param expression: The PromQL-like expression to use for matching.

        :return: A matcher object representing the given expression.

        :see: `Matcher expression syntax <https://prometheus.io/docs/alerting/latest/configuration/#matcher>`_
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7727457f8e9cd1d54293839f5d3bb63124837ef55148e5a1f0df9bc459f7cfca)
            check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
        return typing.cast("AlertManagerMatcher", jsii.sinvoke(cls, "fromString", [expression]))

    @builtins.property
    @jsii.member(jsii_name="expression")
    def expression(self) -> builtins.str:
        '''The PromQL like expression to use for the matcher.'''
        return typing.cast(builtins.str, jsii.get(self, "expression"))


class AlertManagerReceiver(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerReceiver",
):
    '''Represents a notification integration within alert manager.

    :see: `Receiver configuration <https://prometheus.io/docs/alerting/latest/configuration/#receiver>`_
    '''

    def __init__(
        self,
        scope: "AlertManagerConfiguration",
        id: builtins.str,
        *,
        destinations: typing.Optional[typing.Sequence["IAlertManagerDestination"]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the AlertManagerReceiver class.

        :param scope: A CDK Construct that will serve as this construct's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param destinations: Details for alerting providers where events routed to this receiver should be sent,.
        :param name: The name of the receiver which can be referenced in the other parts of the configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a51f37103bd47e48b625a8b9832a7d757e752c9649159fb1c46f40eea9fcb512)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AlertManagerReceiverProps(destinations=destinations, name=name)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addDestination")
    def add_destination(
        self,
        destination: "IAlertManagerDestination",
    ) -> "AlertManagerReceiver":
        '''Adds a new generic destination that should receive alerts that have been routed to this receiver.

        :param destination: The destination where alerts routed to this receiver should be sent.

        :return: The receiver where the destination was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3782218a5cd53e73019a7d7c2c9623d18ec1cee9857c8117464f68b7aafc6fd0)
            check_type(argname="argument destination", value=destination, expected_type=type_hints["destination"])
        return typing.cast("AlertManagerReceiver", jsii.invoke(self, "addDestination", [destination]))

    @jsii.member(jsii_name="addSnsTopic")
    def add_sns_topic(
        self,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        *,
        api_url: typing.Optional[builtins.str] = None,
        attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        message: typing.Optional[builtins.str] = None,
        send_resolved: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
    ) -> "AlertManagerSnsDestination":
        '''Adds a new SNS destination that should receive alerts that have been routed to this receiver.

        :param topic: The SNS topic where alerts should be sent.
        :param api_url: The SNS API URL i.e. https://sns.us-east-2.amazonaws.com. If not specified, the SNS API URL from the SNS SDK will be used.
        :param attributes: SNS message attributes.
        :param message: The message content of the SNS notification.
        :param send_resolved: Controls whether to notify about resolved alerts.
        :param subject: Subject line when the message is delivered to email endpoints.

        :return: The SnsDestination object that was added to the receiver.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0dfd5069145da589cc6cbc767044c6239179378d80b7fd92753881b1f11df735)
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        options = AlertManagerSnsDestinationOptions(
            api_url=api_url,
            attributes=attributes,
            message=message,
            send_resolved=send_resolved,
            subject=subject,
        )

        return typing.cast("AlertManagerSnsDestination", jsii.invoke(self, "addSnsTopic", [topic, options]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the receiver with a construct that is handling the configuration of alert manager that will consume the configuration.

        :param scope: The construct handling the configuration of alert manager that will consume the rendered configuration.

        :return: An alert manager ``receiver`` configuration object.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ac98a441ebaa8fcbdcb9c5469de856e47556f94c4e73f48263c58939dad50ba)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [scope]))

    @builtins.property
    @jsii.member(jsii_name="destinations")
    def destinations(self) -> typing.List["IAlertManagerDestination"]:
        '''Collection of destinations which define details for alerting providers where events routed to this receiver should be sent.

        :group: Inputs
        '''
        return typing.cast(typing.List["IAlertManagerDestination"], jsii.get(self, "destinations"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the receiver which can be referenced in the other parts of the configuration.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "name"))


@jsii.data_type(
    jsii_type="cdk-extensions.aps.AlertManagerReceiverProps",
    jsii_struct_bases=[],
    name_mapping={"destinations": "destinations", "name": "name"},
)
class AlertManagerReceiverProps:
    def __init__(
        self,
        *,
        destinations: typing.Optional[typing.Sequence["IAlertManagerDestination"]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the aler manager route.

        :param destinations: Details for alerting providers where events routed to this receiver should be sent,.
        :param name: The name of the receiver which can be referenced in the other parts of the configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f6e4a9ecae47172c07ffd7184db033eb8db2591b447286a1b2d2ae860e4d679)
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if destinations is not None:
            self._values["destinations"] = destinations
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def destinations(self) -> typing.Optional[typing.List["IAlertManagerDestination"]]:
        '''Details for alerting providers where events routed to this receiver should be sent,.'''
        result = self._values.get("destinations")
        return typing.cast(typing.Optional[typing.List["IAlertManagerDestination"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the receiver which can be referenced in the other parts of the configuration.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlertManagerReceiverProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AlertManagerRoute(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerRoute",
):
    '''Defines a node in a routing tree and its children.

    Its optional
    configuration parameters are inherited from its parent node if not set.

    Every alert enters the routing tree at the configured top-level route, which
    must match all alerts (i.e. not have any configured matchers). It then
    traverses the child nodes. If ``continueMatching`` is set to ``false``, it stops
    after the first matching child. If ``continueMatching`` is ``true`` on a
    matching node, the alert will continue matching against subsequent siblings.
    If an alert does not match any children of a node (no matching child nodes,
    or none exist), the alert is handled based on the configuration parameters
    of the current node.

    :see: `Route Official Documentation <https://prometheus.io/docs/alerting/latest/configuration/#route>`_
    '''

    def __init__(
        self,
        scope: typing.Union["AlertManagerConfiguration", "AlertManagerRoute"],
        id: builtins.str,
        *,
        receiver: AlertManagerReceiver,
        active_time_intervals: typing.Optional[typing.Sequence["TimeInterval"]] = None,
        children: typing.Optional[typing.Sequence[typing.Union["AlertManagerRouteProps", typing.Dict[builtins.str, typing.Any]]]] = None,
        continue_matching: typing.Optional[builtins.bool] = None,
        group_by_labels: typing.Optional[typing.Sequence[builtins.str]] = None,
        group_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        group_wait: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        matchers: typing.Optional[typing.Sequence[AlertManagerMatcher]] = None,
        mute_time_interval: typing.Optional[typing.Sequence["TimeInterval"]] = None,
        repeat_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''Creates a new instance of the AlertManagerRoute class.

        :param scope: A CDK Construct that will serve as this construct's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param receiver: The receiver that should be the target of alerts that are generated by the node.
        :param active_time_intervals: Times when the route should be active. An empty value means that the route is always active. Additionally, the root node cannot have any active times. The route will send notifications only when active, but otherwise acts normally (including ending the route-matching process if the ``continueMatching`` option is not set).
        :param children: Optional child routes to add to the node.
        :param continue_matching: Whether an alert should continue matching subsequent sibling nodes.
        :param group_by_labels: The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group.
        :param group_interval: How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent (usually ~5m or more).
        :param group_wait: How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group (usually ~0s to few minutes).
        :param matchers: A list of matchers that an alert has to fulfill to match the node.
        :param mute_time_interval: Times when the route should be muted. The root node cannot have any mute times. When a route is muted it will not send any notifications, but otherwise acts normally (including ending the route-matching process if the ``continueMatching`` option is not set).
        :param repeat_interval: How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba61bae0afa027a0ee6be18b7fe8f9ee634f7bbe876990d7245bc50aaa961fa4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = AlertManagerRouteProps(
            receiver=receiver,
            active_time_intervals=active_time_intervals,
            children=children,
            continue_matching=continue_matching,
            group_by_labels=group_by_labels,
            group_interval=group_interval,
            group_wait=group_wait,
            matchers=matchers,
            mute_time_interval=mute_time_interval,
            repeat_interval=repeat_interval,
        )

        jsii.create(self.__class__, self, [scope, id, options])

    @jsii.member(jsii_name="addActiveTimeInterval")
    def add_active_time_interval(self, interval: "TimeInterval") -> "AlertManagerRoute":
        '''Adds a new time when the route should be active. The root node cannot have any active times.

        The route will send notifications only when active, but otherwise acts
        normally (including ending the route-matching process if the
        ``continueMatching`` option is not set).

        :param interval: The time interval when alerting on this route should be active.

        :return: The route where the interval was associated.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26acb384bb53e3e0077a8d6e74574177245a4c86f1a91f696ba900c664678fdc)
            check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
        return typing.cast("AlertManagerRoute", jsii.invoke(self, "addActiveTimeInterval", [interval]))

    @jsii.member(jsii_name="addChild")
    def add_child(
        self,
        id: builtins.str,
        *,
        receiver: AlertManagerReceiver,
        active_time_intervals: typing.Optional[typing.Sequence["TimeInterval"]] = None,
        children: typing.Optional[typing.Sequence[typing.Union["AlertManagerRouteProps", typing.Dict[builtins.str, typing.Any]]]] = None,
        continue_matching: typing.Optional[builtins.bool] = None,
        group_by_labels: typing.Optional[typing.Sequence[builtins.str]] = None,
        group_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        group_wait: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        matchers: typing.Optional[typing.Sequence[AlertManagerMatcher]] = None,
        mute_time_interval: typing.Optional[typing.Sequence["TimeInterval"]] = None,
        repeat_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> "AlertManagerRoute":
        '''Adds a new child route to this node.

        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param receiver: The receiver that should be the target of alerts that are generated by the node.
        :param active_time_intervals: Times when the route should be active. An empty value means that the route is always active. Additionally, the root node cannot have any active times. The route will send notifications only when active, but otherwise acts normally (including ending the route-matching process if the ``continueMatching`` option is not set).
        :param children: Optional child routes to add to the node.
        :param continue_matching: Whether an alert should continue matching subsequent sibling nodes.
        :param group_by_labels: The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group.
        :param group_interval: How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent (usually ~5m or more).
        :param group_wait: How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group (usually ~0s to few minutes).
        :param matchers: A list of matchers that an alert has to fulfill to match the node.
        :param mute_time_interval: Times when the route should be muted. The root node cannot have any mute times. When a route is muted it will not send any notifications, but otherwise acts normally (including ending the route-matching process if the ``continueMatching`` option is not set).
        :param repeat_interval: How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).

        :return: The child route that was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37e8e9ee32ee666ee145d9f806f323b6c80bfda7e4c6f3262a362bb1aa4e2e82)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = AlertManagerRouteProps(
            receiver=receiver,
            active_time_intervals=active_time_intervals,
            children=children,
            continue_matching=continue_matching,
            group_by_labels=group_by_labels,
            group_interval=group_interval,
            group_wait=group_wait,
            matchers=matchers,
            mute_time_interval=mute_time_interval,
            repeat_interval=repeat_interval,
        )

        return typing.cast("AlertManagerRoute", jsii.invoke(self, "addChild", [id, options]))

    @jsii.member(jsii_name="addGroupByLabel")
    def add_group_by_label(self, label: builtins.str) -> "AlertManagerRoute":
        '''Adds a label by which incoming alerts are grouped together.

        For example,
        multiple alerts coming in for cluster=A and alertname=LatencyHigh would be
        batched into a single group.

        :param label: The label by which incoming alerts should be grouped.

        :return: The route where the label was associated.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd53318d2eeb548d586de862995148738569b2a2767340a1ea6cd92bef3ab2aa)
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
        return typing.cast("AlertManagerRoute", jsii.invoke(self, "addGroupByLabel", [label]))

    @jsii.member(jsii_name="addMatcher")
    def add_matcher(self, matcher: AlertManagerMatcher) -> "AlertManagerRoute":
        '''Adds a matcher that an alert has to fulfill to match the node.

        :param matcher: The matcher to associate.

        :return: The route where the matcher was associated.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b9926de134f13ac4889ffef4a8f6e81285590988aa52a46eaaa0cc23fd4e250)
            check_type(argname="argument matcher", value=matcher, expected_type=type_hints["matcher"])
        return typing.cast("AlertManagerRoute", jsii.invoke(self, "addMatcher", [matcher]))

    @jsii.member(jsii_name="addMuteTimeInterval")
    def add_mute_time_interval(self, interval: "TimeInterval") -> "AlertManagerRoute":
        '''Adds a time when the route should be muted. The root node cannot have any mute times.

        When a route is muted it will not send any notifications, but otherwise
        acts normally (including ending the route-matching process if the
        ``continueMatching`` option is not set).

        :param interval: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1afb7cf94d5e98ee6abf4e8ffbc819c3b4fc46c07c67ba8f65a771b70732cd3)
            check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
        return typing.cast("AlertManagerRoute", jsii.invoke(self, "addMuteTimeInterval", [interval]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the route with a construct that is handling the configuration of alert manager that will consume the configuration.

        :param scope: The construct handling the configuration of alert manager that will consume the rendered configuration.

        :return: An alert manager ``route`` configuration object.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe6542bd8c1f749b66a1b2d8fcf33cce209481ac3117216efa1c416fb46c359d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [scope]))

    @builtins.property
    @jsii.member(jsii_name="activeTimeIntervals")
    def active_time_intervals(self) -> typing.List["TimeInterval"]:
        '''Times when the route should be active.

        An empty value means that the route
        is always active. Additionally, the root node cannot have any active
        times.

        The route will send notifications only when active, but otherwise acts
        normally (including ending the route-matching process if the
        ``continueMatching`` option is not set).

        :group: Inputs
        '''
        return typing.cast(typing.List["TimeInterval"], jsii.get(self, "activeTimeIntervals"))

    @builtins.property
    @jsii.member(jsii_name="children")
    def children(self) -> typing.List["AlertManagerRoute"]:
        '''Optional child routes to add to the node.

        :group: Inputs
        '''
        return typing.cast(typing.List["AlertManagerRoute"], jsii.get(self, "children"))

    @builtins.property
    @jsii.member(jsii_name="groupByLabels")
    def group_by_labels(self) -> typing.List[builtins.str]:
        '''The labels by which incoming alerts are grouped together.

        For example,
        multiple alerts coming in for cluster=A and alertname=LatencyHigh would be
        batched into a single group.

        :group: Inputs
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "groupByLabels"))

    @builtins.property
    @jsii.member(jsii_name="matchers")
    def matchers(self) -> typing.List[AlertManagerMatcher]:
        '''A list of matchers that an alert has to fulfill to match the node.

        :group: Inputs
        '''
        return typing.cast(typing.List[AlertManagerMatcher], jsii.get(self, "matchers"))

    @builtins.property
    @jsii.member(jsii_name="muteTimeIntervals")
    def mute_time_intervals(self) -> typing.List["TimeInterval"]:
        '''Times when the route should be muted. The root node cannot have any mute times.

        When a route is muted it will not send any notifications, but otherwise
        acts normally (including ending the route-matching process if the
        ``continueMatching`` option is not set).

        :group: Inputs
        '''
        return typing.cast(typing.List["TimeInterval"], jsii.get(self, "muteTimeIntervals"))

    @builtins.property
    @jsii.member(jsii_name="receiver")
    def receiver(self) -> AlertManagerReceiver:
        '''The receiver that should be the target of alerts that are generated by the node.

        :group: Inputs
        '''
        return typing.cast(AlertManagerReceiver, jsii.get(self, "receiver"))

    @builtins.property
    @jsii.member(jsii_name="continueMatching")
    def continue_matching(self) -> typing.Optional[builtins.bool]:
        '''Whether an alert should continue matching subsequent sibling nodes.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "continueMatching"))

    @builtins.property
    @jsii.member(jsii_name="groupInterval")
    def group_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent (usually ~5m or more).

        :group: Inputs
        '''
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "groupInterval"))

    @builtins.property
    @jsii.member(jsii_name="groupWait")
    def group_wait(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to initially wait to send a notification for a group of alerts.

        Allows to wait for an inhibiting alert to arrive or collect more initial
        alerts for the same group (usually ~0s to few minutes).

        :group: Inputs
        '''
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "groupWait"))

    @builtins.property
    @jsii.member(jsii_name="repeatInterval")
    def repeat_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to wait before sending a notification again if it has already been sent successfully for an alert.

        (Usually ~3h or more).

        :group: Inputs
        '''
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "repeatInterval"))


@jsii.data_type(
    jsii_type="cdk-extensions.aps.AlertManagerRouteProps",
    jsii_struct_bases=[],
    name_mapping={
        "receiver": "receiver",
        "active_time_intervals": "activeTimeIntervals",
        "children": "children",
        "continue_matching": "continueMatching",
        "group_by_labels": "groupByLabels",
        "group_interval": "groupInterval",
        "group_wait": "groupWait",
        "matchers": "matchers",
        "mute_time_interval": "muteTimeInterval",
        "repeat_interval": "repeatInterval",
    },
)
class AlertManagerRouteProps:
    def __init__(
        self,
        *,
        receiver: AlertManagerReceiver,
        active_time_intervals: typing.Optional[typing.Sequence["TimeInterval"]] = None,
        children: typing.Optional[typing.Sequence[typing.Union["AlertManagerRouteProps", typing.Dict[builtins.str, typing.Any]]]] = None,
        continue_matching: typing.Optional[builtins.bool] = None,
        group_by_labels: typing.Optional[typing.Sequence[builtins.str]] = None,
        group_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        group_wait: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        matchers: typing.Optional[typing.Sequence[AlertManagerMatcher]] = None,
        mute_time_interval: typing.Optional[typing.Sequence["TimeInterval"]] = None,
        repeat_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''Configuration for the alert manager route.

        :param receiver: The receiver that should be the target of alerts that are generated by the node.
        :param active_time_intervals: Times when the route should be active. An empty value means that the route is always active. Additionally, the root node cannot have any active times. The route will send notifications only when active, but otherwise acts normally (including ending the route-matching process if the ``continueMatching`` option is not set).
        :param children: Optional child routes to add to the node.
        :param continue_matching: Whether an alert should continue matching subsequent sibling nodes.
        :param group_by_labels: The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group.
        :param group_interval: How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent (usually ~5m or more).
        :param group_wait: How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group (usually ~0s to few minutes).
        :param matchers: A list of matchers that an alert has to fulfill to match the node.
        :param mute_time_interval: Times when the route should be muted. The root node cannot have any mute times. When a route is muted it will not send any notifications, but otherwise acts normally (including ending the route-matching process if the ``continueMatching`` option is not set).
        :param repeat_interval: How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed4403f97ffeb1d884d35e8b1f0f3f3255c651c54065c235cfeacf177fdece68)
            check_type(argname="argument receiver", value=receiver, expected_type=type_hints["receiver"])
            check_type(argname="argument active_time_intervals", value=active_time_intervals, expected_type=type_hints["active_time_intervals"])
            check_type(argname="argument children", value=children, expected_type=type_hints["children"])
            check_type(argname="argument continue_matching", value=continue_matching, expected_type=type_hints["continue_matching"])
            check_type(argname="argument group_by_labels", value=group_by_labels, expected_type=type_hints["group_by_labels"])
            check_type(argname="argument group_interval", value=group_interval, expected_type=type_hints["group_interval"])
            check_type(argname="argument group_wait", value=group_wait, expected_type=type_hints["group_wait"])
            check_type(argname="argument matchers", value=matchers, expected_type=type_hints["matchers"])
            check_type(argname="argument mute_time_interval", value=mute_time_interval, expected_type=type_hints["mute_time_interval"])
            check_type(argname="argument repeat_interval", value=repeat_interval, expected_type=type_hints["repeat_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "receiver": receiver,
        }
        if active_time_intervals is not None:
            self._values["active_time_intervals"] = active_time_intervals
        if children is not None:
            self._values["children"] = children
        if continue_matching is not None:
            self._values["continue_matching"] = continue_matching
        if group_by_labels is not None:
            self._values["group_by_labels"] = group_by_labels
        if group_interval is not None:
            self._values["group_interval"] = group_interval
        if group_wait is not None:
            self._values["group_wait"] = group_wait
        if matchers is not None:
            self._values["matchers"] = matchers
        if mute_time_interval is not None:
            self._values["mute_time_interval"] = mute_time_interval
        if repeat_interval is not None:
            self._values["repeat_interval"] = repeat_interval

    @builtins.property
    def receiver(self) -> AlertManagerReceiver:
        '''The receiver that should be the target of alerts that are generated by the node.'''
        result = self._values.get("receiver")
        assert result is not None, "Required property 'receiver' is missing"
        return typing.cast(AlertManagerReceiver, result)

    @builtins.property
    def active_time_intervals(self) -> typing.Optional[typing.List["TimeInterval"]]:
        '''Times when the route should be active.

        An empty value means that the route
        is always active. Additionally, the root node cannot have any active
        times.

        The route will send notifications only when active, but otherwise acts
        normally (including ending the route-matching process if the
        ``continueMatching`` option is not set).
        '''
        result = self._values.get("active_time_intervals")
        return typing.cast(typing.Optional[typing.List["TimeInterval"]], result)

    @builtins.property
    def children(self) -> typing.Optional[typing.List["AlertManagerRouteProps"]]:
        '''Optional child routes to add to the node.'''
        result = self._values.get("children")
        return typing.cast(typing.Optional[typing.List["AlertManagerRouteProps"]], result)

    @builtins.property
    def continue_matching(self) -> typing.Optional[builtins.bool]:
        '''Whether an alert should continue matching subsequent sibling nodes.'''
        result = self._values.get("continue_matching")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def group_by_labels(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The labels by which incoming alerts are grouped together.

        For example,
        multiple alerts coming in for cluster=A and alertname=LatencyHigh would be
        batched into a single group.
        '''
        result = self._values.get("group_by_labels")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def group_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent (usually ~5m or more).'''
        result = self._values.get("group_interval")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def group_wait(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to initially wait to send a notification for a group of alerts.

        Allows to wait for an inhibiting alert to arrive or collect more initial
        alerts for the same group (usually ~0s to few minutes).
        '''
        result = self._values.get("group_wait")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def matchers(self) -> typing.Optional[typing.List[AlertManagerMatcher]]:
        '''A list of matchers that an alert has to fulfill to match the node.'''
        result = self._values.get("matchers")
        return typing.cast(typing.Optional[typing.List[AlertManagerMatcher]], result)

    @builtins.property
    def mute_time_interval(self) -> typing.Optional[typing.List["TimeInterval"]]:
        '''Times when the route should be muted. The root node cannot have any mute times.

        When a route is muted it will not send any notifications, but otherwise
        acts normally (including ending the route-matching process if the
        ``continueMatching`` option is not set).
        '''
        result = self._values.get("mute_time_interval")
        return typing.cast(typing.Optional[typing.List["TimeInterval"]], result)

    @builtins.property
    def repeat_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to wait before sending a notification again if it has already been sent successfully for an alert.

        (Usually ~3h or more).
        '''
        result = self._values.get("repeat_interval")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlertManagerRouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.AlertManagerSnsDestinationOptions",
    jsii_struct_bases=[],
    name_mapping={
        "api_url": "apiUrl",
        "attributes": "attributes",
        "message": "message",
        "send_resolved": "sendResolved",
        "subject": "subject",
    },
)
class AlertManagerSnsDestinationOptions:
    def __init__(
        self,
        *,
        api_url: typing.Optional[builtins.str] = None,
        attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        message: typing.Optional[builtins.str] = None,
        send_resolved: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional configuration for an alert manager SNS destination.

        :param api_url: The SNS API URL i.e. https://sns.us-east-2.amazonaws.com. If not specified, the SNS API URL from the SNS SDK will be used.
        :param attributes: SNS message attributes.
        :param message: The message content of the SNS notification.
        :param send_resolved: Controls whether to notify about resolved alerts.
        :param subject: Subject line when the message is delivered to email endpoints.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f8ad7bc7475679a8a60186db7a675c1c4db6fabfe4e6d8df73a36d3d412235b)
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
            check_type(argname="argument attributes", value=attributes, expected_type=type_hints["attributes"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument send_resolved", value=send_resolved, expected_type=type_hints["send_resolved"])
            check_type(argname="argument subject", value=subject, expected_type=type_hints["subject"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_url is not None:
            self._values["api_url"] = api_url
        if attributes is not None:
            self._values["attributes"] = attributes
        if message is not None:
            self._values["message"] = message
        if send_resolved is not None:
            self._values["send_resolved"] = send_resolved
        if subject is not None:
            self._values["subject"] = subject

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''The SNS API URL i.e. https://sns.us-east-2.amazonaws.com.

        If not specified, the SNS API URL from the SNS SDK will be used.
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def attributes(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''SNS message attributes.'''
        result = self._values.get("attributes")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''The message content of the SNS notification.'''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def send_resolved(self) -> typing.Optional[builtins.bool]:
        '''Controls whether to notify about resolved alerts.'''
        result = self._values.get("send_resolved")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def subject(self) -> typing.Optional[builtins.str]:
        '''Subject line when the message is delivered to email endpoints.'''
        result = self._values.get("subject")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlertManagerSnsDestinationOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.AlertManagerSnsDestinationProps",
    jsii_struct_bases=[AlertManagerSnsDestinationOptions],
    name_mapping={
        "api_url": "apiUrl",
        "attributes": "attributes",
        "message": "message",
        "send_resolved": "sendResolved",
        "subject": "subject",
        "topic": "topic",
    },
)
class AlertManagerSnsDestinationProps(AlertManagerSnsDestinationOptions):
    def __init__(
        self,
        *,
        api_url: typing.Optional[builtins.str] = None,
        attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        message: typing.Optional[builtins.str] = None,
        send_resolved: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''Configuration for an alert manager SNS destination.

        :param api_url: The SNS API URL i.e. https://sns.us-east-2.amazonaws.com. If not specified, the SNS API URL from the SNS SDK will be used.
        :param attributes: SNS message attributes.
        :param message: The message content of the SNS notification.
        :param send_resolved: Controls whether to notify about resolved alerts.
        :param subject: Subject line when the message is delivered to email endpoints.
        :param topic: SNS topic where alerts will be sent. If you are using a FIFO SNS topic you should set a message group interval longer than 5 minutes to prevent messages with the same group key being deduplicated by the SNS default deduplication window.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c0e3a4ee3bbc3a8e0a950badb8df7d9d60121def11d541663a23a71003c43a3)
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
            check_type(argname="argument attributes", value=attributes, expected_type=type_hints["attributes"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument send_resolved", value=send_resolved, expected_type=type_hints["send_resolved"])
            check_type(argname="argument subject", value=subject, expected_type=type_hints["subject"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topic": topic,
        }
        if api_url is not None:
            self._values["api_url"] = api_url
        if attributes is not None:
            self._values["attributes"] = attributes
        if message is not None:
            self._values["message"] = message
        if send_resolved is not None:
            self._values["send_resolved"] = send_resolved
        if subject is not None:
            self._values["subject"] = subject

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''The SNS API URL i.e. https://sns.us-east-2.amazonaws.com.

        If not specified, the SNS API URL from the SNS SDK will be used.
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def attributes(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''SNS message attributes.'''
        result = self._values.get("attributes")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''The message content of the SNS notification.'''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def send_resolved(self) -> typing.Optional[builtins.bool]:
        '''Controls whether to notify about resolved alerts.'''
        result = self._values.get("send_resolved")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def subject(self) -> typing.Optional[builtins.str]:
        '''Subject line when the message is delivered to email endpoints.'''
        result = self._values.get("subject")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''SNS topic where alerts will be sent.

        If you are using a FIFO SNS topic you should set a message group interval
        longer than 5 minutes to prevent messages with the same group key being
        deduplicated by the SNS default deduplication window.
        '''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlertManagerSnsDestinationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AlertManagerTemplate(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerTemplate",
):
    '''A template that can be used for formatting alerts sent by alert manager.

    :see: `Notification template examples <https://prometheus.io/docs/alerting/latest/notification_examples/>`_
    '''

    @jsii.member(jsii_name="fromFile")
    @builtins.classmethod
    def from_file(cls, path: builtins.str) -> "AlertManagerTemplate":
        '''Loads an alert template from the local filesystem.

        :param path: The path to the file containg the template.

        :return:

        An object representing the template that can be used when
        configuring alert manager for Amzon APS.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b19a5eb26b31e92c60092ec6a9e25f373aca41ed635d8e122efb2eab6e6534e3)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
        return typing.cast("AlertManagerTemplate", jsii.sinvoke(cls, "fromFile", [path]))

    @jsii.member(jsii_name="fromString")
    @builtins.classmethod
    def from_string(cls, content: builtins.str) -> "AlertManagerTemplate":
        '''Loads an alert manager template using a template string.

        :param content: The template content as a string. Uses the Go templating system.

        :return:

        An object representing the template that can be used when
        configuring alert manager for Amzon APS.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__196ce0e9e6e6d9241e6ac501cf7d47cdb1158789eaa5445b53deb98d00500cce)
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
        return typing.cast("AlertManagerTemplate", jsii.sinvoke(cls, "fromString", [content]))

    @builtins.property
    @jsii.member(jsii_name="content")
    def content(self) -> builtins.str:
        '''The template content as a string.

        Uses the Go templating system.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "content"))


@jsii.data_type(
    jsii_type="cdk-extensions.aps.AlertingRuleProps",
    jsii_struct_bases=[],
    name_mapping={
        "alert": "alert",
        "expression": "expression",
        "annotations": "annotations",
        "labels": "labels",
        "period": "period",
    },
)
class AlertingRuleProps:
    def __init__(
        self,
        *,
        alert: builtins.str,
        expression: builtins.str,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''Options needed to configure a Prometheus alerting rule inside an APS rules configuration.

        :param alert: The name of the alert. Must be a valid label value.
        :param expression: The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
        :param annotations: Annotations to add to each alert. Supports templating.
        :param labels: Labels to add or overwrite for each alert.
        :param period: Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03dc297f91153127e6c9df441f99357df454a0ee2f67066590733f910102f7dd)
            check_type(argname="argument alert", value=alert, expected_type=type_hints["alert"])
            check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "alert": alert,
            "expression": expression,
        }
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alert(self) -> builtins.str:
        '''The name of the alert.

        Must be a valid label value.
        '''
        result = self._values.get("alert")
        assert result is not None, "Required property 'alert' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def expression(self) -> builtins.str:
        '''The PromQL expression to evaluate.

        Every evaluation cycle this is
        evaluated at the current time, and all resultant time series become
        pending/firing alerts.

        :see: `Querying prometheus <https://prometheus.io/docs/prometheus/latest/querying/basics/>`_
        '''
        result = self._values.get("expression")
        assert result is not None, "Required property 'expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations to add to each alert.

        Supports templating.
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels to add or overwrite for each alert.'''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''Alerts are considered firing once they have been returned for this long.

        Alerts which have not yet fired for long enough are considered pending.
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlertingRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.DayOfMonthRange",
    jsii_struct_bases=[],
    name_mapping={"end": "end", "start": "start"},
)
class DayOfMonthRange:
    def __init__(self, *, end: jsii.Number, start: jsii.Number) -> None:
        '''A range specifying the numerical days in the month.

        Days begin at 1. Negative values are also accepted which begin at the end of
        the month, e.g. -1 during January would represent January 31. For example:
        ``start: 1`` and ``end: 5`` or ``start:-3`` and ``end: -1`` would both be valid
        ranges.

        Extending past the start or end of the month will cause it to be clamped.
        E.g. specifying ``start: 1`` and ``end: 31`` during February will clamp the
        actual end date to 28 or 29 depending on leap years.

        Inclusive on both ends.

        :param end: The last day of the month for which the range should apply (inclusive).
        :param start: The first day of the month for which the range should apply.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91482989802c5a19dcf134e159b07770ae3dcd2b9a7eaeb2a41c792761e2cc85)
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "end": end,
            "start": start,
        }

    @builtins.property
    def end(self) -> jsii.Number:
        '''The last day of the month for which the range should apply (inclusive).'''
        result = self._values.get("end")
        assert result is not None, "Required property 'end' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def start(self) -> jsii.Number:
        '''The first day of the month for which the range should apply.'''
        result = self._values.get("start")
        assert result is not None, "Required property 'start' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DayOfMonthRange(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.DefaultRouteOptions",
    jsii_struct_bases=[],
    name_mapping={
        "group_by_labels": "groupByLabels",
        "group_interval": "groupInterval",
        "group_wait": "groupWait",
        "matchers": "matchers",
        "repeat_interval": "repeatInterval",
    },
)
class DefaultRouteOptions:
    def __init__(
        self,
        *,
        group_by_labels: typing.Optional[typing.Sequence[builtins.str]] = None,
        group_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        group_wait: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        matchers: typing.Optional[typing.Sequence[AlertManagerMatcher]] = None,
        repeat_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''Configuration options that control the default behavior of alerts.

        These are the settings that will be used for any alerts that do not match a
        child node in the default routing tree or alerts that do match a child node
        that doesn't override the settings provded here.

        The default route does not support all the settings supported by other
        (child) routes.

        :param group_by_labels: The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group.
        :param group_interval: How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent (usually ~5m or more).
        :param group_wait: How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group (usually ~0s to few minutes).
        :param matchers: A list of matchers that an alert has to fulfill to match the node.
        :param repeat_interval: How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd60c11fc61be6fb2e2d700e6bcb264ce9960081d5dad55964f9bfefc0f0d876)
            check_type(argname="argument group_by_labels", value=group_by_labels, expected_type=type_hints["group_by_labels"])
            check_type(argname="argument group_interval", value=group_interval, expected_type=type_hints["group_interval"])
            check_type(argname="argument group_wait", value=group_wait, expected_type=type_hints["group_wait"])
            check_type(argname="argument matchers", value=matchers, expected_type=type_hints["matchers"])
            check_type(argname="argument repeat_interval", value=repeat_interval, expected_type=type_hints["repeat_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if group_by_labels is not None:
            self._values["group_by_labels"] = group_by_labels
        if group_interval is not None:
            self._values["group_interval"] = group_interval
        if group_wait is not None:
            self._values["group_wait"] = group_wait
        if matchers is not None:
            self._values["matchers"] = matchers
        if repeat_interval is not None:
            self._values["repeat_interval"] = repeat_interval

    @builtins.property
    def group_by_labels(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The labels by which incoming alerts are grouped together.

        For example,
        multiple alerts coming in for cluster=A and alertname=LatencyHigh would be
        batched into a single group.
        '''
        result = self._values.get("group_by_labels")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def group_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent (usually ~5m or more).'''
        result = self._values.get("group_interval")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def group_wait(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to initially wait to send a notification for a group of alerts.

        Allows to wait for an inhibiting alert to arrive or collect more initial
        alerts for the same group (usually ~0s to few minutes).
        '''
        result = self._values.get("group_wait")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def matchers(self) -> typing.Optional[typing.List[AlertManagerMatcher]]:
        '''A list of matchers that an alert has to fulfill to match the node.'''
        result = self._values.get("matchers")
        return typing.cast(typing.Optional[typing.List[AlertManagerMatcher]], result)

    @builtins.property
    def repeat_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How long to wait before sending a notification again if it has already been sent successfully for an alert.

        (Usually ~3h or more).
        '''
        result = self._values.get("repeat_interval")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DefaultRouteOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.interface(jsii_type="cdk-extensions.aps.IAlertManagerConfiguration")
class IAlertManagerConfiguration(typing_extensions.Protocol):
    '''Represents an alert manager configuration object that can be used by resources configuring alerting for Amazon APS.'''

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> AlertManagerConfigurationDetails:
        '''Associates the configuration with a construct that is handling the configuration of alert manager for an APS workspace.

        :param scope: The construct handling the configuration of alert manager that will consume the configuration.

        :return: Alert manager configuration details.
        '''
        ...


class _IAlertManagerConfigurationProxy:
    '''Represents an alert manager configuration object that can be used by resources configuring alerting for Amazon APS.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.aps.IAlertManagerConfiguration"

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> AlertManagerConfigurationDetails:
        '''Associates the configuration with a construct that is handling the configuration of alert manager for an APS workspace.

        :param scope: The construct handling the configuration of alert manager that will consume the configuration.

        :return: Alert manager configuration details.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecdd2b3fa97fa14b06af1c169056107dd7273a62beafadbdc40f621a744f12dc)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(AlertManagerConfigurationDetails, jsii.invoke(self, "bind", [scope]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAlertManagerConfiguration).__jsii_proxy_class__ = lambda : _IAlertManagerConfigurationProxy


@jsii.interface(jsii_type="cdk-extensions.aps.IAlertManagerDestination")
class IAlertManagerDestination(typing_extensions.Protocol):
    '''Represents a destination where alert manager can send notifications.'''

    @builtins.property
    @jsii.member(jsii_name="category")
    def category(self) -> AlertManagerDestinationCategory:
        '''The destination type being configured.

        Represents a config block in an alert manager receiver configuration.
        '''
        ...

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the destination with a construct that is handling the configuration of alert manager.

        :param scope: The construct handling alert manager configuration.

        :return: An object representing the configured destination.
        '''
        ...


class _IAlertManagerDestinationProxy:
    '''Represents a destination where alert manager can send notifications.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.aps.IAlertManagerDestination"

    @builtins.property
    @jsii.member(jsii_name="category")
    def category(self) -> AlertManagerDestinationCategory:
        '''The destination type being configured.

        Represents a config block in an alert manager receiver configuration.
        '''
        return typing.cast(AlertManagerDestinationCategory, jsii.get(self, "category"))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the destination with a construct that is handling the configuration of alert manager.

        :param scope: The construct handling alert manager configuration.

        :return: An object representing the configured destination.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fccab2458beaa98bf6cf63666f8b0850a47aafba67c71c81d78eb861d602cfd4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [scope]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAlertManagerDestination).__jsii_proxy_class__ = lambda : _IAlertManagerDestinationProxy


@jsii.interface(jsii_type="cdk-extensions.aps.IPrometheusRule")
class IPrometheusRule(typing_extensions.Protocol):
    '''Represents a Prometheus rule that can be added to a rule group and used as part of an APS rules configuration.'''

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the rule with a construct that is configuring an APS rule groups namespace.

        :param scope: The construct handling the configuration of the APS rule groups namespace that will be consuming this rule.
        '''
        ...


class _IPrometheusRuleProxy:
    '''Represents a Prometheus rule that can be added to a rule group and used as part of an APS rules configuration.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.aps.IPrometheusRule"

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the rule with a construct that is configuring an APS rule groups namespace.

        :param scope: The construct handling the configuration of the APS rule groups namespace that will be consuming this rule.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75264843e0a175d6d9f62241c774b7b0dc23fbb528c8377d3d828f9348240d69)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [scope]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPrometheusRule).__jsii_proxy_class__ = lambda : _IPrometheusRuleProxy


@jsii.interface(jsii_type="cdk-extensions.aps.IRuleGroupConfiguration")
class IRuleGroupConfiguration(
    _constructs_77d1e7e8.IConstruct,
    typing_extensions.Protocol,
):
    '''Represents a rules configuration that can be consumed by Amazon Managed Service for Prometheus when creating a rule groups namespace.'''

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> "RuleGroupConfigurationDetails":
        '''Associates the configuration with a resource that is handling the creation of an APS rule groups namespace.

        :param scope: The construct handling the configuration of an APS rule groups namespace that will be consuming this configuration.

        :return: Rule group configuration details.
        '''
        ...


class _IRuleGroupConfigurationProxy(
    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
):
    '''Represents a rules configuration that can be consumed by Amazon Managed Service for Prometheus when creating a rule groups namespace.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.aps.IRuleGroupConfiguration"

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> "RuleGroupConfigurationDetails":
        '''Associates the configuration with a resource that is handling the creation of an APS rule groups namespace.

        :param scope: The construct handling the configuration of an APS rule groups namespace that will be consuming this configuration.

        :return: Rule group configuration details.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b85e972216d5ab9ba29e02fee9f5307ab16999f173250e033ec5bcb371f296b1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast("RuleGroupConfigurationDetails", jsii.invoke(self, "bind", [scope]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IRuleGroupConfiguration).__jsii_proxy_class__ = lambda : _IRuleGroupConfigurationProxy


@jsii.interface(jsii_type="cdk-extensions.aps.IRuleGroupsNamespace")
class IRuleGroupsNamespace(typing_extensions.Protocol):
    '''Represents an APS rule groups namespace in AWS.'''

    @builtins.property
    @jsii.member(jsii_name="rulesGroupsNamespaceArn")
    def rules_groups_namespace_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the APS rule groups namespace.'''
        ...


class _IRuleGroupsNamespaceProxy:
    '''Represents an APS rule groups namespace in AWS.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.aps.IRuleGroupsNamespace"

    @builtins.property
    @jsii.member(jsii_name="rulesGroupsNamespaceArn")
    def rules_groups_namespace_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the APS rule groups namespace.'''
        return typing.cast(builtins.str, jsii.get(self, "rulesGroupsNamespaceArn"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IRuleGroupsNamespace).__jsii_proxy_class__ = lambda : _IRuleGroupsNamespaceProxy


@jsii.interface(jsii_type="cdk-extensions.aps.IWorkspace")
class IWorkspace(typing_extensions.Protocol):
    '''Represents an APS workspace in AWS.'''

    @builtins.property
    @jsii.member(jsii_name="workspaceArn")
    def workspace_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the APS workspace.'''
        ...

    @builtins.property
    @jsii.member(jsii_name="workspaceId")
    def workspace_id(self) -> builtins.str:
        '''The ID generated by AWS for the APS workspace.'''
        ...

    @builtins.property
    @jsii.member(jsii_name="workspacePrometheusEndpoint")
    def workspace_prometheus_endpoint(self) -> builtins.str:
        '''The Prometheus endpoint attribute of the workspace.

        This is the endpoint prefix without the remote_write or query API
        appended.
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="workspaceQueryUrl")
    def workspace_query_url(self) -> builtins.str:
        '''The URL of the remote write endpoint which can be used to ingest metrics into the Prometheus workspace.'''
        ...

    @builtins.property
    @jsii.member(jsii_name="workspaceRemoteWriteUrl")
    def workspace_remote_write_url(self) -> builtins.str:
        '''The URL of the endpoint that other services can use to query the workspace.'''
        ...


class _IWorkspaceProxy:
    '''Represents an APS workspace in AWS.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.aps.IWorkspace"

    @builtins.property
    @jsii.member(jsii_name="workspaceArn")
    def workspace_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the APS workspace.'''
        return typing.cast(builtins.str, jsii.get(self, "workspaceArn"))

    @builtins.property
    @jsii.member(jsii_name="workspaceId")
    def workspace_id(self) -> builtins.str:
        '''The ID generated by AWS for the APS workspace.'''
        return typing.cast(builtins.str, jsii.get(self, "workspaceId"))

    @builtins.property
    @jsii.member(jsii_name="workspacePrometheusEndpoint")
    def workspace_prometheus_endpoint(self) -> builtins.str:
        '''The Prometheus endpoint attribute of the workspace.

        This is the endpoint prefix without the remote_write or query API
        appended.
        '''
        return typing.cast(builtins.str, jsii.get(self, "workspacePrometheusEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="workspaceQueryUrl")
    def workspace_query_url(self) -> builtins.str:
        '''The URL of the remote write endpoint which can be used to ingest metrics into the Prometheus workspace.'''
        return typing.cast(builtins.str, jsii.get(self, "workspaceQueryUrl"))

    @builtins.property
    @jsii.member(jsii_name="workspaceRemoteWriteUrl")
    def workspace_remote_write_url(self) -> builtins.str:
        '''The URL of the endpoint that other services can use to query the workspace.'''
        return typing.cast(builtins.str, jsii.get(self, "workspaceRemoteWriteUrl"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IWorkspace).__jsii_proxy_class__ = lambda : _IWorkspaceProxy


@jsii.enum(jsii_type="cdk-extensions.aps.MatchOperator")
class MatchOperator(enum.Enum):
    '''The logical operator an alert manager matcher should use when evaluating filters for labels.'''

    EQUALS = "EQUALS"
    '''Evaluate an alert manager filter on the basis that the label matches the string it is being compared against.'''
    NOT_EQUALS = "NOT_EQUALS"
    '''Evaluate an alert manager filter on the basis that the label does not match the string it is being compared against.'''
    RE_EQUALS = "RE_EQUALS"
    '''Evaluate an alert manager filter on the basis that the label matches the regular expression it is being compared against.'''
    RE_NOT_EQUALS = "RE_NOT_EQUALS"
    '''Evaluate an alert manager filter on the basis that the label does not match the regular expression it is being compared against.'''


@jsii.data_type(
    jsii_type="cdk-extensions.aps.MonthRange",
    jsii_struct_bases=[],
    name_mapping={"start": "start", "end": "end"},
)
class MonthRange:
    def __init__(
        self,
        *,
        start: jsii.Number,
        end: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''A range of calendar months identified by number, where January = 1.

        Ranges are also accepted by specifying ``end`` inclusive on both ends.

        :param start: The month where the range should start.
        :param end: The month at the end of the range if the range should cover multiple months (inclusive).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba5b4769c15fcc5ddb1fb353f385695ce6f6dcc4882ac8aa188d97b78edcd64c)
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "start": start,
        }
        if end is not None:
            self._values["end"] = end

    @builtins.property
    def start(self) -> jsii.Number:
        '''The month where the range should start.'''
        result = self._values.get("start")
        assert result is not None, "Required property 'start' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def end(self) -> typing.Optional[jsii.Number]:
        '''The month at the end of the range if the range should cover multiple months (inclusive).'''
        result = self._values.get("end")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonthRange(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PrometheusRule(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.PrometheusRule",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="alertingRule")
    @builtins.classmethod
    def alerting_rule(
        cls,
        *,
        alert: builtins.str,
        expression: builtins.str,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> "AlertingRule":
        '''
        :param alert: The name of the alert. Must be a valid label value.
        :param expression: The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
        :param annotations: Annotations to add to each alert. Supports templating.
        :param labels: Labels to add or overwrite for each alert.
        :param period: Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending.
        '''
        options = AlertingRuleProps(
            alert=alert,
            expression=expression,
            annotations=annotations,
            labels=labels,
            period=period,
        )

        return typing.cast("AlertingRule", jsii.sinvoke(cls, "alertingRule", [options]))

    @jsii.member(jsii_name="recordingRule")
    @builtins.classmethod
    def recording_rule(
        cls,
        *,
        expression: builtins.str,
        record: builtins.str,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> "RecordingRule":
        '''
        :param expression: The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and the result recorded as a new set of time series with the metric name as given by ``record``.
        :param record: The name of the time series to output to. Must be a valid metric name.
        :param labels: Labels to add or overwrite before storing the result.
        '''
        options = RecordingRuleProps(
            expression=expression, record=record, labels=labels
        )

        return typing.cast("RecordingRule", jsii.sinvoke(cls, "recordingRule", [options]))


@jsii.implements(IPrometheusRule)
class RecordingRule(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.RecordingRule",
):
    '''Recording rules allow you to precompute frequently needed or computationally expensive expressions and save their result as a new set of time series.

    Querying the precomputed result will then often be much faster than
    executing the original expression every time it is needed. This is
    especially useful for dashboards, which need to query the same expression
    repeatedly every time they refresh.

    :see: `Defining recording rules <https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/>`_
    '''

    def __init__(
        self,
        *,
        expression: builtins.str,
        record: builtins.str,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Creates a new instance of the RecordingRule class.

        :param expression: The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and the result recorded as a new set of time series with the metric name as given by ``record``.
        :param record: The name of the time series to output to. Must be a valid metric name.
        :param labels: Labels to add or overwrite before storing the result.
        '''
        props = RecordingRuleProps(expression=expression, record=record, labels=labels)

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="addLabel")
    def add_label(self, label: builtins.str, value: builtins.str) -> "RecordingRule":
        '''Sets a new label and value that will be added or overridden before storing the result.

        :param label: The name of the label to add.
        :param value: The values of the label to add.

        :return: The recording rule that the label was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__766cef3d6a3845efb1243ac0af2147f37bd3a1a549bdddc7dac97e1e44120e0d)
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("RecordingRule", jsii.invoke(self, "addLabel", [label, value]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        _scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the recording rule with a construct that is configuring an APS rule groups namespace.

        :param _scope: The construct handling the configuration of the APS rule groups namespace that will be consuming this rule.

        :return:

        The rendered configuration for the rule as expected by and APS
        rules config file.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe9a2d500fce73b7d53b348c34eb739a54714883da2f2c8ebe11d93aa884ceb7)
            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [_scope]))

    @builtins.property
    @jsii.member(jsii_name="expression")
    def expression(self) -> builtins.str:
        '''The PromQL expression to evaluate.

        Every evaluation cycle this is
        evaluated at the current time, and the result recorded as a new set of
        time series with the metric name as given by ``record``.

        :see: `Querying prometheus <https://prometheus.io/docs/prometheus/latest/querying/basics/>`_
        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "expression"))

    @builtins.property
    @jsii.member(jsii_name="labels")
    def labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''Labels to add or overwrite before storing the result.'''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "labels"))

    @builtins.property
    @jsii.member(jsii_name="record")
    def record(self) -> builtins.str:
        '''The name of the time series to output to.

        Must be a valid metric name.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "record"))


@jsii.data_type(
    jsii_type="cdk-extensions.aps.RecordingRuleProps",
    jsii_struct_bases=[],
    name_mapping={"expression": "expression", "record": "record", "labels": "labels"},
)
class RecordingRuleProps:
    def __init__(
        self,
        *,
        expression: builtins.str,
        record: builtins.str,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Options needed to configure a Prometheus recording rule inside an APS rules configuration.

        :param expression: The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and the result recorded as a new set of time series with the metric name as given by ``record``.
        :param record: The name of the time series to output to. Must be a valid metric name.
        :param labels: Labels to add or overwrite before storing the result.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cb0a604680ecb8a8589cf7d59a5996ec19c7318e64e54c54b20f83235fd7b3f)
            check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
            check_type(argname="argument record", value=record, expected_type=type_hints["record"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "expression": expression,
            "record": record,
        }
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def expression(self) -> builtins.str:
        '''The PromQL expression to evaluate.

        Every evaluation cycle this is
        evaluated at the current time, and the result recorded as a new set of
        time series with the metric name as given by ``record``.

        :see: `Querying prometheus <https://prometheus.io/docs/prometheus/latest/querying/basics/>`_
        '''
        result = self._values.get("expression")
        assert result is not None, "Required property 'expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def record(self) -> builtins.str:
        '''The name of the time series to output to.

        Must be a valid metric name.
        '''
        result = self._values.get("record")
        assert result is not None, "Required property 'record' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels to add or overwrite before storing the result.'''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RecordingRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RuleGroup(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.RuleGroup",
):
    '''A group of alerting and recording rules for use inside an APS rule groups namespace configuration.

    Rules within a group are run sequentially at a
    regular interval, with the same evaluation time. The names of recording
    rules must be valid metric names. The names of alerting rules must be valid
    label values.

    :see: `Prometheus rule_group specification <https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group>`_
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        limit: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        rules: typing.Optional[typing.Sequence[IPrometheusRule]] = None,
    ) -> None:
        '''Creates a new instance of the RuleGroup class.

        :param scope: A CDK Construct that will serve as this construct's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param interval: How often rules in the group are evaluated.
        :param limit: Limit the number of alerts an alerting rule and series a recording rule can produce. 0 is no limit.
        :param name: The name of the group. Must be unique within the configuration.
        :param rules: The rules to be evaluated per the rule group's configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1c9c0811f780ca66f2de4679bd7d5b37bfd855f049daf852b8f62bdde371c56)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RuleGroupProps(interval=interval, limit=limit, name=name, rules=rules)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addAlertingRule")
    def add_alerting_rule(
        self,
        *,
        alert: builtins.str,
        expression: builtins.str,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> "AlertingRule":
        '''Adds an alerting rule to the rule group.

        :param alert: The name of the alert. Must be a valid label value.
        :param expression: The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
        :param annotations: Annotations to add to each alert. Supports templating.
        :param labels: Labels to add or overwrite for each alert.
        :param period: Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending.

        :return: The alerting rule that was added.
        '''
        options = AlertingRuleProps(
            alert=alert,
            expression=expression,
            annotations=annotations,
            labels=labels,
            period=period,
        )

        return typing.cast("AlertingRule", jsii.invoke(self, "addAlertingRule", [options]))

    @jsii.member(jsii_name="addRecordingRule")
    def add_recording_rule(
        self,
        *,
        expression: builtins.str,
        record: builtins.str,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> RecordingRule:
        '''Adds a recording rule to the rule group.

        :param expression: The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and the result recorded as a new set of time series with the metric name as given by ``record``.
        :param record: The name of the time series to output to. Must be a valid metric name.
        :param labels: Labels to add or overwrite before storing the result.

        :return: The recording rule that was added.
        '''
        options = RecordingRuleProps(
            expression=expression, record=record, labels=labels
        )

        return typing.cast(RecordingRule, jsii.invoke(self, "addRecordingRule", [options]))

    @jsii.member(jsii_name="addRule")
    def add_rule(self, rule: IPrometheusRule) -> "RuleGroup":
        '''Adds a Prometheus rule to the rule group.

        This method can be used to implement any rules that are created outside of
        the the rule group that were created manually by calling their
        constructors or for adding Prometheus rules that use their own custom
        implementations.

        :param rule: The rule to add to the rule group.

        :return: The rule group that the rule was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9671d71d38146be7045ad22dbd2f4b6b0f0f8e7d085457bff6d369ca1bbe2eee)
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
        return typing.cast("RuleGroup", jsii.invoke(self, "addRule", [rule]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the rule group with a construct that is configuring an APS rule groups namespace.

        :param scope: The construct handling the configuration of the APS rule groups namespace that will be consuming this rule group.

        :return:

        The rendered configuration for the rule group as expected by an
        APS rules config file.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7d27d9bfa9cf70bc0af9fe809c05983f7493240ca6fa0f0e576cbb7d37b6db9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [scope]))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the group.

        Must be unique within the configuration.
        '''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="interval")
    def interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How often rules in the group are evaluated.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "interval"))

    @builtins.property
    @jsii.member(jsii_name="limit")
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Limit the number of alerts an alerting rule and series a recording rule can produce.

        0 is no limit.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "limit"))


@jsii.implements(IRuleGroupConfiguration)
class RuleGroupConfiguration(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.RuleGroupConfiguration",
):
    '''Represents a rules file definition that can be consumed by Amazon Managed Service for Prometheus.

    :see: `Creating a rules file <https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-ruler-rulesfile.html>`_
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
    ) -> None:
        '''Creates a new instance of the RuleGroupConfiguration class.

        :param scope: A CDK Construct that will serve as this construct's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82e91dfc0fd2e0edf704b7576497f5b49d4749b49f1dc1995a58f08ac3b5dcd7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        _props = RuleGroupConfigurationProps()

        jsii.create(self.__class__, self, [scope, id, _props])

    @jsii.member(jsii_name="fromContent")
    @builtins.classmethod
    def from_content(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        content: builtins.str,
    ) -> IRuleGroupConfiguration:
        '''Imports an APS rules configuration using a raw string.

        The string should be in YAML format and follow the specification expected
        by the ``aps:CreateRuleGroupsNamespace`` API call.

        :param scope: The construct handling the configuration of a rule groups namespace that will consume the rendered configuration.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param content: The raw string content of a rule groups configuration.

        :return:

        An object that can be used to configure a rule groups namespace
        for APS.

        :see: `Rules file specification <https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-ruler-rulesfile.html>`_
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4704d54dcf52ffd4cd19851f0317d64566703de088bdcb472154b8b06f28be6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
        return typing.cast(IRuleGroupConfiguration, jsii.sinvoke(cls, "fromContent", [scope, id, content]))

    @jsii.member(jsii_name="fromRulesFile")
    @builtins.classmethod
    def from_rules_file(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        path: builtins.str,
    ) -> IRuleGroupConfiguration:
        '''Imports an APS rules file from the local filesystem.

        The file should be in YAML format and follow the specification expected by
        the ``aps:CreateRuleGroupsNamespace`` API call.

        :param scope: The construct handling the configuration of a rule groups namespace that will consume the rendered configuration.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param path: The path to the file containing the rule group definitions.

        :return:

        An object that can be used to configure a rule groups namespace
        for APS.

        :see: `Rules file specification <https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-ruler-rulesfile.html>`_
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a58b4be87af46f6c4d5dce1b0a2d656b983d133dfcca81aca400c31b65b0e69)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
        return typing.cast(IRuleGroupConfiguration, jsii.sinvoke(cls, "fromRulesFile", [scope, id, path]))

    @jsii.member(jsii_name="addRuleGroup")
    def add_rule_group(
        self,
        id: builtins.str,
        *,
        interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        limit: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        rules: typing.Optional[typing.Sequence[IPrometheusRule]] = None,
    ) -> RuleGroup:
        '''Adds a new rule group to the configuration.

        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param interval: How often rules in the group are evaluated.
        :param limit: Limit the number of alerts an alerting rule and series a recording rule can produce. 0 is no limit.
        :param name: The name of the group. Must be unique within the configuration.
        :param rules: The rules to be evaluated per the rule group's configuration.

        :return: The rule group that was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ec0c2bc99d2f805875d8420ffaf9f0aa72a252b4d9c7777b47250b64f42d62f)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = RuleGroupProps(
            interval=interval, limit=limit, name=name, rules=rules
        )

        return typing.cast(RuleGroup, jsii.invoke(self, "addRuleGroup", [id, options]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> "RuleGroupConfigurationDetails":
        '''Associates the configuration with a resource that is handling the creation of an APS rule groups namespace.

        :param scope: The construct handling the configuration of an APS rule groups namespace that will be consuming this configuration.

        :return: Rule group configuration details.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c6c794bcae38f1d84bd8b1e3c7746816a740f5b4abd71031f02a616d9fc476c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast("RuleGroupConfigurationDetails", jsii.invoke(self, "bind", [scope]))

    @builtins.property
    @jsii.member(jsii_name="ruleGroups")
    def rule_groups(self) -> typing.List[RuleGroup]:
        '''Collection of rule groups that are part of this configuration.'''
        return typing.cast(typing.List[RuleGroup], jsii.get(self, "ruleGroups"))


@jsii.data_type(
    jsii_type="cdk-extensions.aps.RuleGroupConfigurationDetails",
    jsii_struct_bases=[],
    name_mapping={"content": "content"},
)
class RuleGroupConfigurationDetails:
    def __init__(self, *, content: builtins.str) -> None:
        '''The details that are needed to configure an APS rule groups namespace that will consume a rule group configuration.

        :param content: The content of the rules configuration definition, in the format of an APS rules configuration file.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__423ff5f64b5ebe408959b0544d5db016cecc0971061cfbaec62dc29a5ed5ba3b)
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "content": content,
        }

    @builtins.property
    def content(self) -> builtins.str:
        '''The content of the rules configuration definition, in the format of an APS rules configuration file.

        :see: `Creating a rules file <https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-ruler-rulesfile.html>`_
        '''
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RuleGroupConfigurationDetails(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.RuleGroupConfigurationProps",
    jsii_struct_bases=[],
    name_mapping={},
)
class RuleGroupConfigurationProps:
    def __init__(self) -> None:
        '''Configuration options for a Prometheus rule group configuration.'''
        self._values: typing.Dict[builtins.str, typing.Any] = {}

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RuleGroupConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.RuleGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "interval": "interval",
        "limit": "limit",
        "name": "name",
        "rules": "rules",
    },
)
class RuleGroupProps:
    def __init__(
        self,
        *,
        interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        limit: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        rules: typing.Optional[typing.Sequence[IPrometheusRule]] = None,
    ) -> None:
        '''Options needed to configure a Prometheus rule group for use with an APS rule groups namespace configuration.

        :param interval: How often rules in the group are evaluated.
        :param limit: Limit the number of alerts an alerting rule and series a recording rule can produce. 0 is no limit.
        :param name: The name of the group. Must be unique within the configuration.
        :param rules: The rules to be evaluated per the rule group's configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1dfec7bd99cc994e9ab03daaa7ce0e1c148ce404cf798008dea766dbcb75887)
            check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
            check_type(argname="argument limit", value=limit, expected_type=type_hints["limit"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if interval is not None:
            self._values["interval"] = interval
        if limit is not None:
            self._values["limit"] = limit
        if name is not None:
            self._values["name"] = name
        if rules is not None:
            self._values["rules"] = rules

    @builtins.property
    def interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''How often rules in the group are evaluated.'''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Limit the number of alerts an alerting rule and series a recording rule can produce.

        0 is no limit.
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the group.

        Must be unique within the configuration.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rules(self) -> typing.Optional[typing.List[IPrometheusRule]]:
        '''The rules to be evaluated per the rule group's configuration.'''
        result = self._values.get("rules")
        return typing.cast(typing.Optional[typing.List[IPrometheusRule]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RuleGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IRuleGroupsNamespace)
class RuleGroupsNamespace(
    _aws_cdk_ceddda9d.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.RuleGroupsNamespace",
):
    '''Amazon Managed Service for Prometheus allows for the configuration of rules that configure alerting and precomputation of frequently needed expressions.

    These rules are added to a workspace using configurations that define one or
    more resource groups. Eache group can contain one or more rules and
    configures the frequency that its rules should be evaluated.

    You can have multiple configurations per workspace. Each configuration is
    contained in a separate *namespace*. Having multiple configuration lets you
    import existing Prometheus rules files to a workspace without having to
    change or combine them. Different rule group namespaces can also have
    different tags.

    :see: `Recording rules and alerting rules <https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-Ruler.html>`_
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        workspace: IWorkspace,
        configuration: typing.Optional[IRuleGroupConfiguration] = None,
        name: typing.Optional[builtins.str] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the RuleGroupsNamespace class.

        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param workspace: The APS workspace that contains this rule groups namespace.
        :param configuration: The rules definition file for this namespace.
        :param name: The name of the rule groups namespace.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d68984d2393848e009717ab81cb791770327c139758dd210de914351de24be89)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RuleGroupsNamespaceProps(
            workspace=workspace,
            configuration=configuration,
            name=name,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromRuleGroupsNamespaceArn")
    @builtins.classmethod
    def from_rule_groups_namespace_arn(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        arn: builtins.str,
    ) -> IRuleGroupsNamespace:
        '''Imports an existing APS rule groups namespace by specifying its Amazon Resource Name (ARN).

        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param arn: The ARN of the existing APS rule groups namespace. to be imported.

        :return: An object representing the imported APS rule groups namespace.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5291057f47a8ca5ad2b1341e777c2934d4e1bc98b9b6d8c671eb233dd3cf6103)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
        return typing.cast(IRuleGroupsNamespace, jsii.sinvoke(cls, "fromRuleGroupsNamespaceArn", [scope, id, arn]))

    @jsii.member(jsii_name="addRuleGroup")
    def add_rule_group(
        self,
        id: builtins.str,
        *,
        interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        limit: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        rules: typing.Optional[typing.Sequence[IPrometheusRule]] = None,
    ) -> RuleGroup:
        '''Adds a new rule group to the configuration.

        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param interval: How often rules in the group are evaluated.
        :param limit: Limit the number of alerts an alerting rule and series a recording rule can produce. 0 is no limit.
        :param name: The name of the group. Must be unique within the configuration.
        :param rules: The rules to be evaluated per the rule group's configuration.

        :return: The rule group that was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6d7e5d895d2c19465bf669ca6799a1ab2fcf07aafd6fbfa9eea8462b44e9707)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = RuleGroupProps(
            interval=interval, limit=limit, name=name, rules=rules
        )

        return typing.cast(RuleGroup, jsii.invoke(self, "addRuleGroup", [id, options]))

    @builtins.property
    @jsii.member(jsii_name="configuration")
    def configuration(self) -> IRuleGroupConfiguration:
        '''The rules definition file for this namespace.

        :see: `RuleGroupsNamespace Data <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-rulegroupsnamespace.html#cfn-aps-rulegroupsnamespace-data>`_
        :group: Inputs
        '''
        return typing.cast(IRuleGroupConfiguration, jsii.get(self, "configuration"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the rule groups namespace.

        :see: `RuleGroupsNamespace Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-rulegroupsnamespace.html#cfn-aps-rulegroupsnamespace-name>`_
        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> _aws_cdk_aws_aps_ceddda9d.CfnRuleGroupsNamespace:
        '''The underlying RuleGroupsNamespace CloudFormation resource.

        :see: `AWS::APS::RuleGroupsNamespace <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-rulegroupsnamespace.html>`_
        :group: Resources
        '''
        return typing.cast(_aws_cdk_aws_aps_ceddda9d.CfnRuleGroupsNamespace, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="rulesGroupsNamespaceArn")
    def rules_groups_namespace_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the APS rule groups namespace.'''
        return typing.cast(builtins.str, jsii.get(self, "rulesGroupsNamespaceArn"))

    @builtins.property
    @jsii.member(jsii_name="workspace")
    def workspace(self) -> IWorkspace:
        '''The APS workspace that contains this rule groups namespace.

        :see: `RuleGroupsNamespace Workspace <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-rulegroupsnamespace.html#cfn-aps-rulegroupsnamespace-workspace>`_
        :group: Inputs
        '''
        return typing.cast(IWorkspace, jsii.get(self, "workspace"))


@jsii.data_type(
    jsii_type="cdk-extensions.aps.RuleGroupsNamespaceProps",
    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "workspace": "workspace",
        "configuration": "configuration",
        "name": "name",
    },
)
class RuleGroupsNamespaceProps(_aws_cdk_ceddda9d.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        workspace: IWorkspace,
        configuration: typing.Optional[IRuleGroupConfiguration] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the RuleGroupsNamespace resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param workspace: The APS workspace that contains this rule groups namespace.
        :param configuration: The rules definition file for this namespace.
        :param name: The name of the rule groups namespace.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0252d99982159aab121bf38bd05d671eba3d363a86831dd5866fbbb9a65fcc19)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument workspace", value=workspace, expected_type=type_hints["workspace"])
            check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "workspace": workspace,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if configuration is not None:
            self._values["configuration"] = configuration
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def workspace(self) -> IWorkspace:
        '''The APS workspace that contains this rule groups namespace.

        :see: `RuleGroupsNamespace Workspace <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-rulegroupsnamespace.html#cfn-aps-rulegroupsnamespace-workspace>`_
        '''
        result = self._values.get("workspace")
        assert result is not None, "Required property 'workspace' is missing"
        return typing.cast(IWorkspace, result)

    @builtins.property
    def configuration(self) -> typing.Optional[IRuleGroupConfiguration]:
        '''The rules definition file for this namespace.

        :see: `RuleGroupsNamespace Data <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-rulegroupsnamespace.html#cfn-aps-rulegroupsnamespace-data>`_
        '''
        result = self._values.get("configuration")
        return typing.cast(typing.Optional[IRuleGroupConfiguration], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the rule groups namespace.

        :see: `RuleGroupsNamespace Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-rulegroupsnamespace.html#cfn-aps-rulegroupsnamespace-name>`_
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RuleGroupsNamespaceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TimeInterval(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.TimeInterval",
):
    '''Represents a named interval of time that may be referenced by the alert manager router to mute/activate particular routes for particular times of day.

    :see: `Time Interval Official Documentation <https://prometheus.io/docs/alerting/latest/configuration/#time_interval-0>`_
    '''

    def __init__(
        self,
        scope: "AlertManagerConfiguration",
        id: builtins.str,
        *,
        intervals: typing.Optional[typing.Sequence["TimeIntervalEntry"]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the TimeInterval class.

        :param scope: A CDK Construct that will serve as this construct's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param intervals: The interval definitions that define the periods of time that the time interval should apply for.
        :param name: The name of the time interval as it will be referenced throught the rest of the alert manager configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac54d46a5938da8c9cafacaf92b4c345c98a627d1e0e6d70a8d8a0eb52bac6c7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = TimeIntervalProps(intervals=intervals, name=name)

        jsii.create(self.__class__, self, [scope, id, options])

    @jsii.member(jsii_name="addInterval")
    def add_interval(self, interval: "TimeIntervalEntry") -> "TimeIntervalEntry":
        '''Adds a new time interval entry to the time interval.

        :param interval: The the time interval entry to be added.

        :return: The time interval which was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dca86cd7f6c4b9cfc7c95022cd8b943e358006a77068697f3b7aba9ce230ffa)
            check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
        return typing.cast("TimeIntervalEntry", jsii.invoke(self, "addInterval", [interval]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the time interval with a construct that is handling the configuration of alert manager.

        :param scope: The construct handling the configuration of alert manager that will consume the rendered configuration.

        :return: An alert manager ``time_interval`` configuration object.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e3e34aebd6d40b42aeafae899c87267ebbeaf9f5e87d58ef5078a215ad0054c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [scope]))

    @builtins.property
    @jsii.member(jsii_name="intervals")
    def intervals(self) -> typing.List["TimeIntervalEntry"]:
        '''Collection of interval entries that defined the the full scope of the periods for which the time interval should apply.

        :group: Inputs
        '''
        return typing.cast(typing.List["TimeIntervalEntry"], jsii.get(self, "intervals"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the time interval as it will be referenced throught the rest of the alert manager configuration.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "name"))


class TimeIntervalEntry(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.TimeIntervalEntry",
):
    '''An object specifying a collection of ranges that together make up an interval of time.

    Referenced by alert manager to define periods for which certain settings
    should apply.

    :see: `Time Interval Official Documentation <https://prometheus.io/docs/alerting/latest/configuration/#time_interval-0>`_
    '''

    def __init__(
        self,
        *,
        days_of_the_month: typing.Optional[typing.Sequence[typing.Union[DayOfMonthRange, typing.Dict[builtins.str, typing.Any]]]] = None,
        months: typing.Optional[typing.Sequence[typing.Union[MonthRange, typing.Dict[builtins.str, typing.Any]]]] = None,
        times: typing.Optional[typing.Sequence[typing.Union["TimeRange", typing.Dict[builtins.str, typing.Any]]]] = None,
        time_zone: typing.Optional[builtins.str] = None,
        weekdays: typing.Optional[typing.Sequence[typing.Union["WeekdayRange", typing.Dict[builtins.str, typing.Any]]]] = None,
        years: typing.Optional[typing.Sequence[typing.Union["YearRange", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Creates a new instance of the TimeIntervalEntry class.

        :param days_of_the_month: A list of ranges specifying the days of the month that the time interval should apply for.
        :param months: A list of ranges specifying the months that the time interval should apply for.
        :param times: A list of ranges specifying the time periods that the time interval should apply for.
        :param time_zone: A string that matches a location in the IANA time zone database. For example, 'Australia/Sydney'. The location provides the time zone for the time interval. You may also use ``Local`` as a location to use the local time of the machine where Alertmanager is running, or ``UTC`` for UTC time. If no timezone is provided, the time interval is taken to be in UTC time.
        :param weekdays: A list of ranges specifying the weekdays that the time interval should apply for.
        :param years: A list of ranges specifying the years that the time interval should apply for.
        '''
        options = TimeIntervalEntryProps(
            days_of_the_month=days_of_the_month,
            months=months,
            times=times,
            time_zone=time_zone,
            weekdays=weekdays,
            years=years,
        )

        jsii.create(self.__class__, self, [options])

    @jsii.member(jsii_name="addDaysOfTheMonth")
    def add_days_of_the_month(
        self,
        start: jsii.Number,
        end: jsii.Number,
    ) -> "TimeIntervalEntry":
        '''Adds a range specifying the numerical days in the month.

        Days begin at 1. Negative values are also accepted which begin at the end
        of the month, e.g. -1 during January would represent January 31. For
        example: ``start: 1`` and ``end: 5`` or ``start:-3`` and ``end: -1`` would both be
        valid ranges.

        Extending past the start or end of the month will cause it to be clamped.
        E.g. specifying ``start: 1`` and ``end: 31`` during February will clamp the
        actual end date to 28 or 29 depending on leap years.

        Inclusive on both ends.

        :param start: The first day of the month for which the range should apply.
        :param end: The last day of the month for which the range should apply (inclusive).

        :return: The time interval the range was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__653ee1759b2d673eb89f130ab38eae34eb8c4e1584d6d23100d54df69bc2b23e)
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
        return typing.cast("TimeIntervalEntry", jsii.invoke(self, "addDaysOfTheMonth", [start, end]))

    @jsii.member(jsii_name="addMonth")
    def add_month(
        self,
        start: jsii.Number,
        end: typing.Optional[jsii.Number] = None,
    ) -> "TimeIntervalEntry":
        '''A range of calendar months identified by number, where January = 1.

        Ranges are also accepted by specifying ``end`` inclusive on both ends.

        :param start: The month where the range should start.
        :param end: The month at the end of the range if the range should cover multiple months (inclusive).

        :return: The time interval the range was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__589474887b25ca9c5b7606ded92704328f6a1184a304f622245c201406d7f8e1)
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
        return typing.cast("TimeIntervalEntry", jsii.invoke(self, "addMonth", [start, end]))

    @jsii.member(jsii_name="addTimes")
    def add_times(self, start: builtins.str, end: builtins.str) -> "TimeIntervalEntry":
        '''Ranges inclusive of the starting time and exclusive of the end time to make it easy to represent times that start/end on hour boundaries.

        For example, ``start: '17:00'`` and ``end: '24:00'`` will begin at 17:00 and
        finish immediately before 24:00.

        :param start: The start time, specified in the format 'HH:MM' using 24 hour time.
        :param end: The end time, specified in the format 'HH:MM' using 24 hour time.

        :return: The time interval the range was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1d188b5a8cb4744fd0b3c494f1e0cc47d5e2f126f997cc0ae6bb2734fc18ac2)
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
        return typing.cast("TimeIntervalEntry", jsii.invoke(self, "addTimes", [start, end]))

    @jsii.member(jsii_name="addWeekday")
    def add_weekday(
        self,
        start: "Weekday",
        end: typing.Optional["Weekday"] = None,
    ) -> "TimeIntervalEntry":
        '''Adds a day of the week, where the week begins on Sunday and ends on Saturday.

        For convenience, ranges are also accepted by specifying ``end`` and are
        inclusive on both ends.

        :param start: The day of the week where the range should start.
        :param end: The day of the week where the range should end. If not specified, the range will end at the end of the day specified by ``start``.

        :return: The time interval the range was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1259681c2471be930665f6cc67eba92f68e7ad2c267a983872ccbf6bcf35e73)
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
        return typing.cast("TimeIntervalEntry", jsii.invoke(self, "addWeekday", [start, end]))

    @jsii.member(jsii_name="addYears")
    def add_years(
        self,
        start: jsii.Number,
        end: typing.Optional[jsii.Number] = None,
    ) -> "TimeIntervalEntry":
        '''Adds a numerical range of years.

        Ranges to cover multiple years are accepted. For example, ``start: 2020`` and
        ``end: 2022``.

        Inclusive on both ends.

        :param start: The year where the range should start.
        :param end: The year where the range should end. If not specified, the range will end at the end of the year specified by ``start``.

        :return: The time interval the range was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f0d149db37d02157b7e1462224eac8c483cea087f1c682da8b1da0b2ecd7a0f)
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
        return typing.cast("TimeIntervalEntry", jsii.invoke(self, "addYears", [start, end]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        _scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the time interval with a construct that is handling the configuration of alert manager.

        :param _scope: The construct handling the configuration of alert manager that will consume the rendered configuration.

        :return: An alert manager ``time_interval`` configuration object.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73ec4c1843ef913457f4d863112ea0340ee6a230f03f9c02ef74ffa53e33b29e)
            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [_scope]))

    @builtins.property
    @jsii.member(jsii_name="daysOfTheMonth")
    def days_of_the_month(self) -> typing.List[DayOfMonthRange]:
        '''Collection of day of the month ranges for which this time interval will apply.

        :group: Inputs
        '''
        return typing.cast(typing.List[DayOfMonthRange], jsii.get(self, "daysOfTheMonth"))

    @builtins.property
    @jsii.member(jsii_name="months")
    def months(self) -> typing.List[MonthRange]:
        '''Collection of month ranges for which this time interval will apply.

        :group: Inputs
        '''
        return typing.cast(typing.List[MonthRange], jsii.get(self, "months"))

    @builtins.property
    @jsii.member(jsii_name="times")
    def times(self) -> typing.List["TimeRange"]:
        '''Collection of time ranges for which this time interval will apply.

        :group: Inputs
        '''
        return typing.cast(typing.List["TimeRange"], jsii.get(self, "times"))

    @builtins.property
    @jsii.member(jsii_name="weekdays")
    def weekdays(self) -> typing.List["WeekdayRange"]:
        '''Collection of weekday ranges for which this time interval will apply.

        :group: Inputs
        '''
        return typing.cast(typing.List["WeekdayRange"], jsii.get(self, "weekdays"))

    @builtins.property
    @jsii.member(jsii_name="years")
    def years(self) -> typing.List["YearRange"]:
        '''Collection of year ranges for which this time interval will apply.

        :group: Inputs
        '''
        return typing.cast(typing.List["YearRange"], jsii.get(self, "years"))

    @builtins.property
    @jsii.member(jsii_name="timeZone")
    def time_zone(self) -> typing.Optional[builtins.str]:
        '''A string that matches a location in the IANA time zone database.

        For example, 'Australia/Sydney'. The location provides the time zone for
        the time interval.

        You may also use ``Local`` as a location to use the local time of the
        machine where Alertmanager is running, or ``UTC`` for UTC time. If no
        timezone is provided, the time interval is taken to be in UTC time.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeZone"))


@jsii.data_type(
    jsii_type="cdk-extensions.aps.TimeIntervalEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "days_of_the_month": "daysOfTheMonth",
        "months": "months",
        "times": "times",
        "time_zone": "timeZone",
        "weekdays": "weekdays",
        "years": "years",
    },
)
class TimeIntervalEntryProps:
    def __init__(
        self,
        *,
        days_of_the_month: typing.Optional[typing.Sequence[typing.Union[DayOfMonthRange, typing.Dict[builtins.str, typing.Any]]]] = None,
        months: typing.Optional[typing.Sequence[typing.Union[MonthRange, typing.Dict[builtins.str, typing.Any]]]] = None,
        times: typing.Optional[typing.Sequence[typing.Union["TimeRange", typing.Dict[builtins.str, typing.Any]]]] = None,
        time_zone: typing.Optional[builtins.str] = None,
        weekdays: typing.Optional[typing.Sequence[typing.Union["WeekdayRange", typing.Dict[builtins.str, typing.Any]]]] = None,
        years: typing.Optional[typing.Sequence[typing.Union["YearRange", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Configuration for the alert manager time interval.

        :param days_of_the_month: A list of ranges specifying the days of the month that the time interval should apply for.
        :param months: A list of ranges specifying the months that the time interval should apply for.
        :param times: A list of ranges specifying the time periods that the time interval should apply for.
        :param time_zone: A string that matches a location in the IANA time zone database. For example, 'Australia/Sydney'. The location provides the time zone for the time interval. You may also use ``Local`` as a location to use the local time of the machine where Alertmanager is running, or ``UTC`` for UTC time. If no timezone is provided, the time interval is taken to be in UTC time.
        :param weekdays: A list of ranges specifying the weekdays that the time interval should apply for.
        :param years: A list of ranges specifying the years that the time interval should apply for.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b9a052b5276ad2d7a5e17508242117f2139addbf7c5d45e520ea340923e66db)
            check_type(argname="argument days_of_the_month", value=days_of_the_month, expected_type=type_hints["days_of_the_month"])
            check_type(argname="argument months", value=months, expected_type=type_hints["months"])
            check_type(argname="argument times", value=times, expected_type=type_hints["times"])
            check_type(argname="argument time_zone", value=time_zone, expected_type=type_hints["time_zone"])
            check_type(argname="argument weekdays", value=weekdays, expected_type=type_hints["weekdays"])
            check_type(argname="argument years", value=years, expected_type=type_hints["years"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if days_of_the_month is not None:
            self._values["days_of_the_month"] = days_of_the_month
        if months is not None:
            self._values["months"] = months
        if times is not None:
            self._values["times"] = times
        if time_zone is not None:
            self._values["time_zone"] = time_zone
        if weekdays is not None:
            self._values["weekdays"] = weekdays
        if years is not None:
            self._values["years"] = years

    @builtins.property
    def days_of_the_month(self) -> typing.Optional[typing.List[DayOfMonthRange]]:
        '''A list of ranges specifying the days of the month that the time interval should apply for.'''
        result = self._values.get("days_of_the_month")
        return typing.cast(typing.Optional[typing.List[DayOfMonthRange]], result)

    @builtins.property
    def months(self) -> typing.Optional[typing.List[MonthRange]]:
        '''A list of ranges specifying the months that the time interval should apply for.'''
        result = self._values.get("months")
        return typing.cast(typing.Optional[typing.List[MonthRange]], result)

    @builtins.property
    def times(self) -> typing.Optional[typing.List["TimeRange"]]:
        '''A list of ranges specifying the time periods that the time interval should apply for.'''
        result = self._values.get("times")
        return typing.cast(typing.Optional[typing.List["TimeRange"]], result)

    @builtins.property
    def time_zone(self) -> typing.Optional[builtins.str]:
        '''A string that matches a location in the IANA time zone database.

        For example, 'Australia/Sydney'. The location provides the time zone for
        the time interval.

        You may also use ``Local`` as a location to use the local time of the
        machine where Alertmanager is running, or ``UTC`` for UTC time. If no
        timezone is provided, the time interval is taken to be in UTC time.
        '''
        result = self._values.get("time_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def weekdays(self) -> typing.Optional[typing.List["WeekdayRange"]]:
        '''A list of ranges specifying the weekdays that the time interval should apply for.'''
        result = self._values.get("weekdays")
        return typing.cast(typing.Optional[typing.List["WeekdayRange"]], result)

    @builtins.property
    def years(self) -> typing.Optional[typing.List["YearRange"]]:
        '''A list of ranges specifying the years that the time interval should apply for.'''
        result = self._values.get("years")
        return typing.cast(typing.Optional[typing.List["YearRange"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TimeIntervalEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.TimeIntervalProps",
    jsii_struct_bases=[],
    name_mapping={"intervals": "intervals", "name": "name"},
)
class TimeIntervalProps:
    def __init__(
        self,
        *,
        intervals: typing.Optional[typing.Sequence[TimeIntervalEntry]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the alert manager time interval.

        :param intervals: The interval definitions that define the periods of time that the time interval should apply for.
        :param name: The name of the time interval as it will be referenced throught the rest of the alert manager configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8603e1f17ec7b04585cebbc930584db9fd11d9cc78cbe34150554df2d35cbd25)
            check_type(argname="argument intervals", value=intervals, expected_type=type_hints["intervals"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if intervals is not None:
            self._values["intervals"] = intervals
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def intervals(self) -> typing.Optional[typing.List[TimeIntervalEntry]]:
        '''The interval definitions that define the periods of time that the time interval should apply for.'''
        result = self._values.get("intervals")
        return typing.cast(typing.Optional[typing.List[TimeIntervalEntry]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the time interval as it will be referenced throught the rest of the alert manager configuration.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TimeIntervalProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.TimeRange",
    jsii_struct_bases=[],
    name_mapping={"end": "end", "start": "start"},
)
class TimeRange:
    def __init__(self, *, end: builtins.str, start: builtins.str) -> None:
        '''Ranges inclusive of the starting time and exclusive of the end time to make it easy to represent times that start/end on hour boundaries.

        For example, ``start: '17:00'`` and ``end: '24:00'`` will begin at 17:00 and
        finish immediately before 24:00.

        :param end: The end time, specified in the format 'HH:MM' using 24 hour time.
        :param start: The start time, specified in the format 'HH:MM' using 24 hour time.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a478e81798d1b1aa822391d01c77ed9284d33226685ee1b6d5d1275aa07bf8e0)
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "end": end,
            "start": start,
        }

    @builtins.property
    def end(self) -> builtins.str:
        '''The end time, specified in the format 'HH:MM' using 24 hour time.'''
        result = self._values.get("end")
        assert result is not None, "Required property 'end' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def start(self) -> builtins.str:
        '''The start time, specified in the format 'HH:MM' using 24 hour time.'''
        result = self._values.get("start")
        assert result is not None, "Required property 'start' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TimeRange(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-extensions.aps.Weekday")
class Weekday(enum.Enum):
    '''The days of the week to be used in Prometheus alert manager configurations.'''

    SUNDAY = "SUNDAY"
    '''Sunday.'''
    MONDAY = "MONDAY"
    '''Monday.'''
    TUESDAY = "TUESDAY"
    '''Tuesday.'''
    WEDNESDAY = "WEDNESDAY"
    '''Wednesday.'''
    THURSDAY = "THURSDAY"
    '''Thursday.'''
    FRIDAY = "FRIDAY"
    '''Friday.'''
    SATURDAY = "SATURDAY"
    '''Saturday.'''


@jsii.data_type(
    jsii_type="cdk-extensions.aps.WeekdayRange",
    jsii_struct_bases=[],
    name_mapping={"start": "start", "end": "end"},
)
class WeekdayRange:
    def __init__(self, *, start: Weekday, end: typing.Optional[Weekday] = None) -> None:
        '''A day of the week, where the week begins on Sunday and ends on Saturday.

        For convenience, ranges are also accepted by specifying ``end`` and are
        inclusive on both ends.

        :param start: The day of the week where the range should start.
        :param end: The day of the week where the range should end. If not specified, the range will end at the end of the day specified by ``start``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86465e2768ad1762de08be5c9445cf1547774e8347024696fa86d083e0fa4890)
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "start": start,
        }
        if end is not None:
            self._values["end"] = end

    @builtins.property
    def start(self) -> Weekday:
        '''The day of the week where the range should start.'''
        result = self._values.get("start")
        assert result is not None, "Required property 'start' is missing"
        return typing.cast(Weekday, result)

    @builtins.property
    def end(self) -> typing.Optional[Weekday]:
        '''The day of the week where the range should end.

        If not specified, the range will end at the end of the day specified by
        ``start``.
        '''
        result = self._values.get("end")
        return typing.cast(typing.Optional[Weekday], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WeekdayRange(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IWorkspace)
class Workspace(
    _aws_cdk_ceddda9d.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.Workspace",
):
    '''Represents an Amazon Managed Service for Prometheus workspace.

    A *workspace* is a logical and isolated Prometheus server dedicated to
    Prometheus resources such as metrics.

    You can have one or more workspaces in each Region in your account.

    :see: `AWS::APS::Workspace <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-workspace.html#aws-resource-aps-workspace-return-values>`_
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        alerting: typing.Optional[typing.Union["WorkspaceAlertingOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        alias: typing.Optional[builtins.str] = None,
        logging: typing.Optional[typing.Union["WorkspaceLoggingOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the Workspace class.

        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param alerting: The details used to configure alerting for the APS workspace.
        :param alias: An alias that you assign to this workspace to help you identify it. It does not need to be unique. The alias can be as many as 100 characters and can include any type of characters.
        :param logging: The details used for configuring logging for the APS workspace.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d4fe17b3dcb4a6fcb28440fce03e66af5d9404414495492548dd6c3f19c756f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = WorkspaceProps(
            alerting=alerting,
            alias=alias,
            logging=logging,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromWorkspaceArn")
    @builtins.classmethod
    def from_workspace_arn(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        workspace_arn: builtins.str,
    ) -> IWorkspace:
        '''Imports an existing APS workspace by specifying its Amazon Resource Name (ARN).

        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param workspace_arn: The ARN of the existing APS workspace to be imported.

        :return: An object representing the imported APS workspace.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afa461fdd8ffaa5089542c8bf8787f44409787b6a210b3c5c0662d5b35109c72)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument workspace_arn", value=workspace_arn, expected_type=type_hints["workspace_arn"])
        return typing.cast(IWorkspace, jsii.sinvoke(cls, "fromWorkspaceArn", [scope, id, workspace_arn]))

    @jsii.member(jsii_name="fromWorkspaceAttributes")
    @builtins.classmethod
    def from_workspace_attributes(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        workspace_arn: typing.Optional[builtins.str] = None,
        workspace_id: typing.Optional[builtins.str] = None,
        workspace_prometheus_endpoint: typing.Optional[builtins.str] = None,
    ) -> IWorkspace:
        '''Imports an existing APS workspace by explicitly specifying its attributes.

        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param workspace_arn: The Amazon Resource Name (ARN) of the APS workspace.
        :param workspace_id: The ID generated by AWS for the APS workspace.
        :param workspace_prometheus_endpoint: The Prometheus endpoint attribute of the workspace. This is the endpoint prefix without the remote_write or query API appended.

        :return: An object representing the imported APS workspace.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60d3199171f1bba437b7d6cbc7eaac9b468af9758e4842e4fa533d977f1acf88)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        attrs = WorkspaceAttributes(
            workspace_arn=workspace_arn,
            workspace_id=workspace_id,
            workspace_prometheus_endpoint=workspace_prometheus_endpoint,
        )

        return typing.cast(IWorkspace, jsii.sinvoke(cls, "fromWorkspaceAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="fromWorkspaceId")
    @builtins.classmethod
    def from_workspace_id(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        workspace_id: builtins.str,
    ) -> IWorkspace:
        '''Imports an existing APS workspace by explicitly specifying its AWS generated ID.

        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param workspace_id: The AWS generated ID of the existing APS workspace to be imported.

        :return: An object representing the imported APS workspace.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcec950a457d984707468fd097b56417f7911b7a161b7157e77c9a693054a2dc)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument workspace_id", value=workspace_id, expected_type=type_hints["workspace_id"])
        return typing.cast(IWorkspace, jsii.sinvoke(cls, "fromWorkspaceId", [scope, id, workspace_id]))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> _aws_cdk_aws_aps_ceddda9d.CfnWorkspace:
        '''The underlying Workspace CloudFormation resource.

        :see: `AWS::APS::Workspace <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-workspace.html>`_
        :group: Resources
        '''
        return typing.cast(_aws_cdk_aws_aps_ceddda9d.CfnWorkspace, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="workspaceArn")
    def workspace_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the APS workspace.'''
        return typing.cast(builtins.str, jsii.get(self, "workspaceArn"))

    @builtins.property
    @jsii.member(jsii_name="workspaceId")
    def workspace_id(self) -> builtins.str:
        '''The ID generated by AWS for the APS workspace.'''
        return typing.cast(builtins.str, jsii.get(self, "workspaceId"))

    @builtins.property
    @jsii.member(jsii_name="workspacePrometheusEndpoint")
    def workspace_prometheus_endpoint(self) -> builtins.str:
        '''The Prometheus endpoint attribute of the workspace.

        This is the endpoint prefix without the remote_write or query API
        appended.
        '''
        return typing.cast(builtins.str, jsii.get(self, "workspacePrometheusEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="workspaceQueryUrl")
    def workspace_query_url(self) -> builtins.str:
        '''The URL of the remote write endpoint which can be used to ingest metrics into the Prometheus workspace.'''
        return typing.cast(builtins.str, jsii.get(self, "workspaceQueryUrl"))

    @builtins.property
    @jsii.member(jsii_name="workspaceRemoteWriteUrl")
    def workspace_remote_write_url(self) -> builtins.str:
        '''The URL of the endpoint that other services can use to query the workspace.'''
        return typing.cast(builtins.str, jsii.get(self, "workspaceRemoteWriteUrl"))

    @builtins.property
    @jsii.member(jsii_name="alerting")
    def alerting(self) -> typing.Optional["WorkspaceAlertingOptions"]:
        '''The details used to configure alerting for the APS workspace.

        :see: `Workspace AlertManagerDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-workspace.html#cfn-aps-workspace-alertmanagerdefinition>`_
        :group: Inputs
        '''
        return typing.cast(typing.Optional["WorkspaceAlertingOptions"], jsii.get(self, "alerting"))

    @builtins.property
    @jsii.member(jsii_name="alertManagerConfiguration")
    def alert_manager_configuration(
        self,
    ) -> typing.Optional["AlertManagerConfiguration"]:
        '''The configuration contolling how alerts are sent for the workspace.

        Only
        available when alerting is enabled and the default alerting configuration
        is used.

        :group: Resources
        '''
        return typing.cast(typing.Optional["AlertManagerConfiguration"], jsii.get(self, "alertManagerConfiguration"))

    @builtins.property
    @jsii.member(jsii_name="alertTopic")
    def alert_topic(self) -> typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic]:
        '''The SNS topic where alerts generated by the workspace will be sent.

        Only
        set if alerting is enabled and the default alert manager configuration is
        used.

        :group: Resources
        '''
        return typing.cast(typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic], jsii.get(self, "alertTopic"))

    @builtins.property
    @jsii.member(jsii_name="alias")
    def alias(self) -> typing.Optional[builtins.str]:
        '''An alias that you assign to this workspace to help you identify it. It does not need to be unique.

        The alias can be as many as 100 characters and can include any type of
        characters.

        :see: `Workspace Alias <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-workspace.html#cfn-aps-workspace-alias>`_
        :group: Inputs
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "alias"))

    @builtins.property
    @jsii.member(jsii_name="logging")
    def logging(self) -> typing.Optional["WorkspaceLoggingOptions"]:
        '''The details used for configuring logging for the APS workspace.

        :see: `Workspace LoggingConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-workspace.html#cfn-aps-workspace-loggingconfiguration>`_
        :group: Inputs
        '''
        return typing.cast(typing.Optional["WorkspaceLoggingOptions"], jsii.get(self, "logging"))

    @builtins.property
    @jsii.member(jsii_name="logGroup")
    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
        '''The CloudWatch log group where logs emitted by the APS workspace will be sent.

        :group: Resources
        '''
        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], jsii.get(self, "logGroup"))


@jsii.data_type(
    jsii_type="cdk-extensions.aps.WorkspaceAlertingOptions",
    jsii_struct_bases=[],
    name_mapping={
        "configuration": "configuration",
        "enabled": "enabled",
        "topic": "topic",
    },
)
class WorkspaceAlertingOptions:
    def __init__(
        self,
        *,
        configuration: typing.Optional[IAlertManagerConfiguration] = None,
        enabled: typing.Optional[builtins.bool] = None,
        topic: typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic] = None,
    ) -> None:
        '''Alerting configuration to use when setting up an APS workspace.

        :param configuration: The alert manager configuration to use when setting up alerting. If alerting is enabled and no configuration is given a default configuration that sends all alerts to SNS will be used.
        :param enabled: Controls whether alerting from the APS workspace should be configured. Default: true
        :param topic: The SNS topic where alerts should be sent when using the default alerting configuration. If a custom alert manager configuration is provided this option is ignored.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__785388ec7bcbf0f9ab3ab8d3ff617f372c2690129c81568a2e9b707017a6ccba)
            check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if configuration is not None:
            self._values["configuration"] = configuration
        if enabled is not None:
            self._values["enabled"] = enabled
        if topic is not None:
            self._values["topic"] = topic

    @builtins.property
    def configuration(self) -> typing.Optional[IAlertManagerConfiguration]:
        '''The alert manager configuration to use when setting up alerting.

        If alerting is enabled and no configuration is given a default
        configuration that sends all alerts to SNS will be used.
        '''
        result = self._values.get("configuration")
        return typing.cast(typing.Optional[IAlertManagerConfiguration], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Controls whether alerting from the APS workspace should be configured.

        :default: true
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def topic(self) -> typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic]:
        '''The SNS topic where alerts should be sent when using the default alerting configuration.

        If a custom alert manager configuration is provided this option is ignored.
        '''
        result = self._values.get("topic")
        return typing.cast(typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WorkspaceAlertingOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.WorkspaceAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "workspace_arn": "workspaceArn",
        "workspace_id": "workspaceId",
        "workspace_prometheus_endpoint": "workspacePrometheusEndpoint",
    },
)
class WorkspaceAttributes:
    def __init__(
        self,
        *,
        workspace_arn: typing.Optional[builtins.str] = None,
        workspace_id: typing.Optional[builtins.str] = None,
        workspace_prometheus_endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for importing an existing APS workspace.

        :param workspace_arn: The Amazon Resource Name (ARN) of the APS workspace.
        :param workspace_id: The ID generated by AWS for the APS workspace.
        :param workspace_prometheus_endpoint: The Prometheus endpoint attribute of the workspace. This is the endpoint prefix without the remote_write or query API appended.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de63c6dc380e32c73a45d718b8f3ba6478137a376ad09fda3e0ec44d51707450)
            check_type(argname="argument workspace_arn", value=workspace_arn, expected_type=type_hints["workspace_arn"])
            check_type(argname="argument workspace_id", value=workspace_id, expected_type=type_hints["workspace_id"])
            check_type(argname="argument workspace_prometheus_endpoint", value=workspace_prometheus_endpoint, expected_type=type_hints["workspace_prometheus_endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if workspace_arn is not None:
            self._values["workspace_arn"] = workspace_arn
        if workspace_id is not None:
            self._values["workspace_id"] = workspace_id
        if workspace_prometheus_endpoint is not None:
            self._values["workspace_prometheus_endpoint"] = workspace_prometheus_endpoint

    @builtins.property
    def workspace_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the APS workspace.'''
        result = self._values.get("workspace_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def workspace_id(self) -> typing.Optional[builtins.str]:
        '''The ID generated by AWS for the APS workspace.'''
        result = self._values.get("workspace_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def workspace_prometheus_endpoint(self) -> typing.Optional[builtins.str]:
        '''The Prometheus endpoint attribute of the workspace.

        This is the endpoint prefix without the remote_write or query API
        appended.
        '''
        result = self._values.get("workspace_prometheus_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WorkspaceAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.WorkspaceLoggingOptions",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "log_group": "logGroup",
        "retention": "retention",
    },
)
class WorkspaceLoggingOptions:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
        retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
    ) -> None:
        '''Logging configuration to use when setting up the APS workspace.

        :param enabled: Controls whether logging for the workspace should be enabled. Default: true
        :param log_group: The log group where events from the APS workspace will be written. If logging is enabled and no log group is provided a new log group will be created.
        :param retention: The length of time that logs from the APS workspace should be kept when a new log group is created for the workspace. This property is ignored when a log group is passed as part of the logging configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24a9a09d43dc6b752a83864df6b27f540223390dc4b583d3187a8d73528a9c81)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
            check_type(argname="argument retention", value=retention, expected_type=type_hints["retention"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if log_group is not None:
            self._values["log_group"] = log_group
        if retention is not None:
            self._values["retention"] = retention

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Controls whether logging for the workspace should be enabled.

        :default: true
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
        '''The log group where events from the APS workspace will be written.

        If logging is enabled and no log group is provided a new log group will be
        created.

        :see: `Workspace LoggingConfiguration.LogGroupArn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aps-workspace-loggingconfiguration.html#cfn-aps-workspace-loggingconfiguration-loggrouparn>`_
        '''
        result = self._values.get("log_group")
        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)

    @builtins.property
    def retention(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays]:
        '''The length of time that logs from the APS workspace should be kept when a new log group is created for the workspace.

        This property is ignored when a log group is passed as part of the logging
        configuration.

        :see: `LogGroup RetentionInDays <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html#cfn-logs-loggroup-retentionindays>`_
        '''
        result = self._values.get("retention")
        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WorkspaceLoggingOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.WorkspaceProps",
    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "alerting": "alerting",
        "alias": "alias",
        "logging": "logging",
    },
)
class WorkspaceProps(_aws_cdk_ceddda9d.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        alerting: typing.Optional[typing.Union[WorkspaceAlertingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        alias: typing.Optional[builtins.str] = None,
        logging: typing.Optional[typing.Union[WorkspaceLoggingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Configuration for the Workspace resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param alerting: The details used to configure alerting for the APS workspace.
        :param alias: An alias that you assign to this workspace to help you identify it. It does not need to be unique. The alias can be as many as 100 characters and can include any type of characters.
        :param logging: The details used for configuring logging for the APS workspace.
        '''
        if isinstance(alerting, dict):
            alerting = WorkspaceAlertingOptions(**alerting)
        if isinstance(logging, dict):
            logging = WorkspaceLoggingOptions(**logging)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__663c8a2d4f00790605fbddeaa792adad5f229661503aead0b438ae668c8f2707)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument alerting", value=alerting, expected_type=type_hints["alerting"])
            check_type(argname="argument alias", value=alias, expected_type=type_hints["alias"])
            check_type(argname="argument logging", value=logging, expected_type=type_hints["logging"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if alerting is not None:
            self._values["alerting"] = alerting
        if alias is not None:
            self._values["alias"] = alias
        if logging is not None:
            self._values["logging"] = logging

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alerting(self) -> typing.Optional[WorkspaceAlertingOptions]:
        '''The details used to configure alerting for the APS workspace.

        :see: `Workspace AlertManagerDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-workspace.html#cfn-aps-workspace-alertmanagerdefinition>`_
        '''
        result = self._values.get("alerting")
        return typing.cast(typing.Optional[WorkspaceAlertingOptions], result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''An alias that you assign to this workspace to help you identify it. It does not need to be unique.

        The alias can be as many as 100 characters and can include any type of
        characters.

        :see: `Workspace Alias <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-workspace.html#cfn-aps-workspace-alias>`_
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def logging(self) -> typing.Optional[WorkspaceLoggingOptions]:
        '''The details used for configuring logging for the APS workspace.

        :see: `Workspace LoggingConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-aps-workspace.html#cfn-aps-workspace-loggingconfiguration>`_
        '''
        result = self._values.get("logging")
        return typing.cast(typing.Optional[WorkspaceLoggingOptions], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WorkspaceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.aps.YearRange",
    jsii_struct_bases=[],
    name_mapping={"start": "start", "end": "end"},
)
class YearRange:
    def __init__(
        self,
        *,
        start: jsii.Number,
        end: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''A numerical range of years.

        Ranges to cover multiple years are accepted. For example, ``start: 2020`` and
        ``end: 2022``.

        Inclusive on both ends.

        :param start: The year where the range should start.
        :param end: The year where the range should end. If not specified, the range will end at the end of the year specified by ``start``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e67ac46d92395cb103d8b149352cf8ca374366ffdec5acce0742f53cae4b5905)
            check_type(argname="argument start", value=start, expected_type=type_hints["start"])
            check_type(argname="argument end", value=end, expected_type=type_hints["end"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "start": start,
        }
        if end is not None:
            self._values["end"] = end

    @builtins.property
    def start(self) -> jsii.Number:
        '''The year where the range should start.'''
        result = self._values.get("start")
        assert result is not None, "Required property 'start' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def end(self) -> typing.Optional[jsii.Number]:
        '''The year where the range should end.

        If not specified, the range will end at the end of the year specified by
        ``start``.
        '''
        result = self._values.get("end")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "YearRange(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IAlertManagerConfiguration)
class AlertManagerConfiguration(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerConfiguration",
):
    '''Represents a Prometheus alert manager configuration that can be used by Amazon APS to send generated alerts to one or more destinations.

    Currently
    the only destination type supported by APS is Amazon SNS.

    :see: `Alert manager configuration specification <https://prometheus.io/docs/alerting/latest/configuration/>`_
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        default_receiver_destinations: typing.Optional[typing.Sequence[IAlertManagerDestination]] = None,
        default_route: typing.Optional[typing.Union[DefaultRouteOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        templates: typing.Optional[typing.Sequence[AlertManagerTemplate]] = None,
    ) -> None:
        '''Creates a new instance of the AlertManagerConfiguration class.

        :param scope: A CDK Construct that will serve as this construct's parent in the construct tree.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param default_receiver_destinations: Destinations where all alerts generated by APS should be sent. If this property is not a provided, a new default topic will be created to receive notifications. If a default topic is not desired (such as in cases where topics will be registered dynamically later in the build) an empty list can be provided. This will result in the default topic not being created an no destinations being configured for the default receiver. Note that the default receiver requires at least one destination to be registered, so if the default topic is skipped and no destinations are provided here, at least one destination *must* be registered for the default route before the CDK app is synthed.
        :param default_route: Options for configuring the behavior of the default route that gets created for alerts. The default route for alert manager does not support all options allowed by child routes.
        :param templates: Collection of templates to make available to alert manager. The templates are available to be referenced in any field that supports templating by using the ``template`` templating function and referencing the name of the template as defined in the template content with the ``define`` keyword.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d99bacfb04fe2086f72d8d29d7cf1687579f214b60ec543eb642086389a30ca8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AlertManagerConfigurationProps(
            default_receiver_destinations=default_receiver_destinations,
            default_route=default_route,
            templates=templates,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromFullConfigurationContent")
    @builtins.classmethod
    def from_full_configuration_content(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        content: builtins.str,
    ) -> IAlertManagerConfiguration:
        '''Imports an alert manager configuration from a raw string in the format expected by Amazon APS.

        The string should combine both the alert manager configuration and the
        alert template content into a single file. To import a configuration that
        has the alert manager configuration and templates being loaded from
        different files/sources use {@link fromSplitConfigurationContent} instead.

        :param scope: The construct handling the configuration of alert manager that will consume the rendered configuration.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param content: A YAML formatted string specifying the alert manager configuration as expected by Amazon APS.

        :return: An object that can be used to configure alert manager for APS.

        :see: `Alert manager configuration specification <https://prometheus.io/docs/alerting/latest/configuration/>`_
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7590ce082c23f9f92412fd7bb9722718830f68a4fc8a172422ef5634d3bf472f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
        return typing.cast(IAlertManagerConfiguration, jsii.sinvoke(cls, "fromFullConfigurationContent", [scope, id, content]))

    @jsii.member(jsii_name="fromFullConfigurationFile")
    @builtins.classmethod
    def from_full_configuration_file(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        path: builtins.str,
    ) -> IAlertManagerConfiguration:
        '''Imports an alert manager configuration using a file in the format expected by Amazon APS.

        The file should combine both the alert manager configuration and the alert
        template content into a single file. To import a configuration that has
        the alert manager configuration and templates being loaded from different
        files/sources use {@link fromSplitConfigurationFiles} instead.

        :param scope: The construct handling the configuration of alert manager that will consume the rendered configuration.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param path: The path to the file containing the APS alert manager configuration.

        :return: An object that can be used to configure alert manager for APS.

        :see: `Alert manager configuration specification <https://prometheus.io/docs/alerting/latest/configuration/>`_
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5644b887e48459dd08983e2e62f6ccb8df573b33e4ea7d0d3af42ca8a6820eb3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
        return typing.cast(IAlertManagerConfiguration, jsii.sinvoke(cls, "fromFullConfigurationFile", [scope, id, path]))

    @jsii.member(jsii_name="fromSplitConfigurationContent")
    @builtins.classmethod
    def from_split_configuration_content(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        content: builtins.str,
        templates: typing.Optional[typing.Mapping[builtins.str, AlertManagerTemplate]] = None,
    ) -> IAlertManagerConfiguration:
        '''Imports an alert manager configuration from a raw string.

        The string should be in YAML format and follow the alert manager
        configuration specifications. To import a configuration using a string
        that combines the alert manager configuration with the template content
        that is already in the format expected by Amazon APS use the import method
        {@link fromFullConfigurationContent} instead.

        If the configuration references any templates then each template the
        configuration references should be specified using the ``templates``
        argument. Templates can be read from their own separate files on disk or
        as a string.

        :param scope: The construct handling the configuration of alert manager that will consume the rendered configuration.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param content: A YAML formatted string specifying the alert manager configuration.
        :param templates: The templates referenced by the imported configuration.

        :return: An object that can be used to configure alert manager for APS.

        :see: `Alert manager configuration specification <https://prometheus.io/docs/alerting/latest/configuration/>`_
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3eb236168a9b336359213312200f3f2c2e6cd77e1d8e533383717856a3c8280)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
            check_type(argname="argument templates", value=templates, expected_type=type_hints["templates"])
        return typing.cast(IAlertManagerConfiguration, jsii.sinvoke(cls, "fromSplitConfigurationContent", [scope, id, content, templates]))

    @jsii.member(jsii_name="fromSplitConfigurationFiles")
    @builtins.classmethod
    def from_split_configuration_files(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        path: builtins.str,
        templates: typing.Optional[typing.Mapping[builtins.str, AlertManagerTemplate]] = None,
    ) -> IAlertManagerConfiguration:
        '''Imports an alert manager configuration from a file.

        The file is a YAML file that follows the alert manager configuration
        specifications. To import a configuration file that combines the alert
        manager configuration with the template content that is already in the
        format expected by Amazon APS use the import method
        {@link fromFullConfigurationFile} instead.

        If the configuration references any templates then each template the
        configuration references should be specified using the ``templates``
        argument. Templates can be read from their own separate files on disk or
        as a string.

        :param scope: The construct handling the configuration of alert manager that will consume the rendered configuration.
        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
        :param path: The path to the file containing the alert manager specification.
        :param templates: The templates referenced by the imported configuration.

        :return: An object that can be used to configure alert manager for APS.

        :see: `Alert manager configuration specification <https://prometheus.io/docs/alerting/latest/configuration/>`_
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94861ea3498df012fb4fd59d621881e412e689c5af1369bfb7475cc9ca6a1617)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument templates", value=templates, expected_type=type_hints["templates"])
        return typing.cast(IAlertManagerConfiguration, jsii.sinvoke(cls, "fromSplitConfigurationFiles", [scope, id, path, templates]))

    @jsii.member(jsii_name="addInhibitRule")
    def add_inhibit_rule(
        self,
        id: builtins.str,
        options: AlertManagerInhibitRuleProps,
    ) -> AlertManagerInhibitRule:
        '''Adds a new inhibit rule that can mute alerts under specific circumstances.

        :param id: Unique identifier for the inhibit rule.
        :param options: Details for the rule being created.

        :return: The inhibit rule that was added to the configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ca33998aedce1484077babe630881aadd29b719b058906d2828527212f81b59)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
        return typing.cast(AlertManagerInhibitRule, jsii.invoke(self, "addInhibitRule", [id, options]))

    @jsii.member(jsii_name="addReciever")
    def add_reciever(
        self,
        id: builtins.str,
        *,
        destinations: typing.Optional[typing.Sequence[IAlertManagerDestination]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> AlertManagerReceiver:
        '''Adds a new receiver to the configuration.

        The receiver can be used to
        specify one or more destinations where alerts should be sent when matched
        by a route in the routing tree.

        :param id: Unique identifier for the receiver.
        :param destinations: Details for alerting providers where events routed to this receiver should be sent,.
        :param name: The name of the receiver which can be referenced in the other parts of the configuration.

        :return: The receiver that was added to the configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4a68231caa2ea4791a5e35d7a6f666d830732ee8b74e95e1bf7389bf85fa76d)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = AlertManagerReceiverProps(destinations=destinations, name=name)

        return typing.cast(AlertManagerReceiver, jsii.invoke(self, "addReciever", [id, options]))

    @jsii.member(jsii_name="addTemplate")
    def add_template(
        self,
        template: AlertManagerTemplate,
    ) -> IAlertManagerConfiguration:
        '''Adds a new template to the configuration.

        The template can be referenced
        within the configuration to control the formatting of the alerts being sent.

        :param template: The template to add to the configuration.

        :return: The configuration object where the template was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d849fe7881e1b468a18638fa7ec3eb6f1a50dbef0bcfc71457bdf7c943e78ad)
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        return typing.cast(IAlertManagerConfiguration, jsii.invoke(self, "addTemplate", [template]))

    @jsii.member(jsii_name="addTimeInterval")
    def add_time_interval(
        self,
        id: builtins.str,
        *,
        intervals: typing.Optional[typing.Sequence[TimeIntervalEntry]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> TimeInterval:
        '''Adds a new time interval to the configuration.

        Time intervals can be used
        to mute or activate groups of alerts under specific circumstances.

        Time intervals are referenced by routes in the routing tree to control the
        behavior of the route. Time intervals to mute or activate alerts cannot be
        added to the default route.

        :param id: Unique identifier for the time interval.
        :param intervals: The interval definitions that define the periods of time that the time interval should apply for.
        :param name: The name of the time interval as it will be referenced throught the rest of the alert manager configuration.

        :return: The time interval that was added to the configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44d7a0caf75da1abb6088e5a940d0e0be3c1491d2bfd14e771b111c0904826d5)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = TimeIntervalProps(intervals=intervals, name=name)

        return typing.cast(TimeInterval, jsii.invoke(self, "addTimeInterval", [id, options]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> AlertManagerConfigurationDetails:
        '''Associates the configuration with a construct that is handling the configuration of alert manager for an APS workspace.

        :param scope: The construct handling the configuration of alert manager that will consume the configuration.

        :return: Alert manager configuration details.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a991a76bb93d481d93df85fb2dc0abb33b67a52a57a97a03c1e4435ebcb05db6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(AlertManagerConfigurationDetails, jsii.invoke(self, "bind", [scope]))

    @jsii.member(jsii_name="generateTemplateName")
    def _generate_template_name(self, idx: jsii.Number) -> builtins.str:
        '''Generates a unique name for a template that is being referenced by the alert manager configuration.

        The names are only used to distinguish different templates as internally
        each template is saved to a file with this name.

        Knowing the name is not needed to use the templates as template references
        rely on the name given to the ``define`` keyword in the template content
        itself rather than the name of the template as it is generated here.

        :param idx: The index of the template to generate a name for.

        :return: A unique name for the template.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17cdb5aa4b7ef9c8b35c69241804e8c73b44275b1a10f27a8031003e52fb0a95)
            check_type(argname="argument idx", value=idx, expected_type=type_hints["idx"])
        return typing.cast(builtins.str, jsii.invoke(self, "generateTemplateName", [idx]))

    @jsii.member(jsii_name="renderAlertManagerConfig")
    def _render_alert_manager_config(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> builtins.str:
        '''Renders an alert manager configuration to be used for configuring notifications on an APS workspace.

        :param scope: The construct that is handling the configuration of alert manager.

        :return:

        The string representation of the rendered Prometheus alert
        manager configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6fae02e5bd92b712b79c9fa8c6782f6bd95170c1e8ac0e74a055dd7a4c2a24c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(builtins.str, jsii.invoke(self, "renderAlertManagerConfig", [scope]))

    @jsii.member(jsii_name="renderTemplates")
    def _render_templates(
        self,
        _scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Renders the configuration templates into the structure that is expected for an APS workspace alert manager configuration.

        :param _scope: The construct that is handling the configuration of alert manager.

        :return:

        An object that represents the templates contained in this
        configuration or undefined if the configuration has no templates.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b38cc1bfd7f0a346b16ec49add36b40783575a9cd7dce2517a2cacf55acaaa66)
            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.invoke(self, "renderTemplates", [_scope]))

    @builtins.property
    @jsii.member(jsii_name="defaultReceiver")
    def default_receiver(self) -> AlertManagerReceiver:
        '''The receiver configuring the destinations where all alerts that are not matched by a child route in the routing tree will be sent.

        :see: `Receiver Official Documentation <https://prometheus.io/docs/alerting/latest/configuration/#receiver>`_
        :group: Resources
        '''
        return typing.cast(AlertManagerReceiver, jsii.get(self, "defaultReceiver"))

    @builtins.property
    @jsii.member(jsii_name="defaultRoute")
    def default_route(self) -> AlertManagerRoute:
        '''The default root route withing the routing tree.

        Serves as the default
        configuration for all alerts. Sends alerts to the default receiver.

        Must match all alerts and cannot be muted or deactivated. To add more
        advanced configurations create additional routes as children of the
        default route.

        :see: `Route OfficialDocumentation <https://prometheus.io/docs/alerting/latest/configuration/#route>`_
        :group: Resources
        '''
        return typing.cast(AlertManagerRoute, jsii.get(self, "defaultRoute"))

    @builtins.property
    @jsii.member(jsii_name="inhibitRules")
    def inhibit_rules(self) -> typing.List[AlertManagerInhibitRule]:
        '''Collection of inhibit rules that mute an alert under scecific sets of circumstances.

        :see: `Inhibit Rule Official Documentation <https://prometheus.io/docs/alerting/latest/configuration/#inhibit_rule>`_
        :group: Resource
        '''
        return typing.cast(typing.List[AlertManagerInhibitRule], jsii.get(self, "inhibitRules"))

    @builtins.property
    @jsii.member(jsii_name="receivers")
    def receivers(self) -> typing.List[AlertManagerReceiver]:
        '''Collection of notification integrations that provide the details for how and where generated alerts should be sent.

        :see: `Receiver Official Documentation <https://prometheus.io/docs/alerting/latest/configuration/#inhibit_rule>`_
        :group: Resources
        '''
        return typing.cast(typing.List[AlertManagerReceiver], jsii.get(self, "receivers"))

    @builtins.property
    @jsii.member(jsii_name="templates")
    def templates(self) -> typing.List[AlertManagerTemplate]:
        '''Collection of alert manager templates that the configuration uses to format the alerts that it sends.

        :group: Inputs
        '''
        return typing.cast(typing.List[AlertManagerTemplate], jsii.get(self, "templates"))

    @builtins.property
    @jsii.member(jsii_name="timeIntervals")
    def time_intervals(self) -> typing.List[TimeInterval]:
        '''Collection of timing configurations that can be used to control when specific alerts should be muted or activated.

        :see: `Time Interval Official Documentation <https://prometheus.io/docs/alerting/latest/configuration/#time_interval>`_
        :group: Resources
        '''
        return typing.cast(typing.List[TimeInterval], jsii.get(self, "timeIntervals"))

    @builtins.property
    @jsii.member(jsii_name="defaultTopic")
    def default_topic(self) -> typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic]:
        '''The topic that the default receiver will send messages to if no destinations are specified as inputs (input destinations are null/undefined).

        The creation of this topic can be skipped to allow the defferred
        configuration of default destination by providing an empty list of
        destinations as inputs.

        :group: Resources
        '''
        return typing.cast(typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic], jsii.get(self, "defaultTopic"))


@jsii.implements(IAlertManagerDestination)
class AlertManagerSnsDestination(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertManagerSnsDestination",
):
    '''An alert manager destination that provides details for sending alert notifications to an Amazon SNS topic.

    :see: `Alert manager SNS configuration <https://prometheus.io/docs/alerting/latest/configuration/#sns_config>`_
    '''

    def __init__(
        self,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        api_url: typing.Optional[builtins.str] = None,
        attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        message: typing.Optional[builtins.str] = None,
        send_resolved: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the AlertManagerSnsDestination class.

        :param topic: SNS topic where alerts will be sent. If you are using a FIFO SNS topic you should set a message group interval longer than 5 minutes to prevent messages with the same group key being deduplicated by the SNS default deduplication window.
        :param api_url: The SNS API URL i.e. https://sns.us-east-2.amazonaws.com. If not specified, the SNS API URL from the SNS SDK will be used.
        :param attributes: SNS message attributes.
        :param message: The message content of the SNS notification.
        :param send_resolved: Controls whether to notify about resolved alerts.
        :param subject: Subject line when the message is delivered to email endpoints.
        '''
        options = AlertManagerSnsDestinationProps(
            topic=topic,
            api_url=api_url,
            attributes=attributes,
            message=message,
            send_resolved=send_resolved,
            subject=subject,
        )

        jsii.create(self.__class__, self, [options])

    @jsii.member(jsii_name="addAttribute")
    def add_attribute(
        self,
        key: builtins.str,
        value: builtins.str,
    ) -> "AlertManagerSnsDestination":
        '''Registers a new attribute to be added to sent SNS messages.

        :param key: The name of the attribute.
        :param value: The value to use for the named attribute.

        :return: The sns destination object the attribute was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a30b40d9be3a465aff37f83c88abbc1c7d7a006d3218abb3ad1e5c53180bb13e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("AlertManagerSnsDestination", jsii.invoke(self, "addAttribute", [key, value]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the destination with a construct that is handling the configuration of alert manager.

        :param scope: The construct handling alert manager configuration.

        :return: An object representing the configured destination.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34fd2af53cf3a3f5bab86839cf37d48466d5cf78d1486a322588694114ce3065)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [scope]))

    @builtins.property
    @jsii.member(jsii_name="attributes")
    def attributes(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''Attributes to be applied to SNS messages.

        :group: Inputs
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "attributes"))

    @builtins.property
    @jsii.member(jsii_name="category")
    def category(self) -> AlertManagerDestinationCategory:
        '''The destination type being configured.

        Represents a config block in an alert manager receiver configuration.
        '''
        return typing.cast(AlertManagerDestinationCategory, jsii.get(self, "category"))

    @builtins.property
    @jsii.member(jsii_name="topic")
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''SNS topic where alerts will be sent.

        If you are using a FIFO SNS topic you should set a message group interval
        longer than 5 minutes to prevent messages with the same group key being
        deduplicated by the SNS default deduplication window.

        :group: Inputs
        '''
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, jsii.get(self, "topic"))

    @builtins.property
    @jsii.member(jsii_name="apiUrl")
    def api_url(self) -> typing.Optional[builtins.str]:
        '''The SNS API URL i.e. https://sns.us-east-2.amazonaws.com.

        If not specified, the SNS API URL from the SNS SDK will be used.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiUrl"))

    @builtins.property
    @jsii.member(jsii_name="message")
    def message(self) -> typing.Optional[builtins.str]:
        '''The message content of the SNS notification.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "message"))

    @builtins.property
    @jsii.member(jsii_name="sendResolved")
    def send_resolved(self) -> typing.Optional[builtins.bool]:
        '''Controls whether to notify about resolved alerts.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "sendResolved"))

    @builtins.property
    @jsii.member(jsii_name="subject")
    def subject(self) -> typing.Optional[builtins.str]:
        '''Subject line when the message is delivered to email endpoints.

        :groups: Inputs
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subject"))


@jsii.implements(IPrometheusRule)
class AlertingRule(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.aps.AlertingRule",
):
    '''Alerting rules allow you to define alert conditions based on Prometheus expression language expressions and to send notifications about firing alerts to an external service.

    Whenever the alert expression results in one
    or more vector elements at a given point in time, the alert counts as active
    for these elements' label sets.

    :see: `Alerting rules <https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/>`_
    '''

    def __init__(
        self,
        *,
        alert: builtins.str,
        expression: builtins.str,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''Creates a new instance of the AlertingRule class.

        :param alert: The name of the alert. Must be a valid label value.
        :param expression: The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
        :param annotations: Annotations to add to each alert. Supports templating.
        :param labels: Labels to add or overwrite for each alert.
        :param period: Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending.
        '''
        props = AlertingRuleProps(
            alert=alert,
            expression=expression,
            annotations=annotations,
            labels=labels,
            period=period,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="addAnnotation")
    def add_annotation(
        self,
        label: builtins.str,
        template: builtins.str,
    ) -> "AlertingRule":
        '''Sets a new annotation that will be added to each generated alert.

        :param label: The name of the annotation to add.
        :param template: The template that will be used to render the value of the annotation.

        :return: The alerting rule that the annotation was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__513b11e15a6b56a6363e5dfde3b9c7603ca5e60547c9a6c1b1277e282a113cfd)
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        return typing.cast("AlertingRule", jsii.invoke(self, "addAnnotation", [label, template]))

    @jsii.member(jsii_name="addLabel")
    def add_label(self, label: builtins.str, template: builtins.str) -> "AlertingRule":
        '''Sets a new label that will be added or overridden for each generated alert.

        :param label: The name of the label to add.
        :param template: The template that will be used to render the value of the label.

        :return: The alerting rule that the label was added to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc094ad7555c5973f6fbdc2f2ccd076a52d62e05e76285ccda98ffd7ec03e383)
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        return typing.cast("AlertingRule", jsii.invoke(self, "addLabel", [label, template]))

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        _scope: _constructs_77d1e7e8.IConstruct,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Associates the alerting rule with a construct that is configuring an APS rule groups namespace.

        :param _scope: The construct handling the configuration of the APS rule groups namespace that will be consuming this rule.

        :return:

        The rendered configuration for the rule as expected by an APS
        rules config file.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2955115f1b55db988b7dc4324cf58a7144e7b04930ccab68410287af9575d8c3)
            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "bind", [_scope]))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> builtins.str:
        '''The name of the alert.

        Must be a valid label value.

        :group: Onputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="expression")
    def expression(self) -> builtins.str:
        '''The PromQL expression to evaluate.

        Every evaluation cycle this is
        evaluated at the current time, and all resultant time series become
        pending/firing alerts.

        :see: `Querying prometheus <https://prometheus.io/docs/prometheus/latest/querying/basics/>`_
        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "expression"))

    @builtins.property
    @jsii.member(jsii_name="period")
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''Alerts are considered firing once they have been returned for this long.

        Alerts which have not yet fired for long enough are considered pending.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "period"))


__all__ = [
    "AlertManagerConfiguration",
    "AlertManagerConfigurationDetails",
    "AlertManagerConfigurationProps",
    "AlertManagerDestination",
    "AlertManagerDestinationCategory",
    "AlertManagerInhibitRule",
    "AlertManagerInhibitRuleProps",
    "AlertManagerMatcher",
    "AlertManagerReceiver",
    "AlertManagerReceiverProps",
    "AlertManagerRoute",
    "AlertManagerRouteProps",
    "AlertManagerSnsDestination",
    "AlertManagerSnsDestinationOptions",
    "AlertManagerSnsDestinationProps",
    "AlertManagerTemplate",
    "AlertingRule",
    "AlertingRuleProps",
    "DayOfMonthRange",
    "DefaultRouteOptions",
    "IAlertManagerConfiguration",
    "IAlertManagerDestination",
    "IPrometheusRule",
    "IRuleGroupConfiguration",
    "IRuleGroupsNamespace",
    "IWorkspace",
    "MatchOperator",
    "MonthRange",
    "PrometheusRule",
    "RecordingRule",
    "RecordingRuleProps",
    "RuleGroup",
    "RuleGroupConfiguration",
    "RuleGroupConfigurationDetails",
    "RuleGroupConfigurationProps",
    "RuleGroupProps",
    "RuleGroupsNamespace",
    "RuleGroupsNamespaceProps",
    "TimeInterval",
    "TimeIntervalEntry",
    "TimeIntervalEntryProps",
    "TimeIntervalProps",
    "TimeRange",
    "Weekday",
    "WeekdayRange",
    "Workspace",
    "WorkspaceAlertingOptions",
    "WorkspaceAttributes",
    "WorkspaceLoggingOptions",
    "WorkspaceProps",
    "YearRange",
]

publication.publish()

def _typecheckingstub__8cbff91d83be6bd8b06b602b6b9e93e20d216e589768f575ab6d1f2c6010e644(
    *,
    contents: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d4829074894e21837337df54d36c60c82b7d149f7979af531bf4d29dd236d80(
    *,
    default_receiver_destinations: typing.Optional[typing.Sequence[IAlertManagerDestination]] = None,
    default_route: typing.Optional[typing.Union[DefaultRouteOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    templates: typing.Optional[typing.Sequence[AlertManagerTemplate]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee96d31190b82fed53dd257897e453fb250f2e84f2cafdfc5897004bf1ed947d(
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    *,
    api_url: typing.Optional[builtins.str] = None,
    attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    message: typing.Optional[builtins.str] = None,
    send_resolved: typing.Optional[builtins.bool] = None,
    subject: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81f98103b29146e8fbc8bfe41a2d240e3fe48039bafda52ef4e8f26431684515(
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e6a19d0395d678236b02437254ceb002b2e26657c7db7413be6a3ac113a2dda(
    scope: AlertManagerConfiguration,
    id: builtins.str,
    options: AlertManagerInhibitRuleProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9fa628986dd21444584b00b1da57d1af20bde0830146d4a141f8a04d44b24f00(
    label: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95de43fa15c0e1d2874d1faf6b8e7b45c8988fce0743890838c588cc983cffa4(
    matcher: AlertManagerMatcher,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66050a8008925fdd455146632a5f6e306152f2a1a2f37c1c9599e82abe003c54(
    matcher: AlertManagerMatcher,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b698f0b2614fc551fd45880c9b42618b6ee68f08904e7e171536c028a659778(
    _scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1958e2d2776995b0606099b11a0abfc6067a6c584e3703f06ff95d07db8c4342(
    label: builtins.str,
    operator: MatchOperator,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbc0f07bb1b51d6e9d9e9fbef0b54e68767eef01649efa7b464285c5c66e4a8f(
    *matchers: AlertManagerMatcher,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7727457f8e9cd1d54293839f5d3bb63124837ef55148e5a1f0df9bc459f7cfca(
    expression: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a51f37103bd47e48b625a8b9832a7d757e752c9649159fb1c46f40eea9fcb512(
    scope: AlertManagerConfiguration,
    id: builtins.str,
    *,
    destinations: typing.Optional[typing.Sequence[IAlertManagerDestination]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3782218a5cd53e73019a7d7c2c9623d18ec1cee9857c8117464f68b7aafc6fd0(
    destination: IAlertManagerDestination,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0dfd5069145da589cc6cbc767044c6239179378d80b7fd92753881b1f11df735(
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    *,
    api_url: typing.Optional[builtins.str] = None,
    attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    message: typing.Optional[builtins.str] = None,
    send_resolved: typing.Optional[builtins.bool] = None,
    subject: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ac98a441ebaa8fcbdcb9c5469de856e47556f94c4e73f48263c58939dad50ba(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f6e4a9ecae47172c07ffd7184db033eb8db2591b447286a1b2d2ae860e4d679(
    *,
    destinations: typing.Optional[typing.Sequence[IAlertManagerDestination]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba61bae0afa027a0ee6be18b7fe8f9ee634f7bbe876990d7245bc50aaa961fa4(
    scope: typing.Union[AlertManagerConfiguration, AlertManagerRoute],
    id: builtins.str,
    *,
    receiver: AlertManagerReceiver,
    active_time_intervals: typing.Optional[typing.Sequence[TimeInterval]] = None,
    children: typing.Optional[typing.Sequence[typing.Union[AlertManagerRouteProps, typing.Dict[builtins.str, typing.Any]]]] = None,
    continue_matching: typing.Optional[builtins.bool] = None,
    group_by_labels: typing.Optional[typing.Sequence[builtins.str]] = None,
    group_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    group_wait: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    matchers: typing.Optional[typing.Sequence[AlertManagerMatcher]] = None,
    mute_time_interval: typing.Optional[typing.Sequence[TimeInterval]] = None,
    repeat_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26acb384bb53e3e0077a8d6e74574177245a4c86f1a91f696ba900c664678fdc(
    interval: TimeInterval,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37e8e9ee32ee666ee145d9f806f323b6c80bfda7e4c6f3262a362bb1aa4e2e82(
    id: builtins.str,
    *,
    receiver: AlertManagerReceiver,
    active_time_intervals: typing.Optional[typing.Sequence[TimeInterval]] = None,
    children: typing.Optional[typing.Sequence[typing.Union[AlertManagerRouteProps, typing.Dict[builtins.str, typing.Any]]]] = None,
    continue_matching: typing.Optional[builtins.bool] = None,
    group_by_labels: typing.Optional[typing.Sequence[builtins.str]] = None,
    group_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    group_wait: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    matchers: typing.Optional[typing.Sequence[AlertManagerMatcher]] = None,
    mute_time_interval: typing.Optional[typing.Sequence[TimeInterval]] = None,
    repeat_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd53318d2eeb548d586de862995148738569b2a2767340a1ea6cd92bef3ab2aa(
    label: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b9926de134f13ac4889ffef4a8f6e81285590988aa52a46eaaa0cc23fd4e250(
    matcher: AlertManagerMatcher,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1afb7cf94d5e98ee6abf4e8ffbc819c3b4fc46c07c67ba8f65a771b70732cd3(
    interval: TimeInterval,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe6542bd8c1f749b66a1b2d8fcf33cce209481ac3117216efa1c416fb46c359d(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed4403f97ffeb1d884d35e8b1f0f3f3255c651c54065c235cfeacf177fdece68(
    *,
    receiver: AlertManagerReceiver,
    active_time_intervals: typing.Optional[typing.Sequence[TimeInterval]] = None,
    children: typing.Optional[typing.Sequence[typing.Union[AlertManagerRouteProps, typing.Dict[builtins.str, typing.Any]]]] = None,
    continue_matching: typing.Optional[builtins.bool] = None,
    group_by_labels: typing.Optional[typing.Sequence[builtins.str]] = None,
    group_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    group_wait: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    matchers: typing.Optional[typing.Sequence[AlertManagerMatcher]] = None,
    mute_time_interval: typing.Optional[typing.Sequence[TimeInterval]] = None,
    repeat_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f8ad7bc7475679a8a60186db7a675c1c4db6fabfe4e6d8df73a36d3d412235b(
    *,
    api_url: typing.Optional[builtins.str] = None,
    attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    message: typing.Optional[builtins.str] = None,
    send_resolved: typing.Optional[builtins.bool] = None,
    subject: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c0e3a4ee3bbc3a8e0a950badb8df7d9d60121def11d541663a23a71003c43a3(
    *,
    api_url: typing.Optional[builtins.str] = None,
    attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    message: typing.Optional[builtins.str] = None,
    send_resolved: typing.Optional[builtins.bool] = None,
    subject: typing.Optional[builtins.str] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b19a5eb26b31e92c60092ec6a9e25f373aca41ed635d8e122efb2eab6e6534e3(
    path: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__196ce0e9e6e6d9241e6ac501cf7d47cdb1158789eaa5445b53deb98d00500cce(
    content: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03dc297f91153127e6c9df441f99357df454a0ee2f67066590733f910102f7dd(
    *,
    alert: builtins.str,
    expression: builtins.str,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91482989802c5a19dcf134e159b07770ae3dcd2b9a7eaeb2a41c792761e2cc85(
    *,
    end: jsii.Number,
    start: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd60c11fc61be6fb2e2d700e6bcb264ce9960081d5dad55964f9bfefc0f0d876(
    *,
    group_by_labels: typing.Optional[typing.Sequence[builtins.str]] = None,
    group_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    group_wait: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    matchers: typing.Optional[typing.Sequence[AlertManagerMatcher]] = None,
    repeat_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecdd2b3fa97fa14b06af1c169056107dd7273a62beafadbdc40f621a744f12dc(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fccab2458beaa98bf6cf63666f8b0850a47aafba67c71c81d78eb861d602cfd4(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75264843e0a175d6d9f62241c774b7b0dc23fbb528c8377d3d828f9348240d69(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b85e972216d5ab9ba29e02fee9f5307ab16999f173250e033ec5bcb371f296b1(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba5b4769c15fcc5ddb1fb353f385695ce6f6dcc4882ac8aa188d97b78edcd64c(
    *,
    start: jsii.Number,
    end: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__766cef3d6a3845efb1243ac0af2147f37bd3a1a549bdddc7dac97e1e44120e0d(
    label: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe9a2d500fce73b7d53b348c34eb739a54714883da2f2c8ebe11d93aa884ceb7(
    _scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cb0a604680ecb8a8589cf7d59a5996ec19c7318e64e54c54b20f83235fd7b3f(
    *,
    expression: builtins.str,
    record: builtins.str,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1c9c0811f780ca66f2de4679bd7d5b37bfd855f049daf852b8f62bdde371c56(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    limit: typing.Optional[jsii.Number] = None,
    name: typing.Optional[builtins.str] = None,
    rules: typing.Optional[typing.Sequence[IPrometheusRule]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9671d71d38146be7045ad22dbd2f4b6b0f0f8e7d085457bff6d369ca1bbe2eee(
    rule: IPrometheusRule,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7d27d9bfa9cf70bc0af9fe809c05983f7493240ca6fa0f0e576cbb7d37b6db9(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82e91dfc0fd2e0edf704b7576497f5b49d4749b49f1dc1995a58f08ac3b5dcd7(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4704d54dcf52ffd4cd19851f0317d64566703de088bdcb472154b8b06f28be6(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    content: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a58b4be87af46f6c4d5dce1b0a2d656b983d133dfcca81aca400c31b65b0e69(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    path: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ec0c2bc99d2f805875d8420ffaf9f0aa72a252b4d9c7777b47250b64f42d62f(
    id: builtins.str,
    *,
    interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    limit: typing.Optional[jsii.Number] = None,
    name: typing.Optional[builtins.str] = None,
    rules: typing.Optional[typing.Sequence[IPrometheusRule]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c6c794bcae38f1d84bd8b1e3c7746816a740f5b4abd71031f02a616d9fc476c(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__423ff5f64b5ebe408959b0544d5db016cecc0971061cfbaec62dc29a5ed5ba3b(
    *,
    content: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1dfec7bd99cc994e9ab03daaa7ce0e1c148ce404cf798008dea766dbcb75887(
    *,
    interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    limit: typing.Optional[jsii.Number] = None,
    name: typing.Optional[builtins.str] = None,
    rules: typing.Optional[typing.Sequence[IPrometheusRule]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d68984d2393848e009717ab81cb791770327c139758dd210de914351de24be89(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    workspace: IWorkspace,
    configuration: typing.Optional[IRuleGroupConfiguration] = None,
    name: typing.Optional[builtins.str] = None,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5291057f47a8ca5ad2b1341e777c2934d4e1bc98b9b6d8c671eb233dd3cf6103(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    arn: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6d7e5d895d2c19465bf669ca6799a1ab2fcf07aafd6fbfa9eea8462b44e9707(
    id: builtins.str,
    *,
    interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    limit: typing.Optional[jsii.Number] = None,
    name: typing.Optional[builtins.str] = None,
    rules: typing.Optional[typing.Sequence[IPrometheusRule]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0252d99982159aab121bf38bd05d671eba3d363a86831dd5866fbbb9a65fcc19(
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    workspace: IWorkspace,
    configuration: typing.Optional[IRuleGroupConfiguration] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac54d46a5938da8c9cafacaf92b4c345c98a627d1e0e6d70a8d8a0eb52bac6c7(
    scope: AlertManagerConfiguration,
    id: builtins.str,
    *,
    intervals: typing.Optional[typing.Sequence[TimeIntervalEntry]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dca86cd7f6c4b9cfc7c95022cd8b943e358006a77068697f3b7aba9ce230ffa(
    interval: TimeIntervalEntry,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e3e34aebd6d40b42aeafae899c87267ebbeaf9f5e87d58ef5078a215ad0054c(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__653ee1759b2d673eb89f130ab38eae34eb8c4e1584d6d23100d54df69bc2b23e(
    start: jsii.Number,
    end: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__589474887b25ca9c5b7606ded92704328f6a1184a304f622245c201406d7f8e1(
    start: jsii.Number,
    end: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1d188b5a8cb4744fd0b3c494f1e0cc47d5e2f126f997cc0ae6bb2734fc18ac2(
    start: builtins.str,
    end: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1259681c2471be930665f6cc67eba92f68e7ad2c267a983872ccbf6bcf35e73(
    start: Weekday,
    end: typing.Optional[Weekday] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f0d149db37d02157b7e1462224eac8c483cea087f1c682da8b1da0b2ecd7a0f(
    start: jsii.Number,
    end: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73ec4c1843ef913457f4d863112ea0340ee6a230f03f9c02ef74ffa53e33b29e(
    _scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b9a052b5276ad2d7a5e17508242117f2139addbf7c5d45e520ea340923e66db(
    *,
    days_of_the_month: typing.Optional[typing.Sequence[typing.Union[DayOfMonthRange, typing.Dict[builtins.str, typing.Any]]]] = None,
    months: typing.Optional[typing.Sequence[typing.Union[MonthRange, typing.Dict[builtins.str, typing.Any]]]] = None,
    times: typing.Optional[typing.Sequence[typing.Union[TimeRange, typing.Dict[builtins.str, typing.Any]]]] = None,
    time_zone: typing.Optional[builtins.str] = None,
    weekdays: typing.Optional[typing.Sequence[typing.Union[WeekdayRange, typing.Dict[builtins.str, typing.Any]]]] = None,
    years: typing.Optional[typing.Sequence[typing.Union[YearRange, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8603e1f17ec7b04585cebbc930584db9fd11d9cc78cbe34150554df2d35cbd25(
    *,
    intervals: typing.Optional[typing.Sequence[TimeIntervalEntry]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a478e81798d1b1aa822391d01c77ed9284d33226685ee1b6d5d1275aa07bf8e0(
    *,
    end: builtins.str,
    start: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86465e2768ad1762de08be5c9445cf1547774e8347024696fa86d083e0fa4890(
    *,
    start: Weekday,
    end: typing.Optional[Weekday] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d4fe17b3dcb4a6fcb28440fce03e66af5d9404414495492548dd6c3f19c756f(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    alerting: typing.Optional[typing.Union[WorkspaceAlertingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    alias: typing.Optional[builtins.str] = None,
    logging: typing.Optional[typing.Union[WorkspaceLoggingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afa461fdd8ffaa5089542c8bf8787f44409787b6a210b3c5c0662d5b35109c72(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    workspace_arn: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60d3199171f1bba437b7d6cbc7eaac9b468af9758e4842e4fa533d977f1acf88(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    workspace_arn: typing.Optional[builtins.str] = None,
    workspace_id: typing.Optional[builtins.str] = None,
    workspace_prometheus_endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcec950a457d984707468fd097b56417f7911b7a161b7157e77c9a693054a2dc(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    workspace_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__785388ec7bcbf0f9ab3ab8d3ff617f372c2690129c81568a2e9b707017a6ccba(
    *,
    configuration: typing.Optional[IAlertManagerConfiguration] = None,
    enabled: typing.Optional[builtins.bool] = None,
    topic: typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de63c6dc380e32c73a45d718b8f3ba6478137a376ad09fda3e0ec44d51707450(
    *,
    workspace_arn: typing.Optional[builtins.str] = None,
    workspace_id: typing.Optional[builtins.str] = None,
    workspace_prometheus_endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24a9a09d43dc6b752a83864df6b27f540223390dc4b583d3187a8d73528a9c81(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
    retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__663c8a2d4f00790605fbddeaa792adad5f229661503aead0b438ae668c8f2707(
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    alerting: typing.Optional[typing.Union[WorkspaceAlertingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    alias: typing.Optional[builtins.str] = None,
    logging: typing.Optional[typing.Union[WorkspaceLoggingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e67ac46d92395cb103d8b149352cf8ca374366ffdec5acce0742f53cae4b5905(
    *,
    start: jsii.Number,
    end: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d99bacfb04fe2086f72d8d29d7cf1687579f214b60ec543eb642086389a30ca8(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    default_receiver_destinations: typing.Optional[typing.Sequence[IAlertManagerDestination]] = None,
    default_route: typing.Optional[typing.Union[DefaultRouteOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    templates: typing.Optional[typing.Sequence[AlertManagerTemplate]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7590ce082c23f9f92412fd7bb9722718830f68a4fc8a172422ef5634d3bf472f(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    content: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5644b887e48459dd08983e2e62f6ccb8df573b33e4ea7d0d3af42ca8a6820eb3(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    path: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3eb236168a9b336359213312200f3f2c2e6cd77e1d8e533383717856a3c8280(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    content: builtins.str,
    templates: typing.Optional[typing.Mapping[builtins.str, AlertManagerTemplate]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94861ea3498df012fb4fd59d621881e412e689c5af1369bfb7475cc9ca6a1617(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    path: builtins.str,
    templates: typing.Optional[typing.Mapping[builtins.str, AlertManagerTemplate]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ca33998aedce1484077babe630881aadd29b719b058906d2828527212f81b59(
    id: builtins.str,
    options: AlertManagerInhibitRuleProps,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4a68231caa2ea4791a5e35d7a6f666d830732ee8b74e95e1bf7389bf85fa76d(
    id: builtins.str,
    *,
    destinations: typing.Optional[typing.Sequence[IAlertManagerDestination]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d849fe7881e1b468a18638fa7ec3eb6f1a50dbef0bcfc71457bdf7c943e78ad(
    template: AlertManagerTemplate,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44d7a0caf75da1abb6088e5a940d0e0be3c1491d2bfd14e771b111c0904826d5(
    id: builtins.str,
    *,
    intervals: typing.Optional[typing.Sequence[TimeIntervalEntry]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a991a76bb93d481d93df85fb2dc0abb33b67a52a57a97a03c1e4435ebcb05db6(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17cdb5aa4b7ef9c8b35c69241804e8c73b44275b1a10f27a8031003e52fb0a95(
    idx: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6fae02e5bd92b712b79c9fa8c6782f6bd95170c1e8ac0e74a055dd7a4c2a24c(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b38cc1bfd7f0a346b16ec49add36b40783575a9cd7dce2517a2cacf55acaaa66(
    _scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a30b40d9be3a465aff37f83c88abbc1c7d7a006d3218abb3ad1e5c53180bb13e(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34fd2af53cf3a3f5bab86839cf37d48466d5cf78d1486a322588694114ce3065(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__513b11e15a6b56a6363e5dfde3b9c7603ca5e60547c9a6c1b1277e282a113cfd(
    label: builtins.str,
    template: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc094ad7555c5973f6fbdc2f2ccd076a52d62e05e76285ccda98ffd7ec03e383(
    label: builtins.str,
    template: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2955115f1b55db988b7dc4324cf58a7144e7b04930ccab68410287af9575d8c3(
    _scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass
