import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_ssm as _aws_cdk_aws_ssm_ceddda9d
import constructs as _constructs_77d1e7e8


class AutomationSchemaVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.ssm.AutomationSchemaVersion",
):
    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, version: builtins.str) -> "AutomationSchemaVersion":
        '''
        :param version: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81b564f0d4d1a1feaa1a92b0eb271ee9be91266f66526eddcc07b827ce2006e1)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        return typing.cast("AutomationSchemaVersion", jsii.sinvoke(cls, "of", [version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_0_3")
    def VER_0_3(cls) -> "AutomationSchemaVersion":
        return typing.cast("AutomationSchemaVersion", jsii.sget(cls, "VER_0_3"))

    @builtins.property
    @jsii.member(jsii_name="version")
    def version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "version"))


@jsii.data_type(
    jsii_type="cdk-extensions.ssm.DocumentBaseProps",
    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "content": "content",
        "document_type": "documentType",
        "name": "name",
        "requires": "requires",
        "target_type": "targetType",
        "update_method": "updateMethod",
        "version_name": "versionName",
    },
)
class DocumentBaseProps(_aws_cdk_ceddda9d.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        content: "IDocumentContent",
        document_type: typing.Optional["DocumentType"] = None,
        name: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Sequence[typing.Union["DocumentRequirement", typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional["DocumentUpdateMethod"] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param content: 
        :param document_type: 
        :param name: 
        :param requires: 
        :param target_type: 
        :param update_method: 
        :param version_name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cbe2dca7c152e90c4dc1f2fc2034605d11d338ff2043c5dcfb0d33d8e9a736c0)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
            check_type(argname="argument document_type", value=document_type, expected_type=type_hints["document_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument requires", value=requires, expected_type=type_hints["requires"])
            check_type(argname="argument target_type", value=target_type, expected_type=type_hints["target_type"])
            check_type(argname="argument update_method", value=update_method, expected_type=type_hints["update_method"])
            check_type(argname="argument version_name", value=version_name, expected_type=type_hints["version_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "content": content,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if document_type is not None:
            self._values["document_type"] = document_type
        if name is not None:
            self._values["name"] = name
        if requires is not None:
            self._values["requires"] = requires
        if target_type is not None:
            self._values["target_type"] = target_type
        if update_method is not None:
            self._values["update_method"] = update_method
        if version_name is not None:
            self._values["version_name"] = version_name

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def content(self) -> "IDocumentContent":
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast("IDocumentContent", result)

    @builtins.property
    def document_type(self) -> typing.Optional["DocumentType"]:
        result = self._values.get("document_type")
        return typing.cast(typing.Optional["DocumentType"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def requires(self) -> typing.Optional[typing.List["DocumentRequirement"]]:
        result = self._values.get("requires")
        return typing.cast(typing.Optional[typing.List["DocumentRequirement"]], result)

    @builtins.property
    def target_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("target_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update_method(self) -> typing.Optional["DocumentUpdateMethod"]:
        result = self._values.get("update_method")
        return typing.cast(typing.Optional["DocumentUpdateMethod"], result)

    @builtins.property
    def version_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("version_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentBaseProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DocumentContent(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.ssm.DocumentContent",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromObject")
    @builtins.classmethod
    def from_object(
        cls,
        *,
        input: typing.Mapping[builtins.str, typing.Any],
    ) -> "IDocumentContent":
        '''
        :param input: 
        '''
        props = ObjectContentProps(input=input)

        return typing.cast("IDocumentContent", jsii.sinvoke(cls, "fromObject", [props]))

    @jsii.member(jsii_name="fromString")
    @builtins.classmethod
    def from_string(
        cls,
        *,
        content: builtins.str,
        document_format: "DocumentFormat",
    ) -> "IDocumentContent":
        '''
        :param content: 
        :param document_format: 
        '''
        props = StringContentProps(content=content, document_format=document_format)

        return typing.cast("IDocumentContent", jsii.sinvoke(cls, "fromString", [props]))


@jsii.data_type(
    jsii_type="cdk-extensions.ssm.DocumentContentResult",
    jsii_struct_bases=[],
    name_mapping={"content": "content", "document_format": "documentFormat"},
)
class DocumentContentResult:
    def __init__(
        self,
        *,
        content: builtins.str,
        document_format: "DocumentFormat",
    ) -> None:
        '''
        :param content: 
        :param document_format: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b54a8eee152cce771bf80713229d7987aeac7e40ff6566e332f41c7a536e7ec)
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
            check_type(argname="argument document_format", value=document_format, expected_type=type_hints["document_format"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "content": content,
            "document_format": document_format,
        }

    @builtins.property
    def content(self) -> builtins.str:
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def document_format(self) -> "DocumentFormat":
        result = self._values.get("document_format")
        assert result is not None, "Required property 'document_format' is missing"
        return typing.cast("DocumentFormat", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentContentResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DocumentFormat(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.ssm.DocumentFormat",
):
    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, value: builtins.str) -> "DocumentFormat":
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ac4de9f0a204e3a34c322090365bc8a0bf5bba2fa4936377e1b7d0e943da16a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DocumentFormat", jsii.sinvoke(cls, "of", [value]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="JSON")
    def JSON(cls) -> "DocumentFormat":
        return typing.cast("DocumentFormat", jsii.sget(cls, "JSON"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TEXT")
    def TEXT(cls) -> "DocumentFormat":
        return typing.cast("DocumentFormat", jsii.sget(cls, "TEXT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="YAML")
    def YAML(cls) -> "DocumentFormat":
        return typing.cast("DocumentFormat", jsii.sget(cls, "YAML"))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk-extensions.ssm.DocumentProps",
    jsii_struct_bases=[DocumentBaseProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "content": "content",
        "document_type": "documentType",
        "name": "name",
        "requires": "requires",
        "target_type": "targetType",
        "update_method": "updateMethod",
        "version_name": "versionName",
    },
)
class DocumentProps(DocumentBaseProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        content: "IDocumentContent",
        document_type: typing.Optional["DocumentType"] = None,
        name: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Sequence[typing.Union["DocumentRequirement", typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional["DocumentUpdateMethod"] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param content: 
        :param document_type: 
        :param name: 
        :param requires: 
        :param target_type: 
        :param update_method: 
        :param version_name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03626c68be6f4cb81292263a32c542107787c652a3eb8a3615e6fad1352894fb)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
            check_type(argname="argument document_type", value=document_type, expected_type=type_hints["document_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument requires", value=requires, expected_type=type_hints["requires"])
            check_type(argname="argument target_type", value=target_type, expected_type=type_hints["target_type"])
            check_type(argname="argument update_method", value=update_method, expected_type=type_hints["update_method"])
            check_type(argname="argument version_name", value=version_name, expected_type=type_hints["version_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "content": content,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if document_type is not None:
            self._values["document_type"] = document_type
        if name is not None:
            self._values["name"] = name
        if requires is not None:
            self._values["requires"] = requires
        if target_type is not None:
            self._values["target_type"] = target_type
        if update_method is not None:
            self._values["update_method"] = update_method
        if version_name is not None:
            self._values["version_name"] = version_name

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def content(self) -> "IDocumentContent":
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast("IDocumentContent", result)

    @builtins.property
    def document_type(self) -> typing.Optional["DocumentType"]:
        result = self._values.get("document_type")
        return typing.cast(typing.Optional["DocumentType"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def requires(self) -> typing.Optional[typing.List["DocumentRequirement"]]:
        result = self._values.get("requires")
        return typing.cast(typing.Optional[typing.List["DocumentRequirement"]], result)

    @builtins.property
    def target_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("target_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update_method(self) -> typing.Optional["DocumentUpdateMethod"]:
        result = self._values.get("update_method")
        return typing.cast(typing.Optional["DocumentUpdateMethod"], result)

    @builtins.property
    def version_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("version_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.ssm.DocumentRequirement",
    jsii_struct_bases=[],
    name_mapping={"document": "document", "version": "version"},
)
class DocumentRequirement:
    def __init__(
        self,
        *,
        document: "IDocument",
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param document: 
        :param version: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e79a4c3bdd468976d20a84ddd3164be0d6939b55894020b79bb93e5390564d1f)
            check_type(argname="argument document", value=document, expected_type=type_hints["document"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "document": document,
        }
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def document(self) -> "IDocument":
        result = self._values.get("document")
        assert result is not None, "Required property 'document' is missing"
        return typing.cast("IDocument", result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentRequirement(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DocumentType(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.ssm.DocumentType",
):
    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, value: builtins.str) -> "DocumentType":
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28c421a33d29c65022a08d61170cc6539cebebff8137f208c83064d342ab9084)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DocumentType", jsii.sinvoke(cls, "of", [value]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPLICATION_CONFIGURATION")
    def APPLICATION_CONFIGURATION(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "APPLICATION_CONFIGURATION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPLICATION_CONFIGURATION_SCHEMA")
    def APPLICATION_CONFIGURATION_SCHEMA(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "APPLICATION_CONFIGURATION_SCHEMA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AUTOMATION")
    def AUTOMATION(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "AUTOMATION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AUTOMATION_CHANGE_TEMPLATE")
    def AUTOMATION_CHANGE_TEMPLATE(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "AUTOMATION_CHANGE_TEMPLATE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="COMMAND")
    def COMMAND(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "COMMAND"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEPLOYMENT_STRATEGY")
    def DEPLOYMENT_STRATEGY(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "DEPLOYMENT_STRATEGY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PACKAGE")
    def PACKAGE(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "PACKAGE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="POLICY")
    def POLICY(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "POLICY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SESSION")
    def SESSION(cls) -> "DocumentType":
        return typing.cast("DocumentType", jsii.sget(cls, "SESSION"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))


class DocumentUpdateMethod(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.ssm.DocumentUpdateMethod",
):
    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, value: builtins.str) -> "DocumentUpdateMethod":
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9018429d719974724099d6429dabbe503df4e63d728b4465a63ada578b5ac9c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DocumentUpdateMethod", jsii.sinvoke(cls, "of", [value]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="NEW_VERSION")
    def NEW_VERSION(cls) -> "DocumentUpdateMethod":
        return typing.cast("DocumentUpdateMethod", jsii.sget(cls, "NEW_VERSION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="REPLACE")
    def REPLACE(cls) -> "DocumentUpdateMethod":
        return typing.cast("DocumentUpdateMethod", jsii.sget(cls, "REPLACE"))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))


@jsii.interface(jsii_type="cdk-extensions.ssm.IDocument")
class IDocument(_aws_cdk_ceddda9d.IResource, typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="documentArn")
    def document_arn(self) -> builtins.str:
        ...

    @builtins.property
    @jsii.member(jsii_name="documentName")
    def document_name(self) -> builtins.str:
        ...


class _IDocumentProxy(
    jsii.proxy_for(_aws_cdk_ceddda9d.IResource), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ssm.IDocument"

    @builtins.property
    @jsii.member(jsii_name="documentArn")
    def document_arn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "documentArn"))

    @builtins.property
    @jsii.member(jsii_name="documentName")
    def document_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "documentName"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDocument).__jsii_proxy_class__ = lambda : _IDocumentProxy


@jsii.interface(jsii_type="cdk-extensions.ssm.IDocumentContent")
class IDocumentContent(typing_extensions.Protocol):
    @jsii.member(jsii_name="bind")
    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> DocumentContentResult:
        '''
        :param scope: -
        '''
        ...


class _IDocumentContentProxy:
    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ssm.IDocumentContent"

    @jsii.member(jsii_name="bind")
    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> DocumentContentResult:
        '''
        :param scope: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__199fdf3ffb03725e06fc06b71d2c3cdccce6f963567c016e5cef3e9cf59b03d1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast(DocumentContentResult, jsii.invoke(self, "bind", [scope]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDocumentContent).__jsii_proxy_class__ = lambda : _IDocumentContentProxy


@jsii.data_type(
    jsii_type="cdk-extensions.ssm.ObjectContentProps",
    jsii_struct_bases=[],
    name_mapping={"input": "input"},
)
class ObjectContentProps:
    def __init__(self, *, input: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''
        :param input: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26d05113d6ee40ae103da01a99d4a38ba082e9ac05ad0495b8999666ce7b679c)
            check_type(argname="argument input", value=input, expected_type=type_hints["input"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "input": input,
        }

    @builtins.property
    def input(self) -> typing.Mapping[builtins.str, typing.Any]:
        result = self._values.get("input")
        assert result is not None, "Required property 'input' is missing"
        return typing.cast(typing.Mapping[builtins.str, typing.Any], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ObjectContentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.ssm.StringContentProps",
    jsii_struct_bases=[],
    name_mapping={"content": "content", "document_format": "documentFormat"},
)
class StringContentProps:
    def __init__(
        self,
        *,
        content: builtins.str,
        document_format: DocumentFormat,
    ) -> None:
        '''
        :param content: 
        :param document_format: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78d24992ff1bb9bd1671ef92df7b07f0ba0d6548ca8bed189a9259a3dba4e4f4)
            check_type(argname="argument content", value=content, expected_type=type_hints["content"])
            check_type(argname="argument document_format", value=document_format, expected_type=type_hints["document_format"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "content": content,
            "document_format": document_format,
        }

    @builtins.property
    def content(self) -> builtins.str:
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def document_format(self) -> DocumentFormat:
        result = self._values.get("document_format")
        assert result is not None, "Required property 'document_format' is missing"
        return typing.cast(DocumentFormat, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StringContentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDocument)
class DocumentBase(
    _aws_cdk_ceddda9d.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.ssm.DocumentBase",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        content: IDocumentContent,
        document_type: typing.Optional[DocumentType] = None,
        name: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Sequence[typing.Union[DocumentRequirement, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[DocumentUpdateMethod] = None,
        version_name: typing.Optional[builtins.str] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param content: 
        :param document_type: 
        :param name: 
        :param requires: 
        :param target_type: 
        :param update_method: 
        :param version_name: 
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b10397b28cc25e73035649723b2967beb7d0672e90ca56e4aef07c5c9af4cdb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DocumentBaseProps(
            content=content,
            document_type=document_type,
            name=name,
            requires=requires,
            target_type=target_type,
            update_method=update_method,
            version_name=version_name,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addRequirement")
    def _add_requirement(
        self,
        *,
        document: IDocument,
        version: typing.Optional[builtins.str] = None,
    ) -> IDocument:
        '''
        :param document: 
        :param version: 
        '''
        requirement = DocumentRequirement(document=document, version=version)

        return typing.cast(IDocument, jsii.invoke(self, "addRequirement", [requirement]))

    @jsii.member(jsii_name="validate")
    def _validate(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "validate", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ARN_FORMAT")
    def ARN_FORMAT(cls) -> _aws_cdk_ceddda9d.ArnFormat:
        return typing.cast(_aws_cdk_ceddda9d.ArnFormat, jsii.sget(cls, "ARN_FORMAT"))

    @builtins.property
    @jsii.member(jsii_name="content")
    def content(self) -> IDocumentContent:
        return typing.cast(IDocumentContent, jsii.get(self, "content"))

    @builtins.property
    @jsii.member(jsii_name="documentArn")
    def document_arn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "documentArn"))

    @builtins.property
    @jsii.member(jsii_name="documentName")
    def document_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "documentName"))

    @builtins.property
    @jsii.member(jsii_name="requires")
    def requires(self) -> typing.List[DocumentRequirement]:
        return typing.cast(typing.List[DocumentRequirement], jsii.get(self, "requires"))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> _aws_cdk_aws_ssm_ceddda9d.CfnDocument:
        return typing.cast(_aws_cdk_aws_ssm_ceddda9d.CfnDocument, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="documentType")
    def document_type(self) -> typing.Optional[DocumentType]:
        return typing.cast(typing.Optional[DocumentType], jsii.get(self, "documentType"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="targetType")
    def target_type(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "targetType"))

    @builtins.property
    @jsii.member(jsii_name="updateMethod")
    def update_method(self) -> typing.Optional[DocumentUpdateMethod]:
        return typing.cast(typing.Optional[DocumentUpdateMethod], jsii.get(self, "updateMethod"))

    @builtins.property
    @jsii.member(jsii_name="versionName")
    def version_name(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "versionName"))


@jsii.interface(jsii_type="cdk-extensions.ssm.IAutomationDocument")
class IAutomationDocument(IDocument, typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="automationDefinitionArn")
    def automation_definition_arn(self) -> builtins.str:
        ...

    @jsii.member(jsii_name="arnForAutomationDefinitionVersion")
    def arn_for_automation_definition_version(
        self,
        version: builtins.str,
    ) -> builtins.str:
        '''
        :param version: -
        '''
        ...


class _IAutomationDocumentProxy(
    jsii.proxy_for(IDocument), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ssm.IAutomationDocument"

    @builtins.property
    @jsii.member(jsii_name="automationDefinitionArn")
    def automation_definition_arn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "automationDefinitionArn"))

    @jsii.member(jsii_name="arnForAutomationDefinitionVersion")
    def arn_for_automation_definition_version(
        self,
        version: builtins.str,
    ) -> builtins.str:
        '''
        :param version: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da2a8c83f3d32545513a53e9df935017bf8b6140d8d53ba77763e1b63678ce0a)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        return typing.cast(builtins.str, jsii.invoke(self, "arnForAutomationDefinitionVersion", [version]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAutomationDocument).__jsii_proxy_class__ = lambda : _IAutomationDocumentProxy


@jsii.implements(IAutomationDocument)
class AutomationDocument(
    DocumentBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.ssm.AutomationDocument",
):
    @jsii.member(jsii_name="fromManaged")
    @builtins.classmethod
    def from_managed(
        cls,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        managed_document_name: builtins.str,
    ) -> IAutomationDocument:
        '''
        :param scope: -
        :param id: -
        :param managed_document_name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2913428e175088edcfd3416b0a543718cca9e0559e4e38012baec31b862899c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument managed_document_name", value=managed_document_name, expected_type=type_hints["managed_document_name"])
        return typing.cast(IAutomationDocument, jsii.sinvoke(cls, "fromManaged", [scope, id, managed_document_name]))

    @jsii.member(jsii_name="arnForAutomationDefinitionVersion")
    def arn_for_automation_definition_version(
        self,
        version: builtins.str,
    ) -> builtins.str:
        '''
        :param version: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c3859bb65665cbe30792dba7941ee2bfbf61730f9a790ba9cfbfff4be37c697)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        return typing.cast(builtins.str, jsii.invoke(self, "arnForAutomationDefinitionVersion", [version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEFAULT_SCHEMA_VERSION")
    def DEFAULT_SCHEMA_VERSION(cls) -> AutomationSchemaVersion:
        return typing.cast(AutomationSchemaVersion, jsii.sget(cls, "DEFAULT_SCHEMA_VERSION"))

    @builtins.property
    @jsii.member(jsii_name="automationDefinitionArn")
    def automation_definition_arn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "automationDefinitionArn"))


class Document(
    DocumentBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.ssm.Document",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        content: IDocumentContent,
        document_type: typing.Optional[DocumentType] = None,
        name: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Sequence[typing.Union[DocumentRequirement, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[DocumentUpdateMethod] = None,
        version_name: typing.Optional[builtins.str] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param content: 
        :param document_type: 
        :param name: 
        :param requires: 
        :param target_type: 
        :param update_method: 
        :param version_name: 
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb4fbcff66b7f1d4bbfcf0c700d68b44ac8b46f63f7bb7d90968f048603e348d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DocumentProps(
            content=content,
            document_type=document_type,
            name=name,
            requires=requires,
            target_type=target_type,
            update_method=update_method,
            version_name=version_name,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])


__all__ = [
    "AutomationDocument",
    "AutomationSchemaVersion",
    "Document",
    "DocumentBase",
    "DocumentBaseProps",
    "DocumentContent",
    "DocumentContentResult",
    "DocumentFormat",
    "DocumentProps",
    "DocumentRequirement",
    "DocumentType",
    "DocumentUpdateMethod",
    "IAutomationDocument",
    "IDocument",
    "IDocumentContent",
    "ObjectContentProps",
    "StringContentProps",
]

publication.publish()

def _typecheckingstub__81b564f0d4d1a1feaa1a92b0eb271ee9be91266f66526eddcc07b827ce2006e1(
    version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cbe2dca7c152e90c4dc1f2fc2034605d11d338ff2043c5dcfb0d33d8e9a736c0(
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    content: IDocumentContent,
    document_type: typing.Optional[DocumentType] = None,
    name: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Sequence[typing.Union[DocumentRequirement, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[DocumentUpdateMethod] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b54a8eee152cce771bf80713229d7987aeac7e40ff6566e332f41c7a536e7ec(
    *,
    content: builtins.str,
    document_format: DocumentFormat,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ac4de9f0a204e3a34c322090365bc8a0bf5bba2fa4936377e1b7d0e943da16a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03626c68be6f4cb81292263a32c542107787c652a3eb8a3615e6fad1352894fb(
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    content: IDocumentContent,
    document_type: typing.Optional[DocumentType] = None,
    name: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Sequence[typing.Union[DocumentRequirement, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[DocumentUpdateMethod] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e79a4c3bdd468976d20a84ddd3164be0d6939b55894020b79bb93e5390564d1f(
    *,
    document: IDocument,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28c421a33d29c65022a08d61170cc6539cebebff8137f208c83064d342ab9084(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9018429d719974724099d6429dabbe503df4e63d728b4465a63ada578b5ac9c2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__199fdf3ffb03725e06fc06b71d2c3cdccce6f963567c016e5cef3e9cf59b03d1(
    scope: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26d05113d6ee40ae103da01a99d4a38ba082e9ac05ad0495b8999666ce7b679c(
    *,
    input: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78d24992ff1bb9bd1671ef92df7b07f0ba0d6548ca8bed189a9259a3dba4e4f4(
    *,
    content: builtins.str,
    document_format: DocumentFormat,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b10397b28cc25e73035649723b2967beb7d0672e90ca56e4aef07c5c9af4cdb(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    content: IDocumentContent,
    document_type: typing.Optional[DocumentType] = None,
    name: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Sequence[typing.Union[DocumentRequirement, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[DocumentUpdateMethod] = None,
    version_name: typing.Optional[builtins.str] = None,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da2a8c83f3d32545513a53e9df935017bf8b6140d8d53ba77763e1b63678ce0a(
    version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2913428e175088edcfd3416b0a543718cca9e0559e4e38012baec31b862899c(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    managed_document_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c3859bb65665cbe30792dba7941ee2bfbf61730f9a790ba9cfbfff4be37c697(
    version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb4fbcff66b7f1d4bbfcf0c700d68b44ac8b46f63f7bb7d90968f048603e348d(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    content: IDocumentContent,
    document_type: typing.Optional[DocumentType] = None,
    name: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Sequence[typing.Union[DocumentRequirement, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[DocumentUpdateMethod] = None,
    version_name: typing.Optional[builtins.str] = None,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass
