import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
import aws_cdk.aws_rds as _aws_cdk_aws_rds_ceddda9d
import constructs as _constructs_77d1e7e8


@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IConnectable)
class DatabaseProxyEndpoint(
    _aws_cdk_ceddda9d.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.rds.DatabaseProxyEndpoint",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_proxy: _aws_cdk_aws_rds_ceddda9d.IDatabaseProxy,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        access: typing.Optional["DatabaseProxyEndpointAccess"] = None,
        name: typing.Optional[builtins.str] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_proxy: 
        :param vpc: 
        :param access: 
        :param name: 
        :param security_groups: 
        :param vpc_subnets: 
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__195ada8b5a01eb7b807a1d48932aa3008d7c3928d8f75490e4c8fc1910ef3d43)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DatabaseProxyEndpointProps(
            database_proxy=database_proxy,
            vpc=vpc,
            access=access,
            name=name,
            security_groups=security_groups,
            vpc_subnets=vpc_subnets,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _aws_cdk_aws_ec2_ceddda9d.Connections:
        '''The network connections associated with this resource.'''
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Connections, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="databaseProxy")
    def database_proxy(self) -> _aws_cdk_aws_rds_ceddda9d.IDatabaseProxy:
        return typing.cast(_aws_cdk_aws_rds_ceddda9d.IDatabaseProxy, jsii.get(self, "databaseProxy"))

    @builtins.property
    @jsii.member(jsii_name="databaseProxyEndpointArn")
    def database_proxy_endpoint_arn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "databaseProxyEndpointArn"))

    @builtins.property
    @jsii.member(jsii_name="databaseProxyEndpointHost")
    def database_proxy_endpoint_host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "databaseProxyEndpointHost"))

    @builtins.property
    @jsii.member(jsii_name="databaseProxyEndpointIsDefault")
    def database_proxy_endpoint_is_default(self) -> _aws_cdk_ceddda9d.IResolvable:
        return typing.cast(_aws_cdk_ceddda9d.IResolvable, jsii.get(self, "databaseProxyEndpointIsDefault"))

    @builtins.property
    @jsii.member(jsii_name="databaseProxyEndpointVpcId")
    def database_proxy_endpoint_vpc_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "databaseProxyEndpointVpcId"))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> _aws_cdk_aws_rds_ceddda9d.CfnDBProxyEndpoint:
        return typing.cast(_aws_cdk_aws_rds_ceddda9d.CfnDBProxyEndpoint, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="vpc")
    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, jsii.get(self, "vpc"))

    @builtins.property
    @jsii.member(jsii_name="vpcSubnets")
    def vpc_subnets(self) -> _aws_cdk_aws_ec2_ceddda9d.SubnetSelection:
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, jsii.get(self, "vpcSubnets"))

    @builtins.property
    @jsii.member(jsii_name="access")
    def access(self) -> typing.Optional["DatabaseProxyEndpointAccess"]:
        return typing.cast(typing.Optional["DatabaseProxyEndpointAccess"], jsii.get(self, "access"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))


class DatabaseProxyEndpointAccess(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.rds.DatabaseProxyEndpointAccess",
):
    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, role: builtins.str) -> "DatabaseProxyEndpointAccess":
        '''
        :param role: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec1e97f3090817e05279b08d6d3d4ec756c2bb8d03642b7788404c4d2d9a13dc)
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
        return typing.cast("DatabaseProxyEndpointAccess", jsii.sinvoke(cls, "of", [role]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="READ_ONLY")
    def READ_ONLY(cls) -> "DatabaseProxyEndpointAccess":
        return typing.cast("DatabaseProxyEndpointAccess", jsii.sget(cls, "READ_ONLY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="READ_WRITE")
    def READ_WRITE(cls) -> "DatabaseProxyEndpointAccess":
        return typing.cast("DatabaseProxyEndpointAccess", jsii.sget(cls, "READ_WRITE"))

    @builtins.property
    @jsii.member(jsii_name="role")
    def role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "role"))


@jsii.data_type(
    jsii_type="cdk-extensions.rds.DatabaseProxyEndpointProps",
    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "database_proxy": "databaseProxy",
        "vpc": "vpc",
        "access": "access",
        "name": "name",
        "security_groups": "securityGroups",
        "vpc_subnets": "vpcSubnets",
    },
)
class DatabaseProxyEndpointProps(_aws_cdk_ceddda9d.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        database_proxy: _aws_cdk_aws_rds_ceddda9d.IDatabaseProxy,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        access: typing.Optional[DatabaseProxyEndpointAccess] = None,
        name: typing.Optional[builtins.str] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param database_proxy: 
        :param vpc: 
        :param access: 
        :param name: 
        :param security_groups: 
        :param vpc_subnets: 
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19c3f0008b43c9b8508101d52f7ea2c02aa18d521c93f21caf39b1303afa2fda)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument database_proxy", value=database_proxy, expected_type=type_hints["database_proxy"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument access", value=access, expected_type=type_hints["access"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "database_proxy": database_proxy,
            "vpc": vpc,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if access is not None:
            self._values["access"] = access
        if name is not None:
            self._values["name"] = name
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def database_proxy(self) -> _aws_cdk_aws_rds_ceddda9d.IDatabaseProxy:
        result = self._values.get("database_proxy")
        assert result is not None, "Required property 'database_proxy' is missing"
        return typing.cast(_aws_cdk_aws_rds_ceddda9d.IDatabaseProxy, result)

    @builtins.property
    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)

    @builtins.property
    def access(self) -> typing.Optional[DatabaseProxyEndpointAccess]:
        result = self._values.get("access")
        return typing.cast(typing.Optional[DatabaseProxyEndpointAccess], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_groups(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseProxyEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "DatabaseProxyEndpoint",
    "DatabaseProxyEndpointAccess",
    "DatabaseProxyEndpointProps",
]

publication.publish()

def _typecheckingstub__195ada8b5a01eb7b807a1d48932aa3008d7c3928d8f75490e4c8fc1910ef3d43(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_proxy: _aws_cdk_aws_rds_ceddda9d.IDatabaseProxy,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    access: typing.Optional[DatabaseProxyEndpointAccess] = None,
    name: typing.Optional[builtins.str] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec1e97f3090817e05279b08d6d3d4ec756c2bb8d03642b7788404c4d2d9a13dc(
    role: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19c3f0008b43c9b8508101d52f7ea2c02aa18d521c93f21caf39b1303afa2fda(
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    database_proxy: _aws_cdk_aws_rds_ceddda9d.IDatabaseProxy,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    access: typing.Optional[DatabaseProxyEndpointAccess] = None,
    name: typing.Optional[builtins.str] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass
