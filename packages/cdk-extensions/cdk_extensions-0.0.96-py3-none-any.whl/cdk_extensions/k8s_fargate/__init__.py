import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_eks as _aws_cdk_aws_eks_ceddda9d
import constructs as _constructs_77d1e7e8
from ..aps import IWorkspace as _IWorkspace_f6ae04ae


class Prometheus(
    _aws_cdk_ceddda9d.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_fargate.Prometheus",
):
    '''Deploys Prometheus into EKS.

    The service is run in Fargate and writes data to Amazon Managed Service for
    Prometheus which provides the backing data store.

    :see: `Official Helm chart documentation <https://github.com/prometheus-community/helm-charts/tree/main/charts/prometheus#readme>`_
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
        workspace: _IWorkspace_f6ae04ae,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        queue_configuration: typing.Optional[typing.Union["QueueConfiguration", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the Prometheus class.

        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
        :param cluster: The EKS cluster where Prometheus should be deployed.
        :param workspace: The Amazon Managed Service for Prometheus workspace where the Prometheus server should sned its data.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param namespace: The Kubernetes namespace where the service should be deployed.
        :param queue_configuration: Configures the queue used to write to Amazon Managed Service for Prometheus.
        :param service_account_name: Name of the Kubernetes service account that should be created and used by Prometheus.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cdac7b94caf42b242ebac85fd1bbce7468574acc49c3071c8ce4e7382766887)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = PrometheusProps(
            cluster=cluster,
            workspace=workspace,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
            namespace=namespace,
            queue_configuration=queue_configuration,
            service_account_name=service_account_name,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.python.classproperty
    @jsii.member(jsii_name="CHART_NAME")
    def CHART_NAME(cls) -> builtins.str:
        '''The name of the Prometheus Helm chart.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CHART_NAME"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CHART_REPOSITORY")
    def CHART_REPOSITORY(cls) -> builtins.str:
        '''The Helm repository providing the chart to be used for installing the Prometheus service.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CHART_REPOSITORY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
    def DEFAULT_NAMESPACE(cls) -> builtins.str:
        '''The default Kubernetes namespace where Prometheus will be installed if an alternative isn't given as input.'''
        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))

    @builtins.property
    @jsii.member(jsii_name="chart")
    def chart(self) -> _aws_cdk_aws_eks_ceddda9d.HelmChart:
        '''The Helm chart that was used to deploy Prometheus.

        :group: Resources
        '''
        return typing.cast(_aws_cdk_aws_eks_ceddda9d.HelmChart, jsii.get(self, "chart"))

    @builtins.property
    @jsii.member(jsii_name="cluster")
    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.Cluster:
        '''The EKS cluster where Prometheus should be deployed.

        :group: Inputs
        '''
        return typing.cast(_aws_cdk_aws_eks_ceddda9d.Cluster, jsii.get(self, "cluster"))

    @builtins.property
    @jsii.member(jsii_name="fargateProfile")
    def fargate_profile(self) -> _aws_cdk_aws_eks_ceddda9d.FargateProfile:
        '''The Fargate profile used for running the service in Fargate.'''
        return typing.cast(_aws_cdk_aws_eks_ceddda9d.FargateProfile, jsii.get(self, "fargateProfile"))

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        '''The Kubernetes namespace where the service should be deployed.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "namespace"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccount")
    def service_account(self) -> _aws_cdk_aws_eks_ceddda9d.ServiceAccount:
        '''The service account that Prometheus will use to gain permissions for Kubernetes and AWS.

        :group: Resources
        '''
        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ServiceAccount, jsii.get(self, "serviceAccount"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccountName")
    def service_account_name(self) -> builtins.str:
        '''Name of the Kubernetes service account that should be created and used by Prometheus.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "serviceAccountName"))

    @builtins.property
    @jsii.member(jsii_name="workspace")
    def workspace(self) -> _IWorkspace_f6ae04ae:
        '''The Amazon Managed Service for Prometheus workspace where the Prometheus server should sned its data.

        :group: Inputs
        '''
        return typing.cast(_IWorkspace_f6ae04ae, jsii.get(self, "workspace"))

    @builtins.property
    @jsii.member(jsii_name="queueConfiguration")
    def queue_configuration(self) -> typing.Optional["QueueConfiguration"]:
        '''Configures the queue used to write to Amazon Managed Service for Prometheus.

        :group: Inputs
        '''
        return typing.cast(typing.Optional["QueueConfiguration"], jsii.get(self, "queueConfiguration"))


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_fargate.PrometheusOptions",
    jsii_struct_bases=[],
    name_mapping={
        "namespace": "namespace",
        "queue_configuration": "queueConfiguration",
        "service_account_name": "serviceAccountName",
    },
)
class PrometheusOptions:
    def __init__(
        self,
        *,
        namespace: typing.Optional[builtins.str] = None,
        queue_configuration: typing.Optional[typing.Union["QueueConfiguration", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional configurations for the Prometheus resource.

        :param namespace: The Kubernetes namespace where the service should be deployed.
        :param queue_configuration: Configures the queue used to write to Amazon Managed Service for Prometheus.
        :param service_account_name: Name of the Kubernetes service account that should be created and used by Prometheus.
        '''
        if isinstance(queue_configuration, dict):
            queue_configuration = QueueConfiguration(**queue_configuration)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9995a4e726490102c0c460daca913369b6436621509069b7ba002894e9d378f2)
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument queue_configuration", value=queue_configuration, expected_type=type_hints["queue_configuration"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if namespace is not None:
            self._values["namespace"] = namespace
        if queue_configuration is not None:
            self._values["queue_configuration"] = queue_configuration
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The Kubernetes namespace where the service should be deployed.'''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def queue_configuration(self) -> typing.Optional["QueueConfiguration"]:
        '''Configures the queue used to write to Amazon Managed Service for Prometheus.'''
        result = self._values.get("queue_configuration")
        return typing.cast(typing.Optional["QueueConfiguration"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''Name of the Kubernetes service account that should be created and used by Prometheus.'''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrometheusOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_fargate.PrometheusProps",
    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps, PrometheusOptions],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "namespace": "namespace",
        "queue_configuration": "queueConfiguration",
        "service_account_name": "serviceAccountName",
        "cluster": "cluster",
        "workspace": "workspace",
    },
)
class PrometheusProps(_aws_cdk_ceddda9d.ResourceProps, PrometheusOptions):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        queue_configuration: typing.Optional[typing.Union["QueueConfiguration", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
        workspace: _IWorkspace_f6ae04ae,
    ) -> None:
        '''
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param namespace: The Kubernetes namespace where the service should be deployed.
        :param queue_configuration: Configures the queue used to write to Amazon Managed Service for Prometheus.
        :param service_account_name: Name of the Kubernetes service account that should be created and used by Prometheus.
        :param cluster: The EKS cluster where Prometheus should be deployed.
        :param workspace: The Amazon Managed Service for Prometheus workspace where the Prometheus server should sned its data.
        '''
        if isinstance(queue_configuration, dict):
            queue_configuration = QueueConfiguration(**queue_configuration)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__172d93f55748285d5ce4033319ff3f8fe96d5b908aca65f4d772dfda8a56a409)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument queue_configuration", value=queue_configuration, expected_type=type_hints["queue_configuration"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument workspace", value=workspace, expected_type=type_hints["workspace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster": cluster,
            "workspace": workspace,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if namespace is not None:
            self._values["namespace"] = namespace
        if queue_configuration is not None:
            self._values["queue_configuration"] = queue_configuration
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The Kubernetes namespace where the service should be deployed.'''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def queue_configuration(self) -> typing.Optional["QueueConfiguration"]:
        '''Configures the queue used to write to Amazon Managed Service for Prometheus.'''
        result = self._values.get("queue_configuration")
        return typing.cast(typing.Optional["QueueConfiguration"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''Name of the Kubernetes service account that should be created and used by Prometheus.'''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.Cluster:
        '''The EKS cluster where Prometheus should be deployed.'''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(_aws_cdk_aws_eks_ceddda9d.Cluster, result)

    @builtins.property
    def workspace(self) -> _IWorkspace_f6ae04ae:
        '''The Amazon Managed Service for Prometheus workspace where the Prometheus server should sned its data.'''
        result = self._values.get("workspace")
        assert result is not None, "Required property 'workspace' is missing"
        return typing.cast(_IWorkspace_f6ae04ae, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrometheusProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_fargate.QueueConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "capacity": "capacity",
        "max_samples_per_send": "maxSamplesPerSend",
        "max_shards": "maxShards",
    },
)
class QueueConfiguration:
    def __init__(
        self,
        *,
        capacity: typing.Optional[jsii.Number] = None,
        max_samples_per_send: typing.Optional[jsii.Number] = None,
        max_shards: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configures the queue used to write to Amazon Managed Service for Prometheus.

        :param capacity: Number of samples to buffer per shard before we block reading of more samples from the WAL. It is recommended to have enough capacity in each shard to buffer several requests to keep throughput up while processing occasional slow remote requests.
        :param max_samples_per_send: Maximum number of samples per send.
        :param max_shards: Maximum number of shards, i.e. amount of concurrency.

        :see: `Remote write configuration <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#remote_write>`_
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59da1c2d60435c8b162df3098859e194ea1037ed72b97d352b573230077ecd50)
            check_type(argname="argument capacity", value=capacity, expected_type=type_hints["capacity"])
            check_type(argname="argument max_samples_per_send", value=max_samples_per_send, expected_type=type_hints["max_samples_per_send"])
            check_type(argname="argument max_shards", value=max_shards, expected_type=type_hints["max_shards"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if capacity is not None:
            self._values["capacity"] = capacity
        if max_samples_per_send is not None:
            self._values["max_samples_per_send"] = max_samples_per_send
        if max_shards is not None:
            self._values["max_shards"] = max_shards

    @builtins.property
    def capacity(self) -> typing.Optional[jsii.Number]:
        '''Number of samples to buffer per shard before we block reading of more samples from the WAL.

        It is recommended to have enough capacity in each
        shard to buffer several requests to keep throughput up while processing
        occasional slow remote requests.
        '''
        result = self._values.get("capacity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_samples_per_send(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of samples per send.'''
        result = self._values.get("max_samples_per_send")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_shards(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of shards, i.e. amount of concurrency.'''
        result = self._values.get("max_shards")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "QueueConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Prometheus",
    "PrometheusOptions",
    "PrometheusProps",
    "QueueConfiguration",
]

publication.publish()

def _typecheckingstub__6cdac7b94caf42b242ebac85fd1bbce7468574acc49c3071c8ce4e7382766887(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
    workspace: _IWorkspace_f6ae04ae,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
    queue_configuration: typing.Optional[typing.Union[QueueConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9995a4e726490102c0c460daca913369b6436621509069b7ba002894e9d378f2(
    *,
    namespace: typing.Optional[builtins.str] = None,
    queue_configuration: typing.Optional[typing.Union[QueueConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__172d93f55748285d5ce4033319ff3f8fe96d5b908aca65f4d772dfda8a56a409(
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
    queue_configuration: typing.Optional[typing.Union[QueueConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_name: typing.Optional[builtins.str] = None,
    cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
    workspace: _IWorkspace_f6ae04ae,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59da1c2d60435c8b162df3098859e194ea1037ed72b97d352b573230077ecd50(
    *,
    capacity: typing.Optional[jsii.Number] = None,
    max_samples_per_send: typing.Optional[jsii.Number] = None,
    max_shards: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass
